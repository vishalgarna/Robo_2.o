'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
import randomstring from 'randomstring';
import SynchronizationListener from '../clients/metaApi/synchronizationListener';
import MetaApiWebsocketClient from '../clients/metaApi/metaApiWebsocket.client';
import LoggerManager from '../logger';
import TerminalHashManager from './terminalHashManager';
import MetatraderAccount from './metatraderAccount';
import { ConditionPromise } from '../helpers/promises';
let TerminalState = class TerminalState extends SynchronizationListener {
    get id() {
        return this._id;
    }
    /**
   * Returns true if MetaApi have connected to MetaTrader terminal
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal
   */ get connected() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.connected, false);
    }
    /**
   * Returns true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to broker
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to
   * broker
   */ get connectedToBroker() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.connectedToBroker, false);
    }
    /**
   * Returns a local copy of account information
   * @returns {MetatraderAccountInformation} local copy of account information
   */ get accountInformation() {
        return this._combinedState.accountInformation;
    }
    /**
   * Returns a local copy of MetaTrader positions opened
   * @returns {Array<MetatraderPosition>} a local copy of MetaTrader positions opened
   */ get positions() {
        const hash = this._combinedState.positionsHash;
        return hash ? Object.values(this._terminalHashManager.getPositionsByHash(hash) || {}) : [];
    }
    /**
   * Returns a local copy of MetaTrader orders opened
   * @returns {Array<MetatraderOrder>} a local copy of MetaTrader orders opened
   */ get orders() {
        const hash = this._combinedState.ordersHash;
        return hash ? Object.values(this._terminalHashManager.getOrdersByHash(hash) || {}) : [];
    }
    /**
   * Returns a local copy of symbol specifications available in MetaTrader trading terminal
   * @returns {Array<MetatraderSymbolSpecification>} a local copy of symbol specifications available in MetaTrader
   * trading terminal
   */ get specifications() {
        const hash = this._combinedState.specificationsHash;
        return hash ? Object.values(this._terminalHashManager.getSpecificationsByHash(this._combinedState.specificationsHash) || {}) : [];
    }
    /**
   * Returns hashes of terminal state data for incremental synchronization
   * @returns {Promise<Object>} promise resolving with hashes of terminal state data
   */ // eslint-disable-next-line complexity
    getHashes() {
        const specificationsHashes = this._terminalHashManager.getLastUsedSpecificationHashes(this._account.server);
        const positionsHashes = this._terminalHashManager.getLastUsedPositionHashes(this._account.id);
        const ordersHashes = this._terminalHashManager.getLastUsedOrderHashes(this._account.id);
        return {
            specificationsHashes: specificationsHashes,
            positionsHashes: positionsHashes,
            ordersHashes: ordersHashes
        };
    }
    /**
   * Returns MetaTrader symbol specification by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolSpecification} MetatraderSymbolSpecification found or undefined if specification for a
   * symbol is not found
   */ specification(symbol) {
        if (this._combinedState.specificationsHash) {
            const state = this._terminalHashManager.getSpecificationsByHash(this._combinedState.specificationsHash);
            return state[symbol];
        } else {
            return null;
        }
    }
    /**
   * Returns MetaTrader symbol price by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolPrice} MetatraderSymbolPrice found or undefined if price for a symbol is not found
   */ price(symbol) {
        return this._combinedState.pricesBySymbol[symbol];
    }
    /**
   * Quote time
   * @typdef {Object} QuoteTime
   * @property {Date} time quote time
   * @property {String} brokerTime quote time in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */ /**
   * Returns time of the last received quote
   * @return {QuoteTime} time of the last received quote
   */ get lastQuoteTime() {
        if (this._combinedState.lastQuoteTime) {
            return {
                time: this._combinedState.lastQuoteTime,
                brokerTime: this._combinedState.lastQuoteBrokerTime
            };
        } else {
            return undefined;
        }
    }
    /**
   * Waits for price to be received
   * @param {string} symbol symbol (e.g. currency pair or an index)
   * @param {number} [timeoutInSeconds] timeout in seconds, default is 30
   * @return {Promise<MetatraderSymbolPrice>} promise resolving with price or undefined if price has not been received
   */ waitForPrice(symbol, timeoutInSeconds = 30) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._waitForPriceResolves[symbol] = _this._waitForPriceResolves[symbol] || [];
            if (!_this.price(symbol)) {
                yield Promise.race([
                    new Promise((res)=>_this._waitForPriceResolves[symbol].push(res)),
                    new Promise((res)=>setTimeout(res, timeoutInSeconds * 1000))
                ]);
            }
            return _this.price(symbol);
        })();
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   */ onConnected(instanceIndex) {
        this._getState(instanceIndex).connected = true;
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */ onDisconnected(instanceIndex) {
        let state = this._getState(instanceIndex);
        state.connected = false;
        state.connectedToBroker = false;
    }
    /**
   * Invoked when broker connection status have changed
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} connected is MetaTrader terminal is connected to broker
   */ onBrokerConnectionStatusChanged(instanceIndex, connected) {
        this._combinedState.lastStatusTime = Date.now();
        this._getState(instanceIndex).connectedToBroker = connected;
    }
    /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {string} instanceIndex index of an account instance connected
   * @param {string} specificationsHash specifications hash
   * @param {string} positionsHash positions hash
   * @param {string} ordersHash orders hash
   * @param {string} synchronizationId synchronization id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, synchronizationId) {
        const unsynchronizedStates = this._getStateIndicesOfSameInstanceNumber(instanceIndex).filter((stateIndex)=>!this._stateByInstanceIndex[stateIndex].ordersInitialized);
        unsynchronizedStates.sort((a, b)=>b.lastSyncUpdateTime - a.lastSyncUpdateTime);
        unsynchronizedStates.slice(1).forEach((stateIndex)=>this._removeState(stateIndex));
        let state = this._getState(instanceIndex);
        state.isSpecificationsExpected = !specificationsHash;
        state.isPositionsExpected = !positionsHash;
        state.isOrdersExpected = !ordersHash;
        state.lastSyncUpdateTime = Date.now();
        state.accountInformation = undefined;
        state.pricesBySymbol = {};
        state.positions = [];
        if (!positionsHash) {
            state.positionsInitialized = false;
            state.positionsHash = null;
        } else {
            state.positionsHash = positionsHash;
        }
        state.orders = [];
        if (!ordersHash) {
            state.ordersInitialized = false;
            state.ordersHash = null;
        } else {
            state.ordersHash = ordersHash;
        }
        state.specificationsBySymbol = {};
        if (!specificationsHash) {
            this._logger.trace(()=>`${this._account.id}:${instanceIndex}:${synchronizationId}: cleared specifications ` + 'on synchronization start');
            state.specificationsHash = null;
        } else {
            this._logger.trace(()=>`${this._account.id}:${instanceIndex}:${synchronizationId}: no need to clear ` + `specifications on synchronization start, ${Object.keys(state.specificationsBySymbol || {}).length} ` + 'specifications reused');
            state.specificationsHash = specificationsHash;
        }
    }
    /**
   * Invoked when MetaTrader account information is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
   */ onAccountInformationUpdated(instanceIndex, accountInformation) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        state.accountInformation = accountInformation;
        if (accountInformation) {
            this._combinedState.accountInformation = Object.assign({}, accountInformation);
        }
    }
    /**
   * Invoked when the positions are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderPosition>} positions updated array of positions
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsReplaced(instanceIndex, positions) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        if (state.isPositionsExpected) {
            state.positions = positions;
        }
    }
    /**
   * Invoked when position synchronization fnished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.positionsInitialized = true;
    }
    /**
   * Invoked when MetaTrader positions are updated
   * @param {string} instanceIndex index of an account instance connected
   * @param {MetatraderPosition[]} positions updated MetaTrader positions
   * @param {string[]} removedPositionIds removed position ids
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsUpdated(instanceIndex, positions, removedPositionIds) {
        var _this = this;
        return _async_to_generator(function*() {
            let instanceState = _this._getState(instanceIndex);
            _this._refreshStateUpdateTime(instanceIndex);
            const date = Date.now();
            removedPositionIds.forEach((id)=>_this._combinedState.removedPositions[id] = date);
            positions = _this._filterRemovedPositions(positions);
            Object.keys(_this._combinedState.removedPositions).forEach((id)=>{
                if (_this._combinedState.removedPositions[id] < date - 24 * 60 * 60 * 1000) {
                    delete _this._combinedState.removedPositions[id];
                }
            });
            if (instanceState.ordersInitialized) {
                const updatePositions = function() {
                    var _ref = _async_to_generator(function*(state, instance) {
                        const hash = yield _this._terminalHashManager.updatePositions(_this._account.id, _this._account.type, _this._id, instance, positions, removedPositionIds, state.positionsHash);
                        state.positionsHash = hash;
                    });
                    return function updatePositions(state, instance) {
                        return _ref.apply(this, arguments);
                    };
                }();
                yield updatePositions(instanceState, instanceIndex);
                yield updatePositions(_this._combinedState, _this._combinedInstanceIndex);
            } else {
                instanceState.positions = instanceState.positions.filter((position)=>!removedPositionIds.includes(position.id));
                positions.forEach((position)=>{
                    let index = instanceState.positions.findIndex((p)=>p.id === position.id);
                    if (index !== -1) {
                        instanceState.positions[index] = position;
                    } else {
                        instanceState.positions.push(position);
                    }
                });
            }
        })();
    }
    /**
   * Invoked when the orders are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderOrder>} orders updated array of pending orders
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPendingOrdersReplaced(instanceIndex, orders) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        if (state.isOrdersExpected) {
            state.orders = orders;
        }
    }
    /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ // eslint-disable-next-line complexity, max-statements
    onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
        var _this = this;
        return _async_to_generator(function*() {
            let state = _this._getState(instanceIndex);
            state.positionsInitialized = true;
            state.ordersInitialized = true;
            _this._combinedState.accountInformation = state.accountInformation ? Object.assign({}, state.accountInformation) : undefined;
            state.positions = _this._filterRemovedPositions(state.positions);
            if (state.positions.length) {
                const hash = _this._terminalHashManager.recordPositions(_this._account.id, _this._account.type, _this._id, instanceIndex, state.positions);
                state.positionsHash = hash;
                _this._combinedState.positions = (state.positions || []).map((p)=>Object.assign({}, p));
                _this._combinedState.positionsHash = hash;
            } else if (state.positionsHash) {
                _this._terminalHashManager.removePositionReference(_this.id, instanceIndex);
                _this._terminalHashManager.addPositionReference(state.positionsHash, _this.id, instanceIndex);
                _this._combinedState.positionsHash = state.positionsHash;
                _this._terminalHashManager.removePositionReference(_this.id, _this._combinedInstanceIndex);
                _this._terminalHashManager.addPositionReference(state.positionsHash, _this.id, _this._combinedInstanceIndex);
            }
            state.orders = _this._filterRemovedOrders(state.orders);
            if (state.orders.length) {
                const hash = _this._terminalHashManager.recordOrders(_this._account.id, _this._account.type, _this._id, instanceIndex, state.orders);
                state.ordersHash = hash;
                _this._combinedState.orders = (state.orders || []).map((o)=>Object.assign({}, o));
                _this._combinedState.ordersHash = hash;
            } else if (state.ordersHash) {
                _this._terminalHashManager.removeOrderReference(_this.id, instanceIndex);
                _this._terminalHashManager.addOrderReference(state.ordersHash, _this.id, instanceIndex);
                _this._combinedState.ordersHash = state.ordersHash;
                _this._terminalHashManager.removeOrderReference(_this.id, _this._combinedInstanceIndex);
                _this._terminalHashManager.addOrderReference(state.ordersHash, _this.id, _this._combinedInstanceIndex);
            }
            _this._logger.trace(()=>`${_this._account.id}:${instanceIndex}:${synchronizationId}: assigned specifications to ` + 'combined state from ' + `${instanceIndex}, ${Object.keys(state.specificationsBySymbol || {}).length} specifications assigned`);
            _this._combinedState.positionsInitialized = true;
            _this._combinedState.ordersInitialized = true;
            if (Object.keys(state.specificationsBySymbol || {}).length) {
                if (state.isSpecificationsExpected) {
                    const hash = yield _this._terminalHashManager.recordSpecifications(_this._account.server, _this._account.type, _this._id, instanceIndex, Object.values(state.specificationsBySymbol));
                    _this._combinedState.specificationsHash = hash;
                    state.specificationsHash = hash;
                    state.specificationsBySymbol = null;
                } else if (state.specificationsHash) {
                    const hash = yield _this._terminalHashManager.updateSpecifications(_this._account.server, _this._account.type, _this._id, instanceIndex, Object.values(state.specificationsBySymbol), [], state.specificationsHash);
                    state.specificationsHash = hash;
                }
            } else if (state.specificationsHash) {
                _this._terminalHashManager.removeSpecificationReference(_this.id, instanceIndex);
                _this._terminalHashManager.addSpecificationReference(state.specificationsHash, _this.id, instanceIndex);
                _this._combinedState.specificationsHash = state.specificationsHash;
                _this._terminalHashManager.removeSpecificationReference(_this.id, _this._combinedInstanceIndex);
                _this._terminalHashManager.addSpecificationReference(state.specificationsHash, _this.id, _this._combinedInstanceIndex);
            }
            for (let stateIndex of _this._getStateIndicesOfSameInstanceNumber(instanceIndex)){
                if (!_this._stateByInstanceIndex[stateIndex].connected) {
                    _this._removeState(stateIndex);
                }
            }
        })();
    }
    /**
   * Invoked when MetaTrader pending orders are updated or completed
   * @param {string} instanceIndex index of an account instance connected
   * @param {MetatraderOrder[]} orders updated MetaTrader pending orders
   * @param {string[]} completedOrderIds completed MetaTrader pending order ids
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPendingOrdersUpdated(instanceIndex, orders, completedOrderIds) {
        var _this = this;
        return _async_to_generator(function*() {
            let instanceState = _this._getState(instanceIndex);
            _this._refreshStateUpdateTime(instanceIndex);
            const date = Date.now();
            completedOrderIds.forEach((id)=>_this._combinedState.completedOrders[id] = date);
            orders = _this._filterRemovedOrders(orders);
            Object.keys(_this._combinedState.completedOrders).forEach((id)=>{
                if (_this._combinedState.completedOrders[id] < date - 24 * 60 * 60 * 1000) {
                    delete _this._combinedState.completedOrders[id];
                }
            });
            if (instanceState.ordersInitialized) {
                const updatePendingOrders = function() {
                    var _ref = _async_to_generator(function*(state, instance) {
                        const hash = yield _this._terminalHashManager.updateOrders(_this._account.id, _this._account.type, _this._id, instance, orders, completedOrderIds, state.ordersHash);
                        state.ordersHash = hash;
                    });
                    return function updatePendingOrders(state, instance) {
                        return _ref.apply(this, arguments);
                    };
                }();
                yield updatePendingOrders(instanceState, instanceIndex);
                yield updatePendingOrders(_this._combinedState, _this._combinedInstanceIndex);
            } else {
                instanceState.orders = instanceState.orders.filter((order)=>!completedOrderIds.includes(order.id));
                orders.forEach((order)=>{
                    let index = instanceState.orders.findIndex((o)=>o.id === order.id);
                    if (index !== -1) {
                        instanceState.orders[index] = order;
                    } else {
                        instanceState.orders.push(order);
                    }
                });
            }
        })();
    }
    /**
   * Invoked when a symbol specification was updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */ onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
        var _this = this;
        return _async_to_generator(function*() {
            let instanceState = _this._getState(instanceIndex);
            _this._refreshStateUpdateTime(instanceIndex);
            if (!instanceState.ordersInitialized) {
                for (let specification of specifications){
                    instanceState.specificationsBySymbol[specification.symbol] = specification;
                }
            } else {
                const hash = _this._terminalHashManager.updateSpecifications(_this._account.server, _this._account.type, _this._id, instanceIndex, specifications, removedSymbols, instanceState.specificationsHash);
                instanceState.specificationsHash = hash;
                const combinedHash = _this._terminalHashManager.updateSpecifications(_this._account.server, _this._account.type, _this._id, _this._combinedInstanceIndex, specifications, removedSymbols, _this._combinedState.specificationsHash);
                _this._combinedState.specificationsHash = combinedHash;
            }
            _this._logger.trace(()=>`${_this._account.id}:${instanceIndex}: updated ${specifications.length} specifications, ` + `removed ${removedSymbols.length} specifications. There are ` + `${Object.keys(instanceState.specificationsBySymbol || {}).length} specifications after update`);
        })();
    }
    /**
   * Invoked when prices for several symbols were updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderSymbolPrice>} prices updated MetaTrader symbol prices
   * @param {Number} equity account liquidation value
   * @param {Number} margin margin used
   * @param {Number} freeMargin free margin
   * @param {Number} marginLevel margin level calculated as % of equity/margin
   */ // eslint-disable-next-line complexity
    onSymbolPricesUpdated(instanceIndex, prices, equity, margin, freeMargin, marginLevel) {
        let instanceState = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        // eslint-disable-next-line complexity,max-statements
        const updateSymbolPrices = (state)=>{
            let pricesInitialized = false;
            let priceUpdated = false;
            for (let price of prices || []){
                let currentPrice = state.pricesBySymbol[price.symbol];
                if (currentPrice && currentPrice.time.getTime() > price.time.getTime()) {
                    continue;
                } else {
                    priceUpdated = true;
                }
                if (!state.lastQuoteTime || state.lastQuoteTime.getTime() < price.time.getTime()) {
                    state.lastQuoteTime = price.time;
                    state.lastQuoteBrokerTime = price.brokerTime;
                }
                state.pricesBySymbol[price.symbol] = price;
                const allPositions = Object.values(this._terminalHashManager.getPositionsByHash(state.positionsHash) || {});
                const allOrders = Object.values(this._terminalHashManager.getOrdersByHash(state.ordersHash) || {});
                let positions = allPositions.filter((p)=>p.symbol === price.symbol);
                let otherPositions = allPositions.filter((p)=>p.symbol !== price.symbol);
                let orders = allOrders.filter((o)=>o.symbol === price.symbol);
                pricesInitialized = true;
                for (let position of otherPositions){
                    let p = state.pricesBySymbol[position.symbol];
                    if (p) {
                        if (position.unrealizedProfit === undefined) {
                            this._updatePositionProfits(position, p);
                        }
                    } else {
                        pricesInitialized = false;
                    }
                }
                for (let position of positions){
                    this._updatePositionProfits(position, price);
                }
                for (let order of orders){
                    order.currentPrice = order.type === 'ORDER_TYPE_BUY' || order.type === 'ORDER_TYPE_BUY_LIMIT' || order.type === 'ORDER_TYPE_BUY_STOP' || order.type === 'ORDER_TYPE_BUY_STOP_LIMIT' ? price.ask : price.bid;
                }
                let priceResolves = this._waitForPriceResolves[price.symbol] || [];
                if (priceResolves.length) {
                    for (let resolve of priceResolves){
                        resolve();
                    }
                    delete this._waitForPriceResolves[price.symbol];
                }
            }
            if (priceUpdated && state.accountInformation) {
                const positions = Object.values(this._terminalHashManager.getPositionsByHash(state.positionsHash) || {});
                if (state.positionsInitialized && pricesInitialized) {
                    if (state.accountInformation.platform === 'mt5') {
                        state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + positions.reduce((acc, p)=>acc + Math.round((p.unrealizedProfit || 0) * 100) / 100 + Math.round((p.swap || 0) * 100) / 100, 0);
                    } else {
                        state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + positions.reduce((acc, p)=>acc + Math.round((p.swap || 0) * 100) / 100 + Math.round((p.commission || 0) * 100) / 100 + Math.round((p.unrealizedProfit || 0) * 100) / 100, 0);
                    }
                    state.accountInformation.equity = Math.round(state.accountInformation.equity * 100) / 100;
                } else {
                    state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.equity;
                }
                state.accountInformation.margin = margin !== undefined ? margin : state.accountInformation.margin;
                state.accountInformation.freeMargin = freeMargin !== undefined ? freeMargin : state.accountInformation.freeMargin;
                state.accountInformation.marginLevel = freeMargin !== undefined ? marginLevel : state.accountInformation.marginLevel;
            }
        };
        updateSymbolPrices(instanceState);
        updateSymbolPrices(this._combinedState);
        for (let price of prices){
            for (let call of Object.values(this._processThrottledQuotesCalls)){
                var _call_expectedSymbols;
                this._logger.trace(`${this._account.id}:${instanceIndex}: refreshed ${price.symbol} price`);
                (_call_expectedSymbols = call.expectedSymbols) === null || _call_expectedSymbols === void 0 ? void 0 : _call_expectedSymbols.delete(price.symbol);
                call.receivedSymbols.add(price.symbol);
                call.promise.check();
            }
        }
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onStreamClosed(instanceIndex) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._stateByInstanceIndex[instanceIndex]) {
                for (let stateIndex of _this._getStateIndicesOfSameInstanceNumber(instanceIndex)){
                    const instanceState = _this._stateByInstanceIndex[stateIndex];
                    if (!_this._stateByInstanceIndex[instanceIndex].ordersInitialized && _this._stateByInstanceIndex[instanceIndex].lastSyncUpdateTime <= instanceState.lastSyncUpdateTime) {
                        _this._removeState(instanceIndex);
                        break;
                    }
                    if (instanceState.connected && instanceState.ordersInitialized) {
                        _this._removeState(instanceIndex);
                        break;
                    }
                }
            }
        })();
    }
    /**
   * Forces refresh of most recent quote updates for symbols subscribed to by the terminal, and waits for them all to
   * be processed by this terminal state. This method does not waits for all other listeners to receive and process the
   * quote updates
   * @param {RefreshTerminalStateOptions} [options] additional options
   * @returns {Promise} promise resolving when the terminal state received and processed the latest quotes
   */ refreshTerminalState(options) {
        var _this = this;
        return _async_to_generator(function*() {
            let callData = {
                receivedSymbols: new Set()
            };
            let callId = randomstring.generate(8);
            _this._processThrottledQuotesCalls[callId] = callData;
            callData.promise = new ConditionPromise(()=>callData.expectedSymbols && !callData.expectedSymbols.size);
            var _options_timeoutInSeconds;
            callData.promise.timeout(1000 * ((_options_timeoutInSeconds = options === null || options === void 0 ? void 0 : options.timeoutInSeconds) !== null && _options_timeoutInSeconds !== void 0 ? _options_timeoutInSeconds : 10), 'refreshing terminal state timed out');
            try {
                let symbols = yield Promise.race([
                    _this._websocketClient.refreshTerminalState(_this._account.id),
                    callData.promise // will only throw timeout error at this point
                ]);
                _this._logger.debug(`${_this._account.id}: expecting for ${symbols.length ? symbols : 0} symbols to refresh`);
                let expectedSymbols = new Set();
                for (let symbol of symbols){
                    if (!callData.receivedSymbols.has(symbol)) {
                        expectedSymbols.add(symbol);
                    }
                }
                callData.expectedSymbols = expectedSymbols;
                callData.promise.check();
                yield callData.promise;
            } finally{
                delete _this._processThrottledQuotesCalls[callId];
            }
        })();
    }
    /**
   * Removes connection related data from terminal hash manager
   */ close() {
        Object.keys(this._stateByInstanceIndex).forEach((instanceIndex)=>{
            this._removeFromHashManager(instanceIndex);
        });
        this._removeFromHashManager(this._combinedInstanceIndex);
    }
    // resets combined state and removes from hash manager if has been disconnected for a long time
    _checkCombinedStateActivityJob() {
        if (!this.connectedToBroker && this._combinedState.lastStatusTime < Date.now() - 30 * 60 * 1000) {
            this._removeFromHashManager(this._combinedInstanceIndex);
            this._combinedState.accountInformation = undefined;
            this._combinedState.specificationsBySymbol = null;
            this._combinedState.pricesBySymbol = {};
            this._combinedState.specificationsHash = null;
            this._combinedState.orders = [];
            this._combinedState.ordersHash = null;
            this._combinedState.positions = [];
            this._combinedState.positionsHash = null;
            this._combinedState.ordersInitialized = false;
            this._combinedState.positionsInitialized = false;
            this._combinedState.lastStatusTime = 0;
            this._combinedState.lastQuoteTime = undefined;
            this._combinedState.lastQuoteBrokerTime = undefined;
        }
    }
    _removeState(instanceIndex) {
        delete this._stateByInstanceIndex[instanceIndex];
        this._removeFromHashManager(instanceIndex);
    }
    _removeFromHashManager(instanceIndex) {
        this._terminalHashManager.removeConnectionReferences(this._account.server, this._account.id, this._id, instanceIndex);
    }
    _refreshStateUpdateTime(instanceIndex) {
        const state = this._stateByInstanceIndex[instanceIndex];
        if (state && state.ordersInitialized) {
            state.lastSyncUpdateTime = Date.now();
        }
    }
    _getStateIndicesOfSameInstanceNumber(instanceIndex) {
        const region = instanceIndex.split(':')[0];
        const instanceNumber = instanceIndex.split(':')[1];
        return Object.keys(this._stateByInstanceIndex).filter((stateInstanceIndex)=>stateInstanceIndex.startsWith(`${region}:${instanceNumber}:`) && instanceIndex !== stateInstanceIndex);
    }
    // eslint-disable-next-line complexity
    _updatePositionProfits(position, price) {
        let specification = this.specification(position.symbol);
        if (specification) {
            let multiplier = Math.pow(10, specification.digits);
            if (position.profit !== undefined) {
                position.profit = Math.round(position.profit * multiplier) / multiplier;
            }
            if (position.unrealizedProfit === undefined || position.realizedProfit === undefined) {
                position.unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (position.currentPrice - position.openPrice) * position.currentTickValue * position.volume / specification.tickSize;
                position.unrealizedProfit = Math.round(position.unrealizedProfit * multiplier) / multiplier;
                position.realizedProfit = position.profit - position.unrealizedProfit;
            }
            let newPositionPrice = position.type === 'POSITION_TYPE_BUY' ? price.bid : price.ask;
            let isProfitable = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice);
            let currentTickValue = isProfitable > 0 ? price.profitTickValue : price.lossTickValue;
            let unrealizedProfit = (position.type === 'POSITION_TYPE_BUY' ? 1 : -1) * (newPositionPrice - position.openPrice) * currentTickValue * position.volume / specification.tickSize;
            unrealizedProfit = Math.round(unrealizedProfit * multiplier) / multiplier;
            position.unrealizedProfit = unrealizedProfit;
            position.profit = position.unrealizedProfit + position.realizedProfit;
            position.profit = Math.round(position.profit * multiplier) / multiplier;
            position.currentPrice = newPositionPrice;
            position.currentTickValue = currentTickValue;
        }
    }
    _filterRemovedPositions(positions) {
        return positions.filter((position)=>!this._combinedState.removedPositions[position.id]);
    }
    _filterRemovedOrders(orders) {
        return orders.filter((order)=>!this._combinedState.completedOrders[order.id]);
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex['' + instanceIndex]) {
            this._logger.trace(`${this._account.id}:${instanceIndex}: constructed new state`);
            this._stateByInstanceIndex['' + instanceIndex] = this._constructTerminalState(instanceIndex);
        }
        return this._stateByInstanceIndex['' + instanceIndex];
    }
    _constructTerminalState(instanceIndex) {
        return {
            instanceIndex,
            connected: false,
            connectedToBroker: false,
            accountInformation: undefined,
            positions: [],
            orders: [],
            specificationsBySymbol: {},
            pricesBySymbol: {},
            ordersInitialized: false,
            positionsInitialized: false,
            lastSyncUpdateTime: 0,
            positionsHash: null,
            ordersHash: null,
            specificationsHash: null,
            isSpecificationsExpected: true,
            isPositionsExpected: true,
            isOrdersExpected: true,
            lastQuoteTime: undefined,
            lastQuoteBrokerTime: undefined
        };
    }
    /**
   * Constructs the instance of terminal state class
   * @param {MetatraderAccount} account mt account
   * @param {TerminalHashManager} terminalHashManager terminal hash manager
   * @param {MetaApiWebsocketClient} websocketClient websocket client
   */ constructor(account, terminalHashManager, websocketClient){
        super();
        this._id = randomstring.generate(32);
        this._account = account;
        this._terminalHashManager = terminalHashManager;
        this._websocketClient = websocketClient;
        this._stateByInstanceIndex = {};
        this._waitForPriceResolves = {};
        this._combinedInstanceIndex = 'combined';
        this._combinedState = {
            accountInformation: undefined,
            positions: [],
            orders: [],
            specificationsBySymbol: null,
            pricesBySymbol: {},
            removedPositions: {},
            completedOrders: {},
            specificationsHash: null,
            positionsHash: null,
            ordersHash: null,
            ordersInitialized: false,
            positionsInitialized: false,
            lastStatusTime: 0,
            lastQuoteTime: undefined,
            lastQuoteBrokerTime: undefined
        };
        this._processThrottledQuotesCalls = {};
        this._logger = LoggerManager.getLogger('TerminalState');
        this._checkCombinedStateActivityJob = this._checkCombinedStateActivityJob.bind(this);
        setInterval(this._checkCombinedStateActivityJob, 5 * 60 * 1000);
    }
};
/**
 * Responsible for storing a local copy of remote terminal state
 */ export { TerminalState as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciBmcm9tICcuLi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uTGlzdGVuZXInO1xuaW1wb3J0IE1ldGFBcGlXZWJzb2NrZXRDbGllbnQgZnJvbSAnLi4vY2xpZW50cy9tZXRhQXBpL21ldGFBcGlXZWJzb2NrZXQuY2xpZW50JztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgVGVybWluYWxIYXNoTWFuYWdlciBmcm9tICcuL3Rlcm1pbmFsSGFzaE1hbmFnZXInO1xuaW1wb3J0IE1ldGF0cmFkZXJBY2NvdW50IGZyb20gJy4vbWV0YXRyYWRlckFjY291bnQnO1xuaW1wb3J0IHtDb25kaXRpb25Qcm9taXNlfSBmcm9tICcuLi9oZWxwZXJzL3Byb21pc2VzJztcblxuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhIGxvY2FsIGNvcHkgb2YgcmVtb3RlIHRlcm1pbmFsIHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsU3RhdGUgZXh0ZW5kcyBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlIG9mIHRlcm1pbmFsIHN0YXRlIGNsYXNzXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnR9IGFjY291bnQgbXQgYWNjb3VudFxuICAgKiBAcGFyYW0ge1Rlcm1pbmFsSGFzaE1hbmFnZXJ9IHRlcm1pbmFsSGFzaE1hbmFnZXIgdGVybWluYWwgaGFzaCBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gd2Vic29ja2V0Q2xpZW50IHdlYnNvY2tldCBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFjY291bnQsIHRlcm1pbmFsSGFzaE1hbmFnZXIsIHdlYnNvY2tldENsaWVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX2FjY291bnQgPSBhY2NvdW50O1xuICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIgPSB0ZXJtaW5hbEhhc2hNYW5hZ2VyO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudCA9IHdlYnNvY2tldENsaWVudDtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgIHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzID0ge307XG4gICAgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4ID0gJ2NvbWJpbmVkJztcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlID0ge1xuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IG51bGwsXG4gICAgICBwcmljZXNCeVN5bWJvbDoge30sXG4gICAgICByZW1vdmVkUG9zaXRpb25zOiB7fSxcbiAgICAgIGNvbXBsZXRlZE9yZGVyczoge30sXG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2g6IG51bGwsXG4gICAgICBwb3NpdGlvbnNIYXNoOiBudWxsLFxuICAgICAgb3JkZXJzSGFzaDogbnVsbCxcbiAgICAgIG9yZGVyc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIGxhc3RTdGF0dXNUaW1lOiAwLFxuICAgICAgbGFzdFF1b3RlVGltZTogdW5kZWZpbmVkLFxuICAgICAgbGFzdFF1b3RlQnJva2VyVGltZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHMgPSB7fTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignVGVybWluYWxTdGF0ZScpO1xuICAgIHRoaXMuX2NoZWNrQ29tYmluZWRTdGF0ZUFjdGl2aXR5Sm9iID0gdGhpcy5fY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IuYmluZCh0aGlzKTtcbiAgICBzZXRJbnRlcnZhbCh0aGlzLl9jaGVja0NvbWJpbmVkU3RhdGVBY3Rpdml0eUpvYiwgNSAqIDYwICogMTAwMCk7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICovXG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiBhY2MgfHwgcy5jb25uZWN0ZWQsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgTWV0YUFwaSBoYXZlIGNvbm5lY3RlZCB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIGFuZCBNZXRhVHJhZGVyIHRlcm1pbmFsIGlzIGNvbm5lY3RlZCB0byBicm9rZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgYW5kIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29ubmVjdGVkIHRvXG4gICAqIGJyb2tlclxuICAgKi9cbiAgZ2V0IGNvbm5lY3RlZFRvQnJva2VyKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5yZWR1Y2UoKGFjYywgcykgPT4gYWNjIHx8IHMuY29ubmVjdGVkVG9Ccm9rZXIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWwgY29weSBvZiBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIHtNZXRhdHJhZGVyQWNjb3VudEluZm9ybWF0aW9ufSBsb2NhbCBjb3B5IG9mIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICovXG4gIGdldCBhY2NvdW50SW5mb3JtYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbWJpbmVkU3RhdGUuYWNjb3VudEluZm9ybWF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgcG9zaXRpb25zIG9wZW5lZFxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgcG9zaXRpb25zIG9wZW5lZFxuICAgKi9cbiAgZ2V0IHBvc2l0aW9ucygpIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNIYXNoO1xuICAgIHJldHVybiBoYXNoID8gT2JqZWN0LnZhbHVlcyh0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFBvc2l0aW9uc0J5SGFzaChoYXNoKSB8fCB7fSkgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIG9yZGVycyBvcGVuZWRcbiAgICogQHJldHVybnMge0FycmF5PE1ldGF0cmFkZXJPcmRlcj59IGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIG9yZGVycyBvcGVuZWRcbiAgICovXG4gIGdldCBvcmRlcnMoKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzSGFzaDtcbiAgICByZXR1cm4gaGFzaCA/IE9iamVjdC52YWx1ZXModGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRPcmRlcnNCeUhhc2goaGFzaCkgfHwge30pIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsIGNvcHkgb2Ygc3ltYm9sIHNwZWNpZmljYXRpb25zIGF2YWlsYWJsZSBpbiBNZXRhVHJhZGVyIHRyYWRpbmcgdGVybWluYWxcbiAgICogQHJldHVybnMge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gYSBsb2NhbCBjb3B5IG9mIHN5bWJvbCBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgaW4gTWV0YVRyYWRlclxuICAgKiB0cmFkaW5nIHRlcm1pbmFsXG4gICAqL1xuICBnZXQgc3BlY2lmaWNhdGlvbnMoKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoO1xuICAgIHJldHVybiBoYXNoID8gT2JqZWN0LnZhbHVlcyh0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFNwZWNpZmljYXRpb25zQnlIYXNoKFxuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gpIHx8IHt9KSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGFzaGVzIG9mIHRlcm1pbmFsIHN0YXRlIGRhdGEgZm9yIGluY3JlbWVudGFsIHN5bmNocm9uaXphdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhhc2hlcyBvZiB0ZXJtaW5hbCBzdGF0ZSBkYXRhXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBnZXRIYXNoZXMoKSB7XG4gICAgY29uc3Qgc3BlY2lmaWNhdGlvbnNIYXNoZXMgPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldExhc3RVc2VkU3BlY2lmaWNhdGlvbkhhc2hlcyh0aGlzLl9hY2NvdW50LnNlcnZlcik7XG4gICAgY29uc3QgcG9zaXRpb25zSGFzaGVzID0gdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRMYXN0VXNlZFBvc2l0aW9uSGFzaGVzKHRoaXMuX2FjY291bnQuaWQpO1xuICAgIGNvbnN0IG9yZGVyc0hhc2hlcyA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0TGFzdFVzZWRPcmRlckhhc2hlcyh0aGlzLl9hY2NvdW50LmlkKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2hlczogc3BlY2lmaWNhdGlvbnNIYXNoZXMsXG4gICAgICBwb3NpdGlvbnNIYXNoZXM6IHBvc2l0aW9uc0hhc2hlcyxcbiAgICAgIG9yZGVyc0hhc2hlczogb3JkZXJzSGFzaGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFUcmFkZXIgc3ltYm9sIHNwZWNpZmljYXRpb24gYnkgc3ltYm9sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9ufSBNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbiBmb3VuZCBvciB1bmRlZmluZWQgaWYgc3BlY2lmaWNhdGlvbiBmb3IgYVxuICAgKiBzeW1ib2wgaXMgbm90IGZvdW5kXG4gICAqL1xuICBzcGVjaWZpY2F0aW9uKHN5bWJvbCkge1xuICAgIGlmKHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0U3BlY2lmaWNhdGlvbnNCeUhhc2goXG4gICAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKTtcbiAgICAgIHJldHVybiBzdGF0ZVtzeW1ib2xdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIHN5bWJvbCBwcmljZSBieSBzeW1ib2xcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHJldHVybiB7TWV0YXRyYWRlclN5bWJvbFByaWNlfSBNZXRhdHJhZGVyU3ltYm9sUHJpY2UgZm91bmQgb3IgdW5kZWZpbmVkIGlmIHByaWNlIGZvciBhIHN5bWJvbCBpcyBub3QgZm91bmRcbiAgICovXG4gIHByaWNlKHN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLl9jb21iaW5lZFN0YXRlLnByaWNlc0J5U3ltYm9sW3N5bWJvbF07XG4gIH1cblxuICAvKipcbiAgICogUXVvdGUgdGltZVxuICAgKiBAdHlwZGVmIHtPYmplY3R9IFF1b3RlVGltZVxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgcXVvdGUgdGltZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyVGltZSBxdW90ZSB0aW1lIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRpbWUgb2YgdGhlIGxhc3QgcmVjZWl2ZWQgcXVvdGVcbiAgICogQHJldHVybiB7UXVvdGVUaW1lfSB0aW1lIG9mIHRoZSBsYXN0IHJlY2VpdmVkIHF1b3RlXG4gICAqL1xuICBnZXQgbGFzdFF1b3RlVGltZSgpIHtcbiAgICBpZiAodGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0UXVvdGVUaW1lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aW1lOiB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZVRpbWUsXG4gICAgICAgIGJyb2tlclRpbWU6IHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFF1b3RlQnJva2VyVGltZSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBwcmljZSB0byBiZSByZWNlaXZlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXRJblNlY29uZHNdIHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xQcmljZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcHJpY2Ugb3IgdW5kZWZpbmVkIGlmIHByaWNlIGhhcyBub3QgYmVlbiByZWNlaXZlZFxuICAgKi9cbiAgYXN5bmMgd2FpdEZvclByaWNlKHN5bWJvbCwgdGltZW91dEluU2Vjb25kcyA9IDMwKSB7XG4gICAgdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbc3ltYm9sXSA9IHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzW3N5bWJvbF0gfHwgW107XG4gICAgaWYgKCF0aGlzLnByaWNlKHN5bWJvbCkpIHtcbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIG5ldyBQcm9taXNlKHJlcyA9PiB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1tzeW1ib2xdLnB1c2gocmVzKSksXG4gICAgICAgIG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgdGltZW91dEluU2Vjb25kcyAqIDEwMDApKVxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByaWNlKHN5bWJvbCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBlc3RhYmxpc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKi9cbiAgb25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpLmNvbm5lY3RlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCB0ZXJtaW5hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqL1xuICBvbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgc3RhdGUuY29ubmVjdGVkVG9Ccm9rZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYnJva2VyIGNvbm5lY3Rpb24gc3RhdHVzIGhhdmUgY2hhbmdlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbm5lY3RlZCBpcyBNZXRhVHJhZGVyIHRlcm1pbmFsIGlzIGNvbm5lY3RlZCB0byBicm9rZXJcbiAgICovXG4gIG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQoaW5zdGFuY2VJbmRleCwgY29ubmVjdGVkKSB7XG4gICAgdGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0U3RhdHVzVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkuY29ubmVjdGVkVG9Ccm9rZXIgPSBjb25uZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIGlzIHN0YXJ0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNwZWNpZmljYXRpb25zSGFzaCBzcGVjaWZpY2F0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbnNIYXNoIHBvc2l0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcnNIYXNoIG9yZGVycyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNIYXNoLCBwb3NpdGlvbnNIYXNoLCBvcmRlcnNIYXNoLCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGNvbnN0IHVuc3luY2hyb25pemVkU3RhdGVzID0gdGhpcy5fZ2V0U3RhdGVJbmRpY2VzT2ZTYW1lSW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleClcbiAgICAgIC5maWx0ZXIoc3RhdGVJbmRleCA9PiAhdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbc3RhdGVJbmRleF0ub3JkZXJzSW5pdGlhbGl6ZWQpO1xuICAgIHVuc3luY2hyb25pemVkU3RhdGVzLnNvcnQoKGEsYikgPT4gYi5sYXN0U3luY1VwZGF0ZVRpbWUgLSBhLmxhc3RTeW5jVXBkYXRlVGltZSk7XG4gICAgdW5zeW5jaHJvbml6ZWRTdGF0ZXMuc2xpY2UoMSkuZm9yRWFjaChzdGF0ZUluZGV4ID0+IHRoaXMuX3JlbW92ZVN0YXRlKHN0YXRlSW5kZXgpKTtcblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmlzU3BlY2lmaWNhdGlvbnNFeHBlY3RlZCA9ICFzcGVjaWZpY2F0aW9uc0hhc2g7XG4gICAgc3RhdGUuaXNQb3NpdGlvbnNFeHBlY3RlZCA9ICFwb3NpdGlvbnNIYXNoO1xuICAgIHN0YXRlLmlzT3JkZXJzRXhwZWN0ZWQgPSAhb3JkZXJzSGFzaDtcbiAgICBzdGF0ZS5sYXN0U3luY1VwZGF0ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5wcmljZXNCeVN5bWJvbCA9IHt9O1xuICAgIHN0YXRlLnBvc2l0aW9ucyA9IFtdO1xuICAgIGlmKCFwb3NpdGlvbnNIYXNoKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uc0hhc2ggPSBwb3NpdGlvbnNIYXNoO1xuICAgIH1cbiAgICBzdGF0ZS5vcmRlcnMgPSBbXTtcbiAgICBpZighb3JkZXJzSGFzaCkge1xuICAgICAgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm9yZGVyc0hhc2ggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5vcmRlcnNIYXNoID0gb3JkZXJzSGFzaDtcbiAgICB9XG4gICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IHt9O1xuICAgIGlmKCFzcGVjaWZpY2F0aW9uc0hhc2gpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZSgoKSA9PiBgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiR7c3luY2hyb25pemF0aW9uSWR9OiBjbGVhcmVkIHNwZWNpZmljYXRpb25zIGAgK1xuICAgICAgICAnb24gc3luY2hyb25pemF0aW9uIHN0YXJ0Jyk7XG4gICAgICBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fToke3N5bmNocm9uaXphdGlvbklkfTogbm8gbmVlZCB0byBjbGVhciBgICtcbiAgICAgICAgYHNwZWNpZmljYXRpb25zIG9uIHN5bmNocm9uaXphdGlvbiBzdGFydCwgJHtPYmplY3Qua2V5cyhzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sIHx8IHt9KS5sZW5ndGh9IGAgK1xuICAgICAgICAnc3BlY2lmaWNhdGlvbnMgcmV1c2VkJyk7XG4gICAgICBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBzcGVjaWZpY2F0aW9uc0hhc2g7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIGFjY291bnQgaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb259IGFjY291bnRJbmZvcm1hdGlvbiB1cGRhdGVkIE1ldGFUcmFkZXIgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGFjY291bnRJbmZvcm1hdGlvbikge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gYWNjb3VudEluZm9ybWF0aW9uO1xuICAgIGlmIChhY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudEluZm9ybWF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBwb3NpdGlvbnMgYXJlIHJlcGxhY2VkIGFzIGEgcmVzdWx0IG9mIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gcG9zaXRpb25zIHVwZGF0ZWQgYXJyYXkgb2YgcG9zaXRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25Qb3NpdGlvbnNSZXBsYWNlZChpbnN0YW5jZUluZGV4LCBwb3NpdGlvbnMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGlmKHN0YXRlLmlzUG9zaXRpb25zRXhwZWN0ZWQpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHBvc2l0aW9uIHN5bmNocm9uaXphdGlvbiBmbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uUG9zaXRpb25zU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUucG9zaXRpb25zSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBvc2l0aW9ucyBhcmUgdXBkYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJQb3NpdGlvbltdfSBwb3NpdGlvbnMgdXBkYXRlZCBNZXRhVHJhZGVyIHBvc2l0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByZW1vdmVkUG9zaXRpb25JZHMgcmVtb3ZlZCBwb3NpdGlvbiBpZHNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblBvc2l0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb25zLCByZW1vdmVkUG9zaXRpb25JZHMpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgcmVtb3ZlZFBvc2l0aW9uSWRzLmZvckVhY2goaWQgPT4gdGhpcy5fY29tYmluZWRTdGF0ZS5yZW1vdmVkUG9zaXRpb25zW2lkXSA9IGRhdGUpO1xuICAgIHBvc2l0aW9ucyA9IHRoaXMuX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMocG9zaXRpb25zKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9jb21iaW5lZFN0YXRlLnJlbW92ZWRQb3NpdGlvbnMpLmZvckVhY2goaWQgPT4ge1xuICAgICAgaWYodGhpcy5fY29tYmluZWRTdGF0ZS5yZW1vdmVkUG9zaXRpb25zW2lkXSA8IGRhdGUgLSAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21iaW5lZFN0YXRlLnJlbW92ZWRQb3NpdGlvbnNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYoaW5zdGFuY2VTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgdXBkYXRlUG9zaXRpb25zID0gYXN5bmMgKHN0YXRlLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci51cGRhdGVQb3NpdGlvbnModGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCxcbiAgICAgICAgICBpbnN0YW5jZSwgcG9zaXRpb25zLCByZW1vdmVkUG9zaXRpb25JZHMsIHN0YXRlLnBvc2l0aW9uc0hhc2gpO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgIH07XG4gICAgICBhd2FpdCB1cGRhdGVQb3NpdGlvbnMoaW5zdGFuY2VTdGF0ZSwgaW5zdGFuY2VJbmRleCk7XG4gICAgICBhd2FpdCB1cGRhdGVQb3NpdGlvbnModGhpcy5fY29tYmluZWRTdGF0ZSwgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2VTdGF0ZS5wb3NpdGlvbnMgPSBpbnN0YW5jZVN0YXRlLnBvc2l0aW9ucy5maWx0ZXIocG9zaXRpb24gPT4gIXJlbW92ZWRQb3NpdGlvbklkcy5pbmNsdWRlcyhwb3NpdGlvbi5pZCkpO1xuICAgICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSBpbnN0YW5jZVN0YXRlLnBvc2l0aW9ucy5maW5kSW5kZXgocCA9PiBwLmlkID09PSBwb3NpdGlvbi5pZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLnBvc2l0aW9uc1tpbmRleF0gPSBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgb3JkZXJzIGFyZSByZXBsYWNlZCBhcyBhIHJlc3VsdCBvZiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJPcmRlcj59IG9yZGVycyB1cGRhdGVkIGFycmF5IG9mIHBlbmRpbmcgb3JkZXJzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25QZW5kaW5nT3JkZXJzUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgb3JkZXJzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fcmVmcmVzaFN0YXRlVXBkYXRlVGltZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZihzdGF0ZS5pc09yZGVyc0V4cGVjdGVkKSB7XG4gICAgICBzdGF0ZS5vcmRlcnMgPSBvcmRlcnM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwZW5kaW5nIG9yZGVyIHN5bmNocm9uaXphdGlvbiBmbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGVcbiAgICogc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuICBhc3luYyBvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID8gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uKSA6XG4gICAgICB1bmRlZmluZWQ7XG4gICAgc3RhdGUucG9zaXRpb25zID0gdGhpcy5fZmlsdGVyUmVtb3ZlZFBvc2l0aW9ucyhzdGF0ZS5wb3NpdGlvbnMpO1xuICAgIGlmKHN0YXRlLnBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlY29yZFBvc2l0aW9ucyh0aGlzLl9hY2NvdW50LmlkLFxuICAgICAgICB0aGlzLl9hY2NvdW50LnR5cGUsIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4LCBzdGF0ZS5wb3NpdGlvbnMpO1xuICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9ucyA9IChzdGF0ZS5wb3NpdGlvbnMgfHwgW10pLm1hcChwID0+IE9iamVjdC5hc3NpZ24oe30sIHApKTtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUucG9zaXRpb25zSGFzaCA9IGhhc2g7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbnNIYXNoKSB7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlbW92ZVBvc2l0aW9uUmVmZXJlbmNlKHRoaXMuaWQsIGluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5hZGRQb3NpdGlvblJlZmVyZW5jZShzdGF0ZS5wb3NpdGlvbnNIYXNoLFxuICAgICAgICB0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUucG9zaXRpb25zSGFzaCA9IHN0YXRlLnBvc2l0aW9uc0hhc2g7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlbW92ZVBvc2l0aW9uUmVmZXJlbmNlKHRoaXMuaWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmFkZFBvc2l0aW9uUmVmZXJlbmNlKHN0YXRlLnBvc2l0aW9uc0hhc2gsXG4gICAgICAgIHRoaXMuaWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIHN0YXRlLm9yZGVycyA9IHRoaXMuX2ZpbHRlclJlbW92ZWRPcmRlcnMoc3RhdGUub3JkZXJzKTtcbiAgICBpZihzdGF0ZS5vcmRlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZWNvcmRPcmRlcnModGhpcy5fYWNjb3VudC5pZCxcbiAgICAgICAgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCwgaW5zdGFuY2VJbmRleCwgc3RhdGUub3JkZXJzKTtcbiAgICAgIHN0YXRlLm9yZGVyc0hhc2ggPSBoYXNoO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnMgPSAoc3RhdGUub3JkZXJzIHx8IFtdKS5tYXAobyA9PiBPYmplY3QuYXNzaWduKHt9LCBvKSk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2ggPSBoYXNoO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub3JkZXJzSGFzaCkge1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVPcmRlclJlZmVyZW5jZSh0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkT3JkZXJSZWZlcmVuY2Uoc3RhdGUub3JkZXJzSGFzaCxcbiAgICAgICAgdGhpcy5pZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2ggPSBzdGF0ZS5vcmRlcnNIYXNoO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVPcmRlclJlZmVyZW5jZSh0aGlzLmlkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5hZGRPcmRlclJlZmVyZW5jZShzdGF0ZS5vcmRlcnNIYXNoLFxuICAgICAgICB0aGlzLmlkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fToke3N5bmNocm9uaXphdGlvbklkfTogYXNzaWduZWQgc3BlY2lmaWNhdGlvbnMgdG8gYCArXG4gICAgICAnY29tYmluZWQgc3RhdGUgZnJvbSAnICtcbiAgICAgIGAke2luc3RhbmNlSW5kZXh9LCAke09iamVjdC5rZXlzKHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgfHwge30pLmxlbmd0aH0gc3BlY2lmaWNhdGlvbnMgYXNzaWduZWRgKTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCB8fCB7fSkubGVuZ3RoKSB7XG4gICAgICBpZihzdGF0ZS5pc1NwZWNpZmljYXRpb25zRXhwZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVjb3JkU3BlY2lmaWNhdGlvbnModGhpcy5fYWNjb3VudC5zZXJ2ZXIsXG4gICAgICAgICAgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCwgaW5zdGFuY2VJbmRleCwgT2JqZWN0LnZhbHVlcyhzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sKSk7XG4gICAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnVwZGF0ZVNwZWNpZmljYXRpb25zKHRoaXMuX2FjY291bnQuc2VydmVyLFxuICAgICAgICAgIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsIGluc3RhbmNlSW5kZXgsIE9iamVjdC52YWx1ZXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCksXG4gICAgICAgICAgW10sIHN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCk7XG4gICAgICAgIHN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gpIHtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVtb3ZlU3BlY2lmaWNhdGlvblJlZmVyZW5jZSh0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkU3BlY2lmaWNhdGlvblJlZmVyZW5jZShzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gsXG4gICAgICAgIHRoaXMuaWQsIGluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2g7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlbW92ZVNwZWNpZmljYXRpb25SZWZlcmVuY2UodGhpcy5pZCwgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkU3BlY2lmaWNhdGlvblJlZmVyZW5jZShzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gsXG4gICAgICAgIHRoaXMuaWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIGZvcihsZXQgc3RhdGVJbmRleCBvZiB0aGlzLl9nZXRTdGF0ZUluZGljZXNPZlNhbWVJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KSkge1xuICAgICAgaWYgKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtzdGF0ZUluZGV4XS5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RhdGUoc3RhdGVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXJzIGFyZSB1cGRhdGVkIG9yIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJPcmRlcltdfSBvcmRlcnMgdXBkYXRlZCBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbXBsZXRlZE9yZGVySWRzIGNvbXBsZXRlZCBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXIgaWRzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25QZW5kaW5nT3JkZXJzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBvcmRlcnMsIGNvbXBsZXRlZE9yZGVySWRzKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGNvbXBsZXRlZE9yZGVySWRzLmZvckVhY2goaWQgPT4gdGhpcy5fY29tYmluZWRTdGF0ZS5jb21wbGV0ZWRPcmRlcnNbaWRdID0gZGF0ZSk7XG4gICAgb3JkZXJzID0gdGhpcy5fZmlsdGVyUmVtb3ZlZE9yZGVycyhvcmRlcnMpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzKS5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGlmKHRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzW2lkXSA8IGRhdGUgLSAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21iaW5lZFN0YXRlLmNvbXBsZXRlZE9yZGVyc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZihpbnN0YW5jZVN0YXRlLm9yZGVyc0luaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB1cGRhdGVQZW5kaW5nT3JkZXJzID0gYXN5bmMgKHN0YXRlLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci51cGRhdGVPcmRlcnModGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCxcbiAgICAgICAgICBpbnN0YW5jZSwgb3JkZXJzLCBjb21wbGV0ZWRPcmRlcklkcywgc3RhdGUub3JkZXJzSGFzaCk7XG4gICAgICAgIHN0YXRlLm9yZGVyc0hhc2ggPSBoYXNoO1xuICAgICAgfTtcbiAgICAgIGF3YWl0IHVwZGF0ZVBlbmRpbmdPcmRlcnMoaW5zdGFuY2VTdGF0ZSwgaW5zdGFuY2VJbmRleCk7XG4gICAgICBhd2FpdCB1cGRhdGVQZW5kaW5nT3JkZXJzKHRoaXMuX2NvbWJpbmVkU3RhdGUsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlU3RhdGUub3JkZXJzID0gaW5zdGFuY2VTdGF0ZS5vcmRlcnMuZmlsdGVyKG9yZGVyID0+ICFjb21wbGV0ZWRPcmRlcklkcy5pbmNsdWRlcyhvcmRlci5pZCkpO1xuICAgICAgb3JkZXJzLmZvckVhY2gob3JkZXIgPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSBpbnN0YW5jZVN0YXRlLm9yZGVycy5maW5kSW5kZXgobyA9PiBvLmlkID09PSBvcmRlci5pZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLm9yZGVyc1tpbmRleF0gPSBvcmRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLm9yZGVycy5wdXNoKG9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN5bWJvbCBzcGVjaWZpY2F0aW9uIHdhcyB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb24+fSBzcGVjaWZpY2F0aW9ucyB1cGRhdGVkIHNwZWNpZmljYXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gcmVtb3ZlZFN5bWJvbHMgcmVtb3ZlZCBzeW1ib2xzXG4gICAqL1xuICBhc3luYyBvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9ucywgcmVtb3ZlZFN5bWJvbHMpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYoIWluc3RhbmNlU3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGZvciAobGV0IHNwZWNpZmljYXRpb24gb2Ygc3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2VTdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sW3NwZWNpZmljYXRpb24uc3ltYm9sXSA9IHNwZWNpZmljYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnVwZGF0ZVNwZWNpZmljYXRpb25zKHRoaXMuX2FjY291bnQuc2VydmVyLCB0aGlzLl9hY2NvdW50LnR5cGUsXG4gICAgICAgIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9ucywgcmVtb3ZlZFN5bWJvbHMsIGluc3RhbmNlU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKTtcbiAgICAgIGluc3RhbmNlU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgIGNvbnN0IGNvbWJpbmVkSGFzaCA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIudXBkYXRlU3BlY2lmaWNhdGlvbnModGhpcy5fYWNjb3VudC5zZXJ2ZXIsXG4gICAgICAgIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzLFxuICAgICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IGNvbWJpbmVkSGFzaDtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IHVwZGF0ZWQgJHtzcGVjaWZpY2F0aW9ucy5sZW5ndGh9IHNwZWNpZmljYXRpb25zLCBgICtcbiAgICAgIGByZW1vdmVkICR7cmVtb3ZlZFN5bWJvbHMubGVuZ3RofSBzcGVjaWZpY2F0aW9ucy4gVGhlcmUgYXJlIGAgK1xuICAgICAgYCR7T2JqZWN0LmtleXMoaW5zdGFuY2VTdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sIHx8IHt9KS5sZW5ndGh9IHNwZWNpZmljYXRpb25zIGFmdGVyIHVwZGF0ZWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwcmljZXMgZm9yIHNldmVyYWwgc3ltYm9scyB3ZXJlIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheTxNZXRhdHJhZGVyU3ltYm9sUHJpY2U+fSBwcmljZXMgdXBkYXRlZCBNZXRhVHJhZGVyIHN5bWJvbCBwcmljZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVxdWl0eSBhY2NvdW50IGxpcXVpZGF0aW9uIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXJnaW4gbWFyZ2luIHVzZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyZWVNYXJnaW4gZnJlZSBtYXJnaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1hcmdpbkxldmVsIG1hcmdpbiBsZXZlbCBjYWxjdWxhdGVkIGFzICUgb2YgZXF1aXR5L21hcmdpblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgb25TeW1ib2xQcmljZXNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHByaWNlcywgZXF1aXR5LCBtYXJnaW4sIGZyZWVNYXJnaW4sIG1hcmdpbkxldmVsKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksbWF4LXN0YXRlbWVudHNcbiAgICBjb25zdCB1cGRhdGVTeW1ib2xQcmljZXMgPSAoc3RhdGUpID0+IHtcbiAgICAgIGxldCBwcmljZXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgbGV0IHByaWNlVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgcHJpY2Ugb2YgcHJpY2VzIHx8IFtdKSB7XG4gICAgICAgIGxldCBjdXJyZW50UHJpY2UgPSBzdGF0ZS5wcmljZXNCeVN5bWJvbFtwcmljZS5zeW1ib2xdO1xuICAgICAgICBpZiAoY3VycmVudFByaWNlICYmIGN1cnJlbnRQcmljZS50aW1lLmdldFRpbWUoKSA+IHByaWNlLnRpbWUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpY2VVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLmxhc3RRdW90ZVRpbWUgfHwgc3RhdGUubGFzdFF1b3RlVGltZS5nZXRUaW1lKCkgPCBwcmljZS50aW1lLmdldFRpbWUoKSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RRdW90ZVRpbWUgPSBwcmljZS50aW1lO1xuICAgICAgICAgIHN0YXRlLmxhc3RRdW90ZUJyb2tlclRpbWUgPSBwcmljZS5icm9rZXJUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnByaWNlc0J5U3ltYm9sW3ByaWNlLnN5bWJvbF0gPSBwcmljZTtcbiAgICAgICAgY29uc3QgYWxsUG9zaXRpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFBvc2l0aW9uc0J5SGFzaChcbiAgICAgICAgICBzdGF0ZS5wb3NpdGlvbnNIYXNoKSB8fCB7fSk7XG4gICAgICAgIGNvbnN0IGFsbE9yZGVycyA9IE9iamVjdC52YWx1ZXModGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRPcmRlcnNCeUhhc2goXG4gICAgICAgICAgc3RhdGUub3JkZXJzSGFzaCkgfHwge30pO1xuICAgICAgICBsZXQgcG9zaXRpb25zID0gYWxsUG9zaXRpb25zLmZpbHRlcihwID0+IHAuc3ltYm9sID09PSBwcmljZS5zeW1ib2wpO1xuICAgICAgICBsZXQgb3RoZXJQb3NpdGlvbnMgPSBhbGxQb3NpdGlvbnMuZmlsdGVyKHAgPT4gcC5zeW1ib2wgIT09IHByaWNlLnN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhbGxPcmRlcnMuZmlsdGVyKG8gPT4gby5zeW1ib2wgPT09IHByaWNlLnN5bWJvbCk7XG4gICAgICAgIHByaWNlc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gb2Ygb3RoZXJQb3NpdGlvbnMpIHtcbiAgICAgICAgICBsZXQgcCA9IHN0YXRlLnByaWNlc0J5U3ltYm9sW3Bvc2l0aW9uLnN5bWJvbF07XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJpY2VzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gb2YgcG9zaXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgb3JkZXIgb2Ygb3JkZXJzKSB7XG4gICAgICAgICAgb3JkZXIuY3VycmVudFByaWNlID0gb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZJyB8fCBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVlfTElNSVQnIHx8XG4gICAgICAgICAgICBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVlfU1RPUCcgfHwgb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZX1NUT1BfTElNSVQnID8gcHJpY2UuYXNrIDogcHJpY2UuYmlkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZVJlc29sdmVzID0gdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbcHJpY2Uuc3ltYm9sXSB8fCBbXTtcbiAgICAgICAgaWYgKHByaWNlUmVzb2x2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgcmVzb2x2ZSBvZiBwcmljZVJlc29sdmVzKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1twcmljZS5zeW1ib2xdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJpY2VVcGRhdGVkICYmIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbikge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0UG9zaXRpb25zQnlIYXNoKHN0YXRlLnBvc2l0aW9uc0hhc2gpIHx8IHt9KTtcbiAgICAgICAgaWYgKHN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkICYmIHByaWNlc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5wbGF0Zm9ybSA9PT0gJ210NScpIHtcbiAgICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgPSBlcXVpdHkgIT09IHVuZGVmaW5lZCA/IGVxdWl0eSA6IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5iYWxhbmNlICtcbiAgICAgICAgICAgICAgcG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwKSA9PiBhY2MgK1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHAudW5yZWFsaXplZFByb2ZpdCB8fCAwKSAqIDEwMCkgLyAxMDAgKyBNYXRoLnJvdW5kKChwLnN3YXAgfHwgMCkgKiAxMDApIC8gMTAwLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IGVxdWl0eSAhPT0gdW5kZWZpbmVkID8gZXF1aXR5IDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmJhbGFuY2UgK1xuICAgICAgICAgICAgcG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwKSA9PiBhY2MgKyBNYXRoLnJvdW5kKChwLnN3YXAgfHwgMCkgKiAxMDApIC8gMTAwICtcbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCgocC5jb21taXNzaW9uIHx8IDApICogMTAwKSAvIDEwMCArIE1hdGgucm91bmQoKHAudW5yZWFsaXplZFByb2ZpdCB8fCAwKSAqIDEwMCkgLyAxMDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ID0gTWF0aC5yb3VuZChzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ICogMTAwKSAvIDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ID0gZXF1aXR5ICE9PSB1bmRlZmluZWQgPyBlcXVpdHkgOiBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW4gPSBtYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbiA6IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW47XG4gICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5mcmVlTWFyZ2luID0gZnJlZU1hcmdpbiAhPT0gdW5kZWZpbmVkID8gZnJlZU1hcmdpbiA6IFxuICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5mcmVlTWFyZ2luO1xuICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24ubWFyZ2luTGV2ZWwgPSBmcmVlTWFyZ2luICE9PSB1bmRlZmluZWQgPyBtYXJnaW5MZXZlbCA6XG4gICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLm1hcmdpbkxldmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlU3ltYm9sUHJpY2VzKGluc3RhbmNlU3RhdGUpO1xuICAgIHVwZGF0ZVN5bWJvbFByaWNlcyh0aGlzLl9jb21iaW5lZFN0YXRlKTtcbiAgICBmb3IgKGxldCBwcmljZSBvZiBwcmljZXMpIHtcbiAgICAgIGZvciAobGV0IGNhbGwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHMpKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiByZWZyZXNoZWQgJHtwcmljZS5zeW1ib2x9IHByaWNlYCk7XG4gICAgICAgIGNhbGwuZXhwZWN0ZWRTeW1ib2xzPy5kZWxldGUocHJpY2Uuc3ltYm9sKTtcbiAgICAgICAgY2FsbC5yZWNlaXZlZFN5bWJvbHMuYWRkKHByaWNlLnN5bWJvbCk7XG4gICAgICAgIGNhbGwucHJvbWlzZS5jaGVjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzdHJlYW0gZm9yIGFuIGluc3RhbmNlIGluZGV4IGlzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZih0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZUluZGV4XSkge1xuICAgICAgZm9yKGxldCBzdGF0ZUluZGV4IG9mIHRoaXMuX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtzdGF0ZUluZGV4XTtcbiAgICAgICAgaWYoIXRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdLm9yZGVyc0luaXRpYWxpemVkIFxuICAgICAgICAgICAgJiYgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF0ubGFzdFN5bmNVcGRhdGVUaW1lIDw9IGluc3RhbmNlU3RhdGUubGFzdFN5bmNVcGRhdGVUaW1lKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW5zdGFuY2VTdGF0ZS5jb25uZWN0ZWQgJiYgaW5zdGFuY2VTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyByZWZyZXNoIG9mIG1vc3QgcmVjZW50IHF1b3RlIHVwZGF0ZXMgZm9yIHN5bWJvbHMgc3Vic2NyaWJlZCB0byBieSB0aGUgdGVybWluYWwsIGFuZCB3YWl0cyBmb3IgdGhlbSBhbGwgdG9cbiAgICogYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgdGVybWluYWwgc3RhdGUuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdhaXRzIGZvciBhbGwgb3RoZXIgbGlzdGVuZXJzIHRvIHJlY2VpdmUgYW5kIHByb2Nlc3MgdGhlXG4gICAqIHF1b3RlIHVwZGF0ZXNcbiAgICogQHBhcmFtIHtSZWZyZXNoVGVybWluYWxTdGF0ZU9wdGlvbnN9IFtvcHRpb25zXSBhZGRpdGlvbmFsIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIHRlcm1pbmFsIHN0YXRlIHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQgdGhlIGxhdGVzdCBxdW90ZXNcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hUZXJtaW5hbFN0YXRlKG9wdGlvbnMpIHtcbiAgICBsZXQgY2FsbERhdGEgPSB7XG4gICAgICByZWNlaXZlZFN5bWJvbHM6IG5ldyBTZXQoKVxuICAgIH07XG4gICAgbGV0IGNhbGxJZCA9IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSg4KTtcbiAgICB0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHNbY2FsbElkXSA9IGNhbGxEYXRhO1xuICAgIGNhbGxEYXRhLnByb21pc2UgPSBuZXcgQ29uZGl0aW9uUHJvbWlzZSgoKSA9PiBjYWxsRGF0YS5leHBlY3RlZFN5bWJvbHMgJiYgIWNhbGxEYXRhLmV4cGVjdGVkU3ltYm9scy5zaXplKTtcbiAgICBjYWxsRGF0YS5wcm9taXNlLnRpbWVvdXQoMTAwMCAqIChvcHRpb25zPy50aW1lb3V0SW5TZWNvbmRzID8/IDEwKSwgJ3JlZnJlc2hpbmcgdGVybWluYWwgc3RhdGUgdGltZWQgb3V0Jyk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzeW1ib2xzID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlZnJlc2hUZXJtaW5hbFN0YXRlKHRoaXMuX2FjY291bnQuaWQpLFxuICAgICAgICBjYWxsRGF0YS5wcm9taXNlIC8vIHdpbGwgb25seSB0aHJvdyB0aW1lb3V0IGVycm9yIGF0IHRoaXMgcG9pbnRcbiAgICAgIF0pO1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiBleHBlY3RpbmcgZm9yICR7c3ltYm9scy5sZW5ndGggPyBzeW1ib2xzIDogMH0gc3ltYm9scyB0byByZWZyZXNoYCk7XG4gICAgICBsZXQgZXhwZWN0ZWRTeW1ib2xzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgc3ltYm9sIG9mIHN5bWJvbHMpIHtcbiAgICAgICAgaWYgKCFjYWxsRGF0YS5yZWNlaXZlZFN5bWJvbHMuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgICBleHBlY3RlZFN5bWJvbHMuYWRkKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhbGxEYXRhLmV4cGVjdGVkU3ltYm9scyA9IGV4cGVjdGVkU3ltYm9scztcbiAgICAgIGNhbGxEYXRhLnByb21pc2UuY2hlY2soKTtcbiAgICAgIGF3YWl0IGNhbGxEYXRhLnByb21pc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHNbY2FsbElkXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBjb25uZWN0aW9uIHJlbGF0ZWQgZGF0YSBmcm9tIHRlcm1pbmFsIGhhc2ggbWFuYWdlclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLmZvckVhY2goaW5zdGFuY2VJbmRleCA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tSGFzaE1hbmFnZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVtb3ZlRnJvbUhhc2hNYW5hZ2VyKHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvLyByZXNldHMgY29tYmluZWQgc3RhdGUgYW5kIHJlbW92ZXMgZnJvbSBoYXNoIG1hbmFnZXIgaWYgaGFzIGJlZW4gZGlzY29ubmVjdGVkIGZvciBhIGxvbmcgdGltZVxuICBfY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IoKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZFRvQnJva2VyICYmIHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFN0YXR1c1RpbWUgPCBEYXRlLm5vdygpIC0gMzAgKiA2MCAqIDEwMDApIHtcbiAgICAgIHRoaXMuX3JlbW92ZUZyb21IYXNoTWFuYWdlcih0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IG51bGw7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnByaWNlc0J5U3ltYm9sID0ge307XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IG51bGw7XG4gICAgICBcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzID0gW107XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2ggPSBudWxsO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNIYXNoID0gbnVsbDtcbiAgICAgIFxuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0U3RhdHVzVGltZSA9IDA7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZVRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZUJyb2tlclRpbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgX3JlbW92ZVN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgdGhpcy5fcmVtb3ZlRnJvbUhhc2hNYW5hZ2VyKGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgX3JlbW92ZUZyb21IYXNoTWFuYWdlcihpbnN0YW5jZUluZGV4KSB7XG4gICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVDb25uZWN0aW9uUmVmZXJlbmNlcyh0aGlzLl9hY2NvdW50LnNlcnZlcixcbiAgICAgIHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIF9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpe1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgaWYoc3RhdGUgJiYgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXRlLmxhc3RTeW5jVXBkYXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCByZWdpb24gPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMF07XG4gICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMV07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KVxuICAgICAgLmZpbHRlcihzdGF0ZUluc3RhbmNlSW5kZXggPT4gc3RhdGVJbnN0YW5jZUluZGV4LnN0YXJ0c1dpdGgoYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTpgKSAmJiBcbiAgICAgIGluc3RhbmNlSW5kZXggIT09IHN0YXRlSW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBfdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwcmljZSkge1xuICAgIGxldCBzcGVjaWZpY2F0aW9uID0gdGhpcy5zcGVjaWZpY2F0aW9uKHBvc2l0aW9uLnN5bWJvbCk7XG4gICAgaWYgKHNwZWNpZmljYXRpb24pIHtcbiAgICAgIGxldCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHNwZWNpZmljYXRpb24uZGlnaXRzKTtcbiAgICAgIGlmIChwb3NpdGlvbi5wcm9maXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi5wcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24ucmVhbGl6ZWRQcm9maXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID0gKHBvc2l0aW9uLnR5cGUgPT09ICdQT1NJVElPTl9UWVBFX0JVWScgPyAxIDogLTEpICpcbiAgICAgICAgICAocG9zaXRpb24uY3VycmVudFByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIHBvc2l0aW9uLmN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICAgIHBvc2l0aW9uLnZvbHVtZSAvIHNwZWNpZmljYXRpb24udGlja1NpemU7XG4gICAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICAgIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0ID0gcG9zaXRpb24ucHJvZml0IC0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdDtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdQb3NpdGlvblByaWNlID0gcG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IHByaWNlLmJpZCA6IHByaWNlLmFzaztcbiAgICAgIGxldCBpc1Byb2ZpdGFibGUgPSAocG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IDEgOiAtMSkgKiAobmV3UG9zaXRpb25QcmljZSAtIHBvc2l0aW9uLm9wZW5QcmljZSk7XG4gICAgICBsZXQgY3VycmVudFRpY2tWYWx1ZSA9IChpc1Byb2ZpdGFibGUgPiAwID8gcHJpY2UucHJvZml0VGlja1ZhbHVlIDogcHJpY2UubG9zc1RpY2tWYWx1ZSk7XG4gICAgICBsZXQgdW5yZWFsaXplZFByb2ZpdCA9IChwb3NpdGlvbi50eXBlID09PSAnUE9TSVRJT05fVFlQRV9CVVknID8gMSA6IC0xKSAqXG4gICAgICAgIChuZXdQb3NpdGlvblByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIGN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICBwb3NpdGlvbi52b2x1bWUgLyBzcGVjaWZpY2F0aW9uLnRpY2tTaXplO1xuICAgICAgdW5yZWFsaXplZFByb2ZpdCA9IE1hdGgucm91bmQodW5yZWFsaXplZFByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSB1bnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdCArIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gTWF0aC5yb3VuZChwb3NpdGlvbi5wcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICBwb3NpdGlvbi5jdXJyZW50UHJpY2UgPSBuZXdQb3NpdGlvblByaWNlO1xuICAgICAgcG9zaXRpb24uY3VycmVudFRpY2tWYWx1ZSA9IGN1cnJlbnRUaWNrVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5maWx0ZXIocG9zaXRpb24gPT4gIXRoaXMuX2NvbWJpbmVkU3RhdGUucmVtb3ZlZFBvc2l0aW9uc1twb3NpdGlvbi5pZF0pO1xuICB9XG5cbiAgX2ZpbHRlclJlbW92ZWRPcmRlcnMob3JkZXJzKSB7XG4gICAgcmV0dXJuIG9yZGVycy5maWx0ZXIob3JkZXIgPT4gIXRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzW29yZGVyLmlkXSk7XG4gIH1cbiAgXG4gIF9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdKSB7XG4gICAgICB0aGlzLl9sb2dnZXIudHJhY2UoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogY29uc3RydWN0ZWQgbmV3IHN0YXRlYCk7XG4gICAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdID0gdGhpcy5fY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICBfY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbmNlSW5kZXgsXG4gICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgY29ubmVjdGVkVG9Ccm9rZXI6IGZhbHNlLFxuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IHt9LFxuICAgICAgcHJpY2VzQnlTeW1ib2w6IHt9LFxuICAgICAgb3JkZXJzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgcG9zaXRpb25zSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgbGFzdFN5bmNVcGRhdGVUaW1lOiAwLFxuICAgICAgcG9zaXRpb25zSGFzaDogbnVsbCxcbiAgICAgIG9yZGVyc0hhc2g6IG51bGwsXG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2g6IG51bGwsXG4gICAgICBpc1NwZWNpZmljYXRpb25zRXhwZWN0ZWQ6IHRydWUsXG4gICAgICBpc1Bvc2l0aW9uc0V4cGVjdGVkOiB0cnVlLFxuICAgICAgaXNPcmRlcnNFeHBlY3RlZDogdHJ1ZSxcbiAgICAgIGxhc3RRdW90ZVRpbWU6IHVuZGVmaW5lZCxcbiAgICAgIGxhc3RRdW90ZUJyb2tlclRpbWU6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxufVxuIl0sIm5hbWVzIjpbInJhbmRvbXN0cmluZyIsIlN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwiTWV0YUFwaVdlYnNvY2tldENsaWVudCIsIkxvZ2dlck1hbmFnZXIiLCJUZXJtaW5hbEhhc2hNYW5hZ2VyIiwiTWV0YXRyYWRlckFjY291bnQiLCJDb25kaXRpb25Qcm9taXNlIiwiVGVybWluYWxTdGF0ZSIsImlkIiwiX2lkIiwiY29ubmVjdGVkIiwiT2JqZWN0IiwidmFsdWVzIiwiX3N0YXRlQnlJbnN0YW5jZUluZGV4IiwicmVkdWNlIiwiYWNjIiwicyIsImNvbm5lY3RlZFRvQnJva2VyIiwiYWNjb3VudEluZm9ybWF0aW9uIiwiX2NvbWJpbmVkU3RhdGUiLCJwb3NpdGlvbnMiLCJoYXNoIiwicG9zaXRpb25zSGFzaCIsIl90ZXJtaW5hbEhhc2hNYW5hZ2VyIiwiZ2V0UG9zaXRpb25zQnlIYXNoIiwib3JkZXJzIiwib3JkZXJzSGFzaCIsImdldE9yZGVyc0J5SGFzaCIsInNwZWNpZmljYXRpb25zIiwic3BlY2lmaWNhdGlvbnNIYXNoIiwiZ2V0U3BlY2lmaWNhdGlvbnNCeUhhc2giLCJnZXRIYXNoZXMiLCJzcGVjaWZpY2F0aW9uc0hhc2hlcyIsImdldExhc3RVc2VkU3BlY2lmaWNhdGlvbkhhc2hlcyIsIl9hY2NvdW50Iiwic2VydmVyIiwicG9zaXRpb25zSGFzaGVzIiwiZ2V0TGFzdFVzZWRQb3NpdGlvbkhhc2hlcyIsIm9yZGVyc0hhc2hlcyIsImdldExhc3RVc2VkT3JkZXJIYXNoZXMiLCJzcGVjaWZpY2F0aW9uIiwic3ltYm9sIiwic3RhdGUiLCJwcmljZSIsInByaWNlc0J5U3ltYm9sIiwibGFzdFF1b3RlVGltZSIsInRpbWUiLCJicm9rZXJUaW1lIiwibGFzdFF1b3RlQnJva2VyVGltZSIsInVuZGVmaW5lZCIsIndhaXRGb3JQcmljZSIsInRpbWVvdXRJblNlY29uZHMiLCJfd2FpdEZvclByaWNlUmVzb2x2ZXMiLCJQcm9taXNlIiwicmFjZSIsInJlcyIsInB1c2giLCJzZXRUaW1lb3V0Iiwib25Db25uZWN0ZWQiLCJpbnN0YW5jZUluZGV4IiwiX2dldFN0YXRlIiwib25EaXNjb25uZWN0ZWQiLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwibGFzdFN0YXR1c1RpbWUiLCJEYXRlIiwibm93Iiwib25TeW5jaHJvbml6YXRpb25TdGFydGVkIiwic3luY2hyb25pemF0aW9uSWQiLCJ1bnN5bmNocm9uaXplZFN0YXRlcyIsIl9nZXRTdGF0ZUluZGljZXNPZlNhbWVJbnN0YW5jZU51bWJlciIsImZpbHRlciIsInN0YXRlSW5kZXgiLCJvcmRlcnNJbml0aWFsaXplZCIsInNvcnQiLCJhIiwiYiIsImxhc3RTeW5jVXBkYXRlVGltZSIsInNsaWNlIiwiZm9yRWFjaCIsIl9yZW1vdmVTdGF0ZSIsImlzU3BlY2lmaWNhdGlvbnNFeHBlY3RlZCIsImlzUG9zaXRpb25zRXhwZWN0ZWQiLCJpc09yZGVyc0V4cGVjdGVkIiwicG9zaXRpb25zSW5pdGlhbGl6ZWQiLCJzcGVjaWZpY2F0aW9uc0J5U3ltYm9sIiwiX2xvZ2dlciIsInRyYWNlIiwia2V5cyIsImxlbmd0aCIsIm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCIsIl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lIiwiYXNzaWduIiwib25Qb3NpdGlvbnNSZXBsYWNlZCIsIm9uUG9zaXRpb25zU3luY2hyb25pemVkIiwib25Qb3NpdGlvbnNVcGRhdGVkIiwicmVtb3ZlZFBvc2l0aW9uSWRzIiwiaW5zdGFuY2VTdGF0ZSIsImRhdGUiLCJyZW1vdmVkUG9zaXRpb25zIiwiX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMiLCJ1cGRhdGVQb3NpdGlvbnMiLCJpbnN0YW5jZSIsInR5cGUiLCJfY29tYmluZWRJbnN0YW5jZUluZGV4IiwicG9zaXRpb24iLCJpbmNsdWRlcyIsImluZGV4IiwiZmluZEluZGV4IiwicCIsIm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkIiwib25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkIiwicmVjb3JkUG9zaXRpb25zIiwibWFwIiwicmVtb3ZlUG9zaXRpb25SZWZlcmVuY2UiLCJhZGRQb3NpdGlvblJlZmVyZW5jZSIsIl9maWx0ZXJSZW1vdmVkT3JkZXJzIiwicmVjb3JkT3JkZXJzIiwibyIsInJlbW92ZU9yZGVyUmVmZXJlbmNlIiwiYWRkT3JkZXJSZWZlcmVuY2UiLCJyZWNvcmRTcGVjaWZpY2F0aW9ucyIsInVwZGF0ZVNwZWNpZmljYXRpb25zIiwicmVtb3ZlU3BlY2lmaWNhdGlvblJlZmVyZW5jZSIsImFkZFNwZWNpZmljYXRpb25SZWZlcmVuY2UiLCJvblBlbmRpbmdPcmRlcnNVcGRhdGVkIiwiY29tcGxldGVkT3JkZXJJZHMiLCJjb21wbGV0ZWRPcmRlcnMiLCJ1cGRhdGVQZW5kaW5nT3JkZXJzIiwidXBkYXRlT3JkZXJzIiwib3JkZXIiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCIsInJlbW92ZWRTeW1ib2xzIiwiY29tYmluZWRIYXNoIiwib25TeW1ib2xQcmljZXNVcGRhdGVkIiwicHJpY2VzIiwiZXF1aXR5IiwibWFyZ2luIiwiZnJlZU1hcmdpbiIsIm1hcmdpbkxldmVsIiwidXBkYXRlU3ltYm9sUHJpY2VzIiwicHJpY2VzSW5pdGlhbGl6ZWQiLCJwcmljZVVwZGF0ZWQiLCJjdXJyZW50UHJpY2UiLCJnZXRUaW1lIiwiYWxsUG9zaXRpb25zIiwiYWxsT3JkZXJzIiwib3RoZXJQb3NpdGlvbnMiLCJ1bnJlYWxpemVkUHJvZml0IiwiX3VwZGF0ZVBvc2l0aW9uUHJvZml0cyIsImFzayIsImJpZCIsInByaWNlUmVzb2x2ZXMiLCJyZXNvbHZlIiwicGxhdGZvcm0iLCJiYWxhbmNlIiwiTWF0aCIsInJvdW5kIiwic3dhcCIsImNvbW1pc3Npb24iLCJjYWxsIiwiX3Byb2Nlc3NUaHJvdHRsZWRRdW90ZXNDYWxscyIsImV4cGVjdGVkU3ltYm9scyIsImRlbGV0ZSIsInJlY2VpdmVkU3ltYm9scyIsImFkZCIsInByb21pc2UiLCJjaGVjayIsIm9uU3RyZWFtQ2xvc2VkIiwicmVmcmVzaFRlcm1pbmFsU3RhdGUiLCJvcHRpb25zIiwiY2FsbERhdGEiLCJTZXQiLCJjYWxsSWQiLCJnZW5lcmF0ZSIsInNpemUiLCJ0aW1lb3V0Iiwic3ltYm9scyIsIl93ZWJzb2NrZXRDbGllbnQiLCJkZWJ1ZyIsImhhcyIsImNsb3NlIiwiX3JlbW92ZUZyb21IYXNoTWFuYWdlciIsIl9jaGVja0NvbWJpbmVkU3RhdGVBY3Rpdml0eUpvYiIsInJlbW92ZUNvbm5lY3Rpb25SZWZlcmVuY2VzIiwicmVnaW9uIiwic3BsaXQiLCJpbnN0YW5jZU51bWJlciIsInN0YXRlSW5zdGFuY2VJbmRleCIsInN0YXJ0c1dpdGgiLCJtdWx0aXBsaWVyIiwicG93IiwiZGlnaXRzIiwicHJvZml0IiwicmVhbGl6ZWRQcm9maXQiLCJvcGVuUHJpY2UiLCJjdXJyZW50VGlja1ZhbHVlIiwidm9sdW1lIiwidGlja1NpemUiLCJuZXdQb3NpdGlvblByaWNlIiwiaXNQcm9maXRhYmxlIiwicHJvZml0VGlja1ZhbHVlIiwibG9zc1RpY2tWYWx1ZSIsIl9jb25zdHJ1Y3RUZXJtaW5hbFN0YXRlIiwiY29uc3RydWN0b3IiLCJhY2NvdW50IiwidGVybWluYWxIYXNoTWFuYWdlciIsIndlYnNvY2tldENsaWVudCIsImdldExvZ2dlciIsImJpbmQiLCJzZXRJbnRlcnZhbCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLE9BQU9BLGtCQUFrQixlQUFlO0FBQ3hDLE9BQU9DLDZCQUE2Qiw2Q0FBNkM7QUFDakYsT0FBT0MsNEJBQTRCLDZDQUE2QztBQUNoRixPQUFPQyxtQkFBbUIsWUFBWTtBQUN0QyxPQUFPQyx5QkFBeUIsd0JBQXdCO0FBQ3hELE9BQU9DLHVCQUF1QixzQkFBc0I7QUFDcEQsU0FBUUMsZ0JBQWdCLFFBQU8sc0JBQXNCO0FBS3RDLElBQUEsQUFBTUMsZ0JBQU4sTUFB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
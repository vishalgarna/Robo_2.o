'use strict';
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
import randomstring from 'randomstring';
import socketIO from 'socket.io-client';
import TimeoutError from '../timeoutError';
import { ValidationError, NotFoundError, InternalError, UnauthorizedError, TooManyRequestsError, ForbiddenError } from '../errorHandler';
import OptionsValidator from '../optionsValidator';
import NotSynchronizedError from './notSynchronizedError';
import NotConnectedError from './notConnectedError';
import TradeError from './tradeError';
import PacketOrderer from './packetOrderer';
import SynchronizationThrottler from './synchronizationThrottler';
import SubscriptionManager from './subscriptionManager';
import LoggerManager from '../../logger';
import any from 'promise.any';
import LatencyService from './latencyService';
let PacketLogger;
if (typeof window === 'undefined') {
    PacketLogger = require('./packetLogger').default;
}
let MetaApiWebsocketClient = class MetaApiWebsocketClient {
    /**
   * Restarts the account synchronization process on an out of order packet
   * @param {String} accountId account id
   * @param {Number} instanceIndex instance index
   * @param {Number} expectedSequenceNumber expected s/n
   * @param {Number} actualSequenceNumber actual s/n
   * @param {Object} packet packet data
   * @param {Date} receivedAt time the packet was received at
   */ onOutOfOrderPacket(accountId, instanceIndex, expectedSequenceNumber, actualSequenceNumber, packet, receivedAt) {
        const primaryAccountId = this._accountsByReplicaId[accountId];
        if (this._subscriptionManager.isSubscriptionActive(accountId)) {
            const level = this._latencyService.getSynchronizedAccountInstances(primaryAccountId).length ? 'debug' : 'error';
            this._logger[level]('MetaApi websocket client received an out of order ' + `packet type ${packet.type} for account id ${accountId}:${instanceIndex}. Expected s/n ` + `${expectedSequenceNumber} does not match the actual of ${actualSequenceNumber}`);
            this.ensureSubscribe(accountId, instanceIndex);
        }
    }
    /**
   * Patch server URL for use in unit tests
   * @param {String} url patched server URL
   */ set url(url) {
        this._url = url;
    }
    /**
   * Websocket client predefined region
   * @returns {String} predefined region
   */ get region() {
        return this._region;
    }
    /**
   * Returns the list of socket instance dictionaries
   * @return {Object[]} list of socket instance dictionaries
   */ get socketInstances() {
        return this._socketInstances;
    }
    /**
   * Returns the dictionary of socket instances by account ids
   * @return {Object} dictionary of socket instances by account ids
   */ get socketInstancesByAccounts() {
        return this._socketInstancesByAccounts;
    }
    /**
   * Returns the dictionary of account replicas by region
   * @return {Object} dictionary of account replicas by region
   */ get accountReplicas() {
        return this._accountReplicas;
    }
    /**
   * Returns the dictionary of primary account ids by replica ids
   * @return {Object} dictionary of primary account ids by replica ids
   */ get accountsByReplicaId() {
        return this._accountsByReplicaId;
    }
    /**
   * Returns clear account cache job. Used for tests
   * @return {Function} clear account cache job
   */ get clearAccountCacheJob() {
        return this._clearAccountCacheJob.bind(this);
    }
    /**
   * Returns latency service
   * @returns {LatencyService} latency service
   */ get latencyService() {
        return this._latencyService;
    }
    /**
   * Returns the list of subscribed account ids
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @return {string[]} list of subscribed account ids
   */ subscribedAccountIds(instanceNumber, socketInstanceIndex, region) {
        const connectedIds = [];
        if (this._socketInstancesByAccounts[instanceNumber]) {
            Object.keys(this._connectedHosts).forEach((instanceId)=>{
                const accountId = instanceId.split(':')[0];
                const accountRegion = this.getAccountRegion(accountId);
                if (!connectedIds.includes(accountId) && this._socketInstancesByAccounts[instanceNumber][accountId] !== undefined && (this._socketInstancesByAccounts[instanceNumber][accountId] === socketInstanceIndex || socketInstanceIndex === undefined) && accountRegion === region) {
                    connectedIds.push(accountId);
                }
            });
        }
        return connectedIds;
    }
    /**
   * Returns websocket client connection status
   * @param {Number} instanceNumber instance index number
   * @param {Number} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @returns {Boolean} websocket client connection status
   */ connected(instanceNumber, socketInstanceIndex, region) {
        const instance = this._socketInstances[region] && this._socketInstances[region][instanceNumber].length > socketInstanceIndex ? this._socketInstances[region][instanceNumber][socketInstanceIndex] : null;
        return instance && instance.socket && instance.socket.connected || false;
    }
    /**
   * Returns list of accounts assigned to instance
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @returns 
   */ getAssignedAccounts(instanceNumber, socketInstanceIndex, region) {
        const accountIds = [];
        Object.keys(this._socketInstancesByAccounts[instanceNumber]).forEach((key)=>{
            const accountRegion = this.getAccountRegion(key);
            if (accountRegion === region && this._socketInstancesByAccounts[instanceNumber][key] === socketInstanceIndex) {
                accountIds.push(key);
            }
        });
        return accountIds;
    }
    /**
   * Returns account region by id
   * @param {String} accountId account id
   * @returns {String} account region
   */ getAccountRegion(accountId) {
        return this._regionsByAccounts[accountId] && this._regionsByAccounts[accountId].region;
    }
    /**
   * Adds account cache info
   * @param {String} accountId account id
   * @param {Object} replicas account replicas
   */ addAccountCache(accountId, replicas) {
        this._accountReplicas[accountId] = replicas;
        Object.keys(replicas).forEach((region)=>{
            const replicaId = replicas[region];
            if (!this._regionsByAccounts[replicaId]) {
                this._regionsByAccounts[replicaId] = {
                    region,
                    connections: 1,
                    lastUsed: Date.now()
                };
            } else {
                this._regionsByAccounts[replicaId].connections++;
            }
            this._accountsByReplicaId[replicaId] = accountId;
        });
        this._logger.debug(`${accountId}: added account cache`);
    }
    /**
   * Updates account cache info
   * @param {String} accountId account id
   * @param {Object} replicas account replicas
   */ updateAccountCache(accountId, replicas) {
        const oldReplicas = this._accountReplicas[accountId];
        if (oldReplicas) {
            const connectionCount = this._regionsByAccounts[accountId].connections;
            Object.keys(oldReplicas).forEach((region)=>{
                const replicaId = replicas[region];
                delete this._accountsByReplicaId[replicaId];
                delete this._regionsByAccounts[replicaId];
            });
            this._accountReplicas[accountId] = replicas;
            Object.keys(replicas).forEach((region)=>{
                const replicaId = replicas[region];
                this._regionsByAccounts[replicaId] = {
                    region,
                    connections: connectionCount,
                    lastUsed: Date.now()
                };
                this._accountsByReplicaId[replicaId] = accountId;
            });
            this._logger.debug(`${accountId}: updated account cache`);
        }
    }
    /**
   * Removes account region info
   * @param {String} accountId account id
   */ removeAccountCache(accountId) {
        if (this._regionsByAccounts[accountId]) {
            if (this._regionsByAccounts[accountId].connections > 0) {
                this._regionsByAccounts[accountId].connections--;
            }
        }
    }
    /**
   * Locks subscription for a socket instance based on TooManyRequestsError metadata
   * @param {Number} instanceNumber instance index number
   * @param {String} socketInstanceIndex socket instance index
   * @param {String} region server region
   * @param {Object} metadata TooManyRequestsError metadata
   */ lockSocketInstance(instanceNumber, socketInstanceIndex, region, metadata) {
        var _this = this;
        return _async_to_generator(function*() {
            if (metadata.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER') {
                _this._subscribeLock = {
                    recommendedRetryTime: metadata.recommendedRetryTime,
                    lockedAtAccounts: _this.subscribedAccountIds(instanceNumber, undefined, region).length,
                    lockedAtTime: Date.now()
                };
            } else {
                const subscribedAccounts = _this.subscribedAccountIds(instanceNumber, socketInstanceIndex, region);
                if (subscribedAccounts.length === 0) {
                    const socketInstance = _this.socketInstances[region][instanceNumber][socketInstanceIndex];
                    socketInstance.socket.close();
                    yield _this._reconnect(instanceNumber, socketInstanceIndex, region);
                } else {
                    const instance = _this.socketInstances[region][instanceNumber][socketInstanceIndex];
                    instance.subscribeLock = {
                        recommendedRetryTime: metadata.recommendedRetryTime,
                        type: metadata.type,
                        lockedAtAccounts: subscribedAccounts.length
                    };
                }
            }
        })();
    }
    /**
   * Connects to MetaApi server via socket.io protocol
   * @param {Number} instanceNumber instance index number
   * @param {String} region server region
   * @returns {Promise} promise which resolves when connection is established
   */ connect(instanceNumber, region) {
        var _this = this;
        return _async_to_generator(function*() {
            var _this__socketInstances, _region, _this__socketInstances_region, _instanceNumber;
            if (_this._region && region !== _this._region) {
                throw new ValidationError(`Trying to connect to ${region} region, but configured with ${_this._region}`);
            }
            let clientId = Math.random();
            let resolve;
            let result = new Promise((res, rej)=>{
                resolve = res;
            });
            (_this__socketInstances = _this._socketInstances)[_region = region] || (_this__socketInstances[_region] = {});
            (_this__socketInstances_region = _this._socketInstances[region])[_instanceNumber = instanceNumber] || (_this__socketInstances_region[_instanceNumber] = []);
            const socketInstanceIndex = _this._socketInstances[region][instanceNumber].length;
            const instance = {
                id: socketInstanceIndex,
                reconnectWaitTime: _this._socketMinimumReconnectTimeout,
                connected: false,
                requestResolves: {},
                resolved: false,
                connectResult: result,
                sessionId: randomstring.generate(32),
                isReconnecting: false,
                socket: null,
                synchronizationThrottler: new SynchronizationThrottler(_this, socketInstanceIndex, instanceNumber, region, _this._synchronizationThrottlerOpts),
                subscribeLock: null,
                instanceNumber
            };
            instance.connected = true;
            _this._socketInstances[region][instanceNumber].push(instance);
            instance.synchronizationThrottler.start();
            const serverUrl = yield _this._getServerUrl(instanceNumber, socketInstanceIndex, region);
            const socketInstance = socketIO(serverUrl, {
                path: '/ws',
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: Infinity,
                timeout: _this._connectTimeout,
                extraHeaders: {
                    'Client-Id': clientId
                },
                query: {
                    'auth-token': _this._token,
                    clientId: clientId,
                    protocol: 3
                }
            });
            instance.socket = socketInstance;
            socketInstance.on('connect', /*#__PURE__*/ _async_to_generator(function*() {
                // eslint-disable-next-line no-console
                _this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client connected to the MetaApi server`);
                instance.reconnectWaitTime = _this._socketMinimumReconnectTimeout;
                instance.isReconnecting = false;
                if (!instance.resolved) {
                    instance.resolved = true;
                    resolve();
                } else {
                    yield _this._fireReconnected(instanceNumber, instance.id, region);
                }
                if (!instance.connected) {
                    instance.socket.close();
                }
            }));
            socketInstance.on('reconnect', /*#__PURE__*/ _async_to_generator(function*() {
                instance.isReconnecting = false;
                _this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client reconnected`);
                yield _this._fireReconnected(instanceNumber, instance.id, region);
            }));
            socketInstance.on('connect_error', function() {
                var _ref = _async_to_generator(function*(err) {
                    // eslint-disable-next-line no-console
                    _this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client connection error`, err);
                    instance.isReconnecting = false;
                    yield _this._reconnect(instanceNumber, instance.id, region);
                });
                return function(err) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('connect_timeout', function() {
                var _ref = _async_to_generator(function*(timeout) {
                    // eslint-disable-next-line no-console
                    _this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client connection timeout`);
                    instance.isReconnecting = false;
                    if (!instance.resolved) {
                        yield _this._reconnect(instanceNumber, instance.id, region);
                    }
                });
                return function(timeout) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('disconnect', function() {
                var _ref = _async_to_generator(function*(reason) {
                    instance.synchronizationThrottler.onDisconnect();
                    // eslint-disable-next-line no-console
                    _this._logger.info(`${region}:${instanceNumber}: MetaApi websocket client disconnected from the ` + `MetaApi server because of ${reason}`);
                    instance.isReconnecting = false;
                    yield _this._reconnect(instanceNumber, instance.id, region);
                });
                return function(reason) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('error', function() {
                var _ref = _async_to_generator(function*(error) {
                    // eslint-disable-next-line no-console
                    _this._logger.error(`${region}:${instanceNumber}: MetaApi websocket client error`, error);
                    instance.isReconnecting = false;
                    yield _this._reconnect(instanceNumber, instance.id, region);
                });
                return function(error) {
                    return _ref.apply(this, arguments);
                };
            }());
            socketInstance.on('response', (data)=>{
                if (typeof data === 'string') {
                    data = JSON.parse(data);
                }
                _this._logger.debug(()=>`${data.accountId}: Response received: ${JSON.stringify({
                        requestId: data.requestId,
                        timestamps: data.timestamps
                    })}`);
                let requestResolve = instance.requestResolves[data.requestId] || {
                    resolve: ()=>{},
                    reject: ()=>{}
                };
                delete instance.requestResolves[data.requestId];
                _this._convertIsoTimeToDate(data);
                requestResolve.resolve(data);
                if (data.timestamps && requestResolve.type) {
                    data.timestamps.clientProcessingFinished = new Date();
                    for (let listener of _this._latencyListeners){
                        Promise.resolve().then(()=>requestResolve.type === 'trade' ? listener.onTrade(data.accountId, data.timestamps) : listener.onResponse(data.accountId, requestResolve.type, data.timestamps)).catch((error)=>_this._logger.error('Failed to process onResponse event for account ' + data.accountId + ', request type ' + requestResolve.type, error));
                    }
                }
            });
            socketInstance.on('processingError', (data)=>{
                let requestResolve = instance.requestResolves[data.requestId] || {
                    resolve: ()=>{},
                    reject: ()=>{}
                };
                delete instance.requestResolves[data.requestId];
                requestResolve.reject(_this._convertError(data));
            });
            // eslint-disable-next-line complexity
            socketInstance.on('synchronization', function() {
                var _ref = _async_to_generator(function*(data) {
                    if (typeof data === 'string') {
                        data = JSON.parse(data);
                    }
                    if (data.instanceIndex && data.instanceIndex !== instanceNumber) {
                        _this._logger.trace(()=>`${data.accountId}:${data.instanceNumber}: received packet with wrong instance ` + `index via a socket with instance number of ${instanceNumber}, data=${JSON.stringify({
                                type: data.type,
                                sequenceNumber: data.sequenceNumber,
                                sequenceTimestamp: data.sequenceTimestamp,
                                synchronizationId: data.synchronizationId,
                                application: data.application,
                                host: data.host,
                                specificationsUpdated: data.specificationsUpdated,
                                positionsUpdated: data.positionsUpdated,
                                ordersUpdated: data.ordersUpdated,
                                specifications: data.specifications ? (data.specifications || []).length : undefined
                            })}`);
                        return;
                    }
                    if (!_this._regionsByAccounts[data.accountId]) {
                        _this._regionsByAccounts[data.accountId] = {
                            region,
                            connections: 0,
                            lastUsed: Date.now()
                        };
                    }
                    _this._logger.trace(()=>`${data.accountId}:${data.instanceIndex}: Sync packet received: ${JSON.stringify({
                            type: data.type,
                            sequenceNumber: data.sequenceNumber,
                            sequenceTimestamp: data.sequenceTimestamp,
                            synchronizationId: data.synchronizationId,
                            application: data.application,
                            host: data.host,
                            specificationsUpdated: data.specificationsUpdated,
                            positionsUpdated: data.positionsUpdated,
                            ordersUpdated: data.ordersUpdated,
                            specifications: data.specifications ? (data.specifications || []).length : undefined
                        })}, ` + `active listeners: ${(_this._synchronizationListeners[data.accountId] || []).length}`);
                    let activeSynchronizationIds = instance.synchronizationThrottler.activeSynchronizationIds;
                    if (!data.synchronizationId || activeSynchronizationIds.includes(data.synchronizationId)) {
                        if (_this._packetLogger) {
                            yield _this._packetLogger.logPacket(data);
                        }
                        const ignoredPacketTypes = [
                            'disconnected',
                            'status',
                            'keepalive'
                        ];
                        if (!_this._subscriptionManager.isSubscriptionActive(data.accountId) && !ignoredPacketTypes.includes(data.type)) {
                            _this._logger.debug(`${data.accountId}: Packet arrived to inactive connection, attempting` + ` unsubscribe, packet: ${data.type}`);
                            if (_this._throttleRequest('unsubscribe', data.accountId, data.instanceIndex, _this._unsubscribeThrottlingInterval)) {
                                _this.unsubscribe(data.accountId).catch((err)=>{
                                    _this._logger.warn(`${data.accountId}:${data.instanceIndex || 0}: failed to unsubscribe`, err);
                                });
                            }
                            return;
                        }
                        _this._convertIsoTimeToDate(data);
                    } else {
                        data.type = 'noop';
                    }
                    _this.queuePacket(data);
                });
                return function(data) {
                    return _ref.apply(this, arguments);
                };
            }());
            return result;
        })();
    }
    /**
   * Closes connection to MetaApi server
   */ close() {
        Object.keys(this._socketInstances).forEach((region)=>{
            Object.keys(this._socketInstances[region]).forEach((instanceNumber)=>{
                this._socketInstances[region][instanceNumber].forEach(function() {
                    var _ref = _async_to_generator(function*(instance) {
                        if (instance.connected) {
                            instance.connected = false;
                            yield instance.socket.close();
                            for (let requestResolve of Object.values(instance.requestResolves)){
                                requestResolve.reject(new Error('MetaApi connection closed'));
                            }
                            instance.requestResolves = {};
                        }
                    });
                    return function(instance) {
                        return _ref.apply(this, arguments);
                    };
                }());
                this._socketInstancesByAccounts[instanceNumber] = {};
                this._socketInstances[region][instanceNumber] = [];
            });
        });
        this._synchronizationListeners = {};
        this._latencyListeners = [];
        this._packetOrderer.stop();
    }
    /**
   * Stops the client
   */ stop() {
        clearInterval(this._clearAccountCacheInterval);
        clearInterval(this._clearInactiveSyncDataJob);
        this._latencyService.stop();
    }
    /**
   * Returns account information for a specified MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {GetAccountInformationOptions} [options] additional request options
   * @returns {Promise<MetatraderAccountInformation>} promise resolving with account information
   */ getAccountInformation(accountId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getAccountInformation'
            }, options));
            return response.accountInformation;
        })();
    }
    /**
   * Returns positions for a specified MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {GetPositionsOptions} [options] additional request options
   * @returns {Promise<Array<MetatraderPosition>} promise resolving with array of open positions
   */ getPositions(accountId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getPositions'
            }, options));
            return response.positions;
        })();
    }
    /**
   * Returns specific position for a MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @param {GetPositionOptions} [options] additional request options
   * @return {Promise<MetatraderPosition>} promise resolving with MetaTrader position found
   */ getPosition(accountId, positionId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getPosition',
                positionId
            }, options));
            return response.position;
        })();
    }
    /**
   * Returns open orders for a specified MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {GetOrdersOptions} [options] additional request options
   * @return {Promise<Array<MetatraderOrder>>} promise resolving with open MetaTrader orders
   */ getOrders(accountId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getOrders'
            }, options));
            return response.orders;
        })();
    }
    /**
   * Returns specific open order for a MetaTrader account.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} orderId order id (ticket number)
   * @param {GetOrderOptions} [options] additional request options
   * @return {Promise<MetatraderOrder>} promise resolving with metatrader order found
   */ getOrder(accountId, orderId, options) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, _object_spread({
                application: 'RPC',
                type: 'getOrder',
                orderId
            }, options));
            return response.order;
        })();
    }
    /**
   * MetaTrader history orders search query response
   * @typedef {Object} MetatraderHistoryOrders
   * @property {Array<MetatraderOrder>} historyOrders array of history orders returned
   * @property {Boolean} synchronizing flag indicating that history order initial synchronization is still in progress
   * and thus search results may be incomplete
   */ /**
   * Returns the history of completed orders for a specific ticket number.
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (order id)
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */ getHistoryOrdersByTicket(accountId, ticket) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getHistoryOrdersByTicket',
                ticket
            });
            return {
                historyOrders: response.historyOrders,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns the history of completed orders for a specific position id
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */ getHistoryOrdersByPosition(accountId, positionId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getHistoryOrdersByPosition',
                positionId
            });
            return {
                historyOrders: response.historyOrders,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns the history of completed orders for a specific time range
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderHistoryOrders>} promise resolving with request results containing history orders found
   */ getHistoryOrdersByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getHistoryOrdersByTimeRange',
                startTime,
                endTime,
                offset,
                limit
            });
            return {
                historyOrders: response.historyOrders,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * MetaTrader history deals search query response
   * @typedef {Object} MetatraderDeals
   * @property {Array<MetatraderDeal>} deals array of history deals returned
   * @property {Boolean} synchronizing flag indicating that deal initial synchronization is still in progress
   * and thus search results may be incomplete
   */ /**
   * MetaTrader deal
   * @typedef {Object} MetatraderDeal
   * @property {String} id deal id (ticket number)
   * @property {String} type deal type (one of DEAL_TYPE_BUY, DEAL_TYPE_SELL, DEAL_TYPE_BALANCE, DEAL_TYPE_CREDIT,
   * DEAL_TYPE_CHARGE, DEAL_TYPE_CORRECTION, DEAL_TYPE_BONUS, DEAL_TYPE_COMMISSION, DEAL_TYPE_COMMISSION_DAILY,
   * DEAL_TYPE_COMMISSION_MONTHLY, DEAL_TYPE_COMMISSION_AGENT_DAILY, DEAL_TYPE_COMMISSION_AGENT_MONTHLY,
   * DEAL_TYPE_INTEREST, DEAL_TYPE_BUY_CANCELED, DEAL_TYPE_SELL_CANCELED, DEAL_DIVIDEND, DEAL_DIVIDEND_FRANKED,
   * DEAL_TAX). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_type
   * @property {String} entryType deal entry type (one of DEAL_ENTRY_IN, DEAL_ENTRY_OUT, DEAL_ENTRY_INOUT,
   * DEAL_ENTRY_OUT_BY). See https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_entry
   * @property {String} [symbol] symbol deal relates to
   * @property {Number} [magic] deal magic number, identifies the EA which initiated the deal
   * @property {Date} time time the deal was conducted at
   * @property {String} brokerTime time time the deal was conducted at, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Number} [volume] deal volume
   * @property {Number} [price] the price the deal was conducted at
   * @property {Number} [commission] deal commission
   * @property {Number} [swap] deal swap
   * @property {Number} profit deal profit
   * @property {String} [positionId] id of position the deal relates to
   * @property {String} [orderId] id of order the deal relates to
   * @property {String} [comment] deal comment. The sum of the line lengths of the comment and the clientId
   * must be less than or equal to 26. For more information see https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} [brokerComment] current comment value on broker side (possibly overriden by the broker)
   * @property {String} [clientId] client-assigned id. The id value can be assigned when submitting a trade and
   * will be present on position, history orders and history deals related to the trade. You can use this field to bind
   * your trades to objects in your application and then track trade progress. The sum of the line lengths of the
   * comment and the clientId must be less than or equal to 26. For more information see
   * https://metaapi.cloud/docs/client/clientIdUsage/
   * @property {String} platform platform id (mt4 or mt5)
   * @property {String} [reason] optional deal execution reason. One of DEAL_REASON_CLIENT, DEAL_REASON_MOBILE,
   * DEAL_REASON_WEB, DEAL_REASON_EXPERT, DEAL_REASON_SL, DEAL_REASON_TP, DEAL_REASON_SO, DEAL_REASON_ROLLOVER,
   * DEAL_REASON_VMARGIN, DEAL_REASON_SPLIT, DEAL_REASON_UNKNOWN. See
   * https://www.mql5.com/en/docs/constants/tradingconstants/dealproperties#enum_deal_reason.
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {number} [stopLoss] deal stop loss. For MT5 opening deal this is the SL of the order opening the 
   * position. For MT4 deals or MT5 closing deal this is the last known position SL.
   * @property {number} [takeProfit] deal take profit. For MT5 opening deal this is the TP of the order opening the 
   * position. For MT4 deals or MT5 closing deal this is the last known position TP.
   */ /**
   * Returns history deals with a specific ticket number
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} ticket ticket number (deal id for MT5 or order id for MT4)
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */ getDealsByTicket(accountId, ticket) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getDealsByTicket',
                ticket
            });
            return {
                deals: response.deals,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns history deals for a specific position id
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {String} positionId position id
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */ getDealsByPosition(accountId, positionId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getDealsByPosition',
                positionId
            });
            return {
                deals: response.deals,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Returns history deals with for a specific time range
   * @param {String} accountId id of the MetaTrader account to return information for
   * @param {Date} startTime start of time range, inclusive
   * @param {Date} endTime end of time range, exclusive
   * @param {Number} offset pagination offset, default is 0
   * @param {Number} limit pagination limit, default is 1000
   * @returns {Promise<MetatraderDeals>} promise resolving with request results containing deals found
   */ getDealsByTimeRange(accountId, startTime, endTime, offset = 0, limit = 1000) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getDealsByTimeRange',
                startTime,
                endTime,
                offset,
                limit
            });
            return {
                deals: response.deals,
                synchronizing: response.synchronizing
            };
        })();
    }
    /**
   * Clears the order and transaction history of a specified application and removes the application
   * @param {String} accountId id of the MetaTrader account to remove history and application for
   * @return {Promise} promise resolving when the history is cleared
   */ removeApplication(accountId) {
        return this.rpcRequest(accountId, {
            type: 'removeApplication'
        });
    }
    /**
   * MetaTrader trade response
   * @typedef {Object} MetatraderTradeResponse
   * @property {Number} numericCode numeric response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are 0, 10008-10010, 10025. The rest
   * codes are errors
   * @property {String} stringCode string response code, see
   * https://www.mql5.com/en/docs/constants/errorswarnings/enum_trade_return_codes and
   * https://book.mql4.com/appendix/errors. Response codes which indicate success are ERR_NO_ERROR,
   * TRADE_RETCODE_PLACED, TRADE_RETCODE_DONE, TRADE_RETCODE_DONE_PARTIAL, TRADE_RETCODE_NO_CHANGES. The rest codes are
   * errors.
   * @property {String} message human-readable response message
   * @property {String} orderId order id which was created/modified during the trade
   * @property {String} positionId position id which was modified during the trade
   */ /**
   * Execute a trade on a connected MetaTrader account
   * @param {String} accountId id of the MetaTrader account to execute trade for
   * @param {MetatraderTrade} trade trade to execute (see docs for possible trade types)
   * @param {String} [application] application to use
   * @param {String} [reliability] account reliability
   * @returns {Promise<MetatraderTradeResponse>} promise resolving with trade result
   * @throws {TradeError} on trade error, check error properties for error code details
   */ // eslint-disable-next-line complexity
    trade(accountId, trade, application, reliability) {
        var _this = this;
        return _async_to_generator(function*() {
            let response;
            if (application === 'RPC') {
                response = yield _this.rpcRequest(accountId, {
                    type: 'trade',
                    trade,
                    application
                });
            } else {
                response = yield _this.rpcRequestAllInstances(accountId, {
                    type: 'trade',
                    trade,
                    application: application || _this._application,
                    requestId: randomstring.generate(32)
                }, reliability);
            }
            response.response = response.response || {};
            response.response.stringCode = response.response.stringCode || response.response.description;
            response.response.numericCode = response.response.numericCode !== undefined ? response.response.numericCode : response.response.error;
            if ([
                'ERR_NO_ERROR',
                'TRADE_RETCODE_PLACED',
                'TRADE_RETCODE_DONE',
                'TRADE_RETCODE_DONE_PARTIAL',
                'TRADE_RETCODE_NO_CHANGES'
            ].includes(response.response.stringCode || response.response.description)) {
                return response.response;
            } else {
                throw new TradeError(response.response.message, response.response.numericCode, response.response.stringCode);
            }
        })();
    }
    /**
   * Creates a task that ensures the account gets subscribed to the server
   * @param {String} accountId account id to subscribe
   * @param {Number} instanceNumber instance index number
   */ ensureSubscribe(accountId, instanceNumber) {
        this._subscriptionManager.scheduleSubscribe(accountId, instanceNumber);
    }
    /**
   * Subscribes to the Metatrader terminal events
   * @param {String} accountId id of the MetaTrader account to subscribe to
   * @param {Number} instanceNumber instance index number
   * @returns {Promise} promise which resolves when subscription started
   */ subscribe(accountId, instanceNumber) {
        return this._subscriptionManager.subscribe(accountId, instanceNumber);
    }
    /**
   * Requests the terminal to start synchronization process
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} instanceIndex instance index
   * @param {String} host name of host to synchronize with
   * @param {String} synchronizationId synchronization request id
   * @param {Date} startingHistoryOrderTime from what date to start synchronizing history orders from. If not specified,
   * the entire order history will be downloaded.
   * @param {Date} startingDealTime from what date to start deal synchronization from. If not specified, then all
   * history deals will be downloaded.
   * @param {Function} getHashes function to get terminal state hashes
   * @returns {Promise} promise which resolves when synchronization started
   */ synchronize(accountId, instanceIndex, host, synchronizationId, startingHistoryOrderTime, startingDealTime, hashes) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._getSocketInstanceByAccount(accountId, instanceIndex) === undefined) {
                _this._logger.debug(`${accountId}:${instanceIndex}: creating socket instance on synchronize`);
                yield _this._createSocketInstanceByAccount(accountId, instanceIndex);
            }
            const syncThrottler = _this._getSocketInstanceByAccount(accountId, instanceIndex).synchronizationThrottler;
            _this._synchronizationHashes[synchronizationId] = hashes;
            _this._synchronizationHashes[synchronizationId].lastUpdated = Date.now();
            return syncThrottler.scheduleSynchronize(accountId, {
                requestId: synchronizationId,
                version: 2,
                type: 'synchronize',
                startingHistoryOrderTime,
                startingDealTime,
                instanceIndex,
                host
            }, hashes);
        })();
    }
    /**
   * Waits for server-side terminal state synchronization to complete
   * @param {String} accountId id of the MetaTrader account to synchronize
   * @param {Number} [instanceNumber] instance index number
   * @param {String} applicationPattern MetaApi application regular expression pattern, default is .*
   * @param {Number} timeoutInSeconds timeout in seconds, default is 300 seconds
   * @param {String} [application] application to synchronize with
   * @returns {Promise} promise which resolves when synchronization started
   */ waitSynchronized(accountId, instanceNumber, applicationPattern, timeoutInSeconds, application) {
        return this.rpcRequest(accountId, {
            type: 'waitSynchronized',
            applicationPattern,
            timeoutInSeconds,
            instanceIndex: instanceNumber,
            application: application || this._application
        }, timeoutInSeconds + 1);
    }
    /**
   * Market data subscription
   * @typedef {Object} MarketDataSubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   * @property {string} [timeframe] when subscription type is candles, defines the timeframe according to which the
   * candles must be generated. Allowed values for MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h,
   * 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @property {number} [intervalInMilliseconds] defines how frequently the terminal will stream data to client. If not
   * set, then the value configured in account will be used
   */ /**
   * Subscribes on market data of specified symbol
   * @param {String} accountId id of the MetaTrader account
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataSubscription>} subscriptions array of market data subscription to create or update
   * @param {String} [reliability] account reliability
   * @returns {Promise} promise which resolves when subscription request was processed
   */ subscribeToMarketData(accountId, symbol, subscriptions, reliability) {
        return this.rpcRequestAllInstances(accountId, {
            type: 'subscribeToMarketData',
            symbol,
            subscriptions
        }, reliability);
    }
    /**
   * Refreshes market data subscriptions on the server to prevent them from expiring
   * @param {String} accountId id of the MetaTrader account
   * @param {Number} instanceNumber instance index number
   * @param {Array} subscriptions array of subscriptions to refresh
   */ refreshMarketDataSubscriptions(accountId, instanceNumber, subscriptions) {
        return this.rpcRequest(accountId, {
            type: 'refreshMarketDataSubscriptions',
            subscriptions,
            instanceIndex: instanceNumber
        });
    }
    /**
   * Market data unsubscription
   * @typedef {Object} MarketDataUnsubscription
   * @property {string} type subscription type, one of quotes, candles, ticks, or marketDepth
   */ /**
   * Unsubscribes from market data of specified symbol
   * @param {String} accountId id of the MetaTrader account
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @param {Array<MarketDataUnsubscription>} subscriptions array of subscriptions to cancel
   * @param {String} [reliability] account reliability
   * @returns {Promise} promise which resolves when unsubscription request was processed
   */ unsubscribeFromMarketData(accountId, symbol, subscriptions, reliability) {
        return this.rpcRequestAllInstances(accountId, {
            type: 'unsubscribeFromMarketData',
            symbol,
            subscriptions
        }, reliability);
    }
    /**
   * Retrieves symbols available on an account
   * @param {String} accountId id of the MetaTrader account to retrieve symbols for
   * @returns {Promise<Array<string>>} promise which resolves when symbols are retrieved
   */ getSymbols(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getSymbols'
            });
            return response.symbols;
        })();
    }
    /**
   * Retrieves specification for a symbol
   * @param {String} accountId id of the MetaTrader account to retrieve symbol specification for
   * @param {String} symbol symbol to retrieve specification for
   * @returns {Promise<MetatraderSymbolSpecification>} promise which resolves when specification is retrieved
   */ getSymbolSpecification(accountId, symbol) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getSymbolSpecification',
                symbol
            });
            return response.specification;
        })();
    }
    /**
   * Retrieves price for a symbol
   * @param {String} accountId id of the MetaTrader account to retrieve symbol price for
   * @param {String} symbol symbol to retrieve price for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderSymbolPrice>} promise which resolves when price is retrieved
   */ getSymbolPrice(accountId, symbol, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getSymbolPrice',
                symbol,
                keepSubscription
            });
            return response.price;
        })();
    }
    /**
   * Retrieves price for a symbol
   * @param {string} accountId id of the MetaTrader account to retrieve candle for
   * @param {string} symbol symbol to retrieve candle for
   * @param {string} timeframe defines the timeframe according to which the candle must be generated. Allowed values for
   * MT5 are 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m, 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn. Allowed values
   * for MT4 are 1m, 5m, 15m 30m, 1h, 4h, 1d, 1w, 1mn
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderCandle>} promise which resolves when candle is retrieved
   */ getCandle(accountId, symbol, timeframe, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getCandle',
                symbol,
                timeframe,
                keepSubscription
            });
            return response.candle;
        })();
    }
    /**
   * Retrieves latest tick for a symbol. MT4 G1 accounts do not support this API
   * @param {string} accountId id of the MetaTrader account to retrieve symbol tick for
   * @param {string} symbol symbol to retrieve tick for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderTick>} promise which resolves when tick is retrieved
   */ getTick(accountId, symbol, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getTick',
                symbol,
                keepSubscription
            });
            return response.tick;
        })();
    }
    /**
   * Retrieves latest order book for a symbol. MT4 accounts do not support this API
   * @param {string} accountId id of the MetaTrader account to retrieve symbol order book for
   * @param {string} symbol symbol to retrieve order book for
   * @param {boolean} keepSubscription if set to true, the account will get a long-term subscription to symbol market
   * data. Long-term subscription means that on subsequent calls you will get updated value faster. If set to false or
   * not set, the subscription will be set to expire in 12 minutes.
   * @returns {Promise<MetatraderBook>} promise which resolves when order book is retrieved
   */ getBook(accountId, symbol, keepSubscription = false) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getBook',
                symbol,
                keepSubscription
            });
            return response.book;
        })();
    }
    /**
   * Forces refresh of most recent quote updates for symbols subscribed to by the terminal
   * @param {string} accountId id of the MetaTrader account
   * @returns {Promise<string[]>} promise which resolves with recent quote symbols that was initiated to process
   */ refreshTerminalState(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'refreshTerminalState'
            });
            return response.symbols;
        })();
    }
    /**
   * Forces refresh and retrieves latest quotes for a subset of symbols the terminal is subscribed to
   * @param {string} accountId id of the MetaTrader account
   * @param {string[]} symbols quote symbols to refresh
   * @returns {Promise<RefreshedQuotes>} refreshed quotes and basic account information info
   */ refreshSymbolQuotes(accountId, symbols) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'refreshSymbolQuotes',
                symbols
            });
            return response.refreshedQuotes;
        })();
    }
    /**
   * Sends client uptime stats to the server.
   * @param {String} accountId id of the MetaTrader account to save uptime
   * @param {Object} uptime uptime statistics to send to the server
   * @returns {Promise} promise which resolves when uptime statistics is submitted
   */ saveUptime(accountId, uptime) {
        return this.rpcRequest(accountId, {
            type: 'saveUptime',
            uptime
        });
    }
    /**
   * Unsubscribe from account
   * @param {String} accountId id of the MetaTrader account to unsubscribe
   * @returns {Promise} promise which resolves when socket unsubscribed
   */ unsubscribe(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            const region = _this.getAccountRegion(accountId);
            _this._latencyService.onUnsubscribe(accountId);
            const updateEventsToRemove = Object.keys(_this._updateEvents).filter((key)=>key.startsWith(accountId));
            updateEventsToRemove.forEach((key)=>delete _this._updateEvents[key]);
            if (_this._socketInstances[region]) {
                yield Promise.all(Object.keys(_this._socketInstances[region]).map(function() {
                    var _ref = _async_to_generator(function*(instanceNumber) {
                        try {
                            yield _this._subscriptionManager.unsubscribe(accountId, Number(instanceNumber));
                            delete _this._socketInstancesByAccounts[instanceNumber][accountId];
                        } catch (err) {
                            if (![
                                'TimeoutError',
                                'NotFoundError'
                            ].includes(err.name)) {
                                _this._logger.warn(`${accountId}:${instanceNumber}: failed to unsubscribe`, err);
                            }
                        }
                    });
                    return function(instanceNumber) {
                        return _ref.apply(this, arguments);
                    };
                }()));
            }
        })();
    }
    /**
   * Current server time (see https://metaapi.cloud/docs/client/models/serverTime/)
   * @typedef {Object} ServerTime
   * @property {Date} time current server time
   * @property {String} brokerTime current broker time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Date} [lastQuoteTime] last quote time
   * @property {String} [lastQuoteBrokerTime] last quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */ /**
   * Returns server time for a specified MetaTrader account
   * @param {string} accountId id of the MetaTrader account to return server time for
   * @returns {Promise<ServerTime>} promise resolving with server time
   */ getServerTime(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            let response = yield _this.rpcRequest(accountId, {
                application: 'RPC',
                type: 'getServerTime'
            });
            return response.serverTime;
        })();
    }
    /**
   * Margin required to open a trade (see https://metaapi.cloud/docs/client/models/margin/)
   * @typedef {Object} Margin
   * @property {number} [margin] margin required to open a trade. If margin can not be calculated, then this field is
   * not defined
   */ /**
   * Contains order to calculate margin for (see https://metaapi.cloud/docs/client/models/marginOrder/)
   * @typedef {Object} MarginOrder
   * @property {string} symbol order symbol
   * @property {string} type order type, one of ORDER_TYPE_BUY or ORDER_TYPE_SELL
   * @property {number} volume order volume, must be greater than 0
   * @property {number} openPrice order open price, must be greater than 0
   */ /**
   * Calculates margin required to open a trade on the specified trading account
   * @param {string} accountId id of the trading account to calculate margin for
   * @param {string} application application to send the request to
   * @param {string} reliability account reliability
   * @param {MarginOrder} order order to calculate margin for
   * @returns {Promise<Margin>} promise resolving with margin calculation result
   */ calculateMargin(accountId, application, reliability, order) {
        var _this = this;
        return _async_to_generator(function*() {
            let response;
            if (application === 'RPC') {
                response = yield _this.rpcRequest(accountId, {
                    application,
                    type: 'calculateMargin',
                    order
                });
            } else {
                response = yield _this.rpcRequestAllInstances(accountId, {
                    application,
                    type: 'calculateMargin',
                    order
                }, reliability);
            }
            return response.margin;
        })();
    }
    /**
   * Calls onUnsubscribeRegion listener event 
   * @param {String} accountId account id
   * @param {String} region account region to unsubscribe
   */ unsubscribeAccountRegion(accountId, region) {
        var _this = this;
        return _async_to_generator(function*() {
            const unsubscribePromises = [];
            for (let listener of _this._synchronizationListeners[accountId] || []){
                unsubscribePromises.push(Promise.resolve(_async_to_generator(function*() {
                    yield _this._processEvent(()=>listener.onUnsubscribeRegion(region), `${accountId}:${region}:onUnsubscribeRegion`, true);
                })()).catch((err)=>_this._logger.error(`${accountId}:${region}: Failed to notify listener ` + 'about onUnsubscribeRegion event', err)));
            }
            yield Promise.all(unsubscribePromises);
        })();
    }
    /**
   * Adds synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to add
   */ addSynchronizationListener(accountId, listener) {
        this._logger.trace(`${accountId}: Added synchronization listener`);
        let listeners = this._synchronizationListeners[accountId];
        if (!listeners) {
            listeners = [];
            this._synchronizationListeners[accountId] = listeners;
        }
        listeners.push(listener);
    }
    /**
   * Removes synchronization listener for specific account
   * @param {String} accountId account id
   * @param {SynchronizationListener} listener synchronization listener to remove
   */ removeSynchronizationListener(accountId, listener) {
        this._logger.trace(`${accountId}: Removed synchronization listener`);
        let listeners = this._synchronizationListeners[accountId];
        if (!listeners) {
            listeners = [];
        }
        listeners = listeners.filter((l)=>l !== listener);
        this._synchronizationListeners[accountId] = listeners;
    }
    /**
   * Adds latency listener
   * @param {LatencyListener} listener latency listener to add
   */ addLatencyListener(listener) {
        this._latencyListeners.push(listener);
    }
    /**
   * Removes latency listener
   * @param {LatencyListener} listener latency listener to remove
   */ removeLatencyListener(listener) {
        this._latencyListeners = this._latencyListeners.filter((l)=>l !== listener);
    }
    /**
   * Adds reconnect listener
   * @param {ReconnectListener} listener reconnect listener to add
   * @param {String} accountId account id of listener
   */ addReconnectListener(listener, accountId) {
        this._reconnectListeners.push({
            accountId,
            listener
        });
    }
    /**
   * Removes reconnect listener
   * @param {ReconnectListener} listener listener to remove
   */ removeReconnectListener(listener) {
        this._reconnectListeners = this._reconnectListeners.filter((l)=>l.listener !== listener);
    }
    /**
   * Removes all listeners. Intended for use in unit tests.
   */ removeAllListeners() {
        this._synchronizationListeners = {};
        this._reconnectListeners = [];
    }
    /**
   * Clears account or replica data from client records and unsubscribes
   * @param {string} accountId account id to process the removal of
   */ onAccountDeleted(accountId) {
        this._subscriptionManager.cancelAccount(accountId);
        this._latencyService.onUnsubscribe(accountId);
        const masterAccountId = this._accountsByReplicaId[accountId];
        if (masterAccountId) {
            if (masterAccountId === accountId) {
                const regionData = this._accountReplicas[masterAccountId];
                const replicas = Object.values(regionData);
                Object.keys(this._synchronizationIdByInstance).filter((instance)=>instance.startsWith(`${masterAccountId}`)).forEach((instance)=>delete this._synchronizationIdByInstance[instance]);
                replicas.forEach((replica)=>{
                    Object.values(this._socketInstancesByAccounts).forEach((instance)=>{
                        delete instance[replica];
                    });
                    delete this._accountsByReplicaId[replica];
                    delete this._regionsByAccounts[replica];
                });
                delete this._accountReplicas[masterAccountId];
                this._logger.debug(`${masterAccountId}: processed primary account removal`);
            } else {
                Object.values(this._socketInstancesByAccounts).forEach((instance)=>{
                    delete instance[accountId];
                });
                const regionData = this._regionsByAccounts[accountId];
                if (regionData) {
                    const region = regionData.region;
                    Object.keys(this._synchronizationIdByInstance).filter((instance)=>instance.startsWith(`${masterAccountId}:${region}`)).forEach((instance)=>delete this._synchronizationIdByInstance[instance]);
                    delete this._accountReplicas[masterAccountId][region];
                    this._logger.debug(`${masterAccountId}: processed removal of replica ${accountId}`);
                }
                delete this._accountsByReplicaId[accountId];
                delete this._regionsByAccounts[accountId];
            }
        }
    }
    /**
   * Queues an account packet for processing
   * @param {Object} packet packet to process
   */ queuePacket(packet) {
        const accountId = packet.accountId;
        const packets = this._packetOrderer.restoreOrder(packet).filter((p)=>p.type !== 'noop');
        if (this._sequentialEventProcessing && packet.sequenceNumber !== undefined) {
            const events = packets.map((packetItem)=>()=>Promise.resolve(this._processSynchronizationPacket(packetItem)));
            if (!this._eventQueues[accountId]) {
                this._eventQueues[accountId] = events;
                this._callAccountEvents(accountId);
            } else {
                this._eventQueues[accountId] = this._eventQueues[accountId].concat(events);
            }
        } else {
            packets.forEach((packetItem)=>this._processSynchronizationPacket(packetItem));
        }
    }
    /**
   * Queues account event for processing
   * @param {String} accountId account id
   * @param {String} name event label name
   * @param {Function} callable async or regular function to execute
   */ queueEvent(accountId, name, callable) {
        let event = ()=>this._processEvent(callable, `${accountId}:${name}`);
        if (this._sequentialEventProcessing) {
            if (!this._eventQueues[accountId]) {
                this._eventQueues[accountId] = [
                    event
                ];
                this._callAccountEvents(accountId);
            } else {
                this._eventQueues[accountId].push(event);
            }
        } else {
            event();
        }
    }
    _callAccountEvents(accountId) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._eventQueues[accountId]) {
                while(_this._eventQueues[accountId].length){
                    yield _this._eventQueues[accountId][0]();
                    _this._eventQueues[accountId].shift();
                }
                delete _this._eventQueues[accountId];
            }
        })();
    }
    _reconnect(instanceNumber, socketInstanceIndex, region) {
        var _this = this;
        return _async_to_generator(function*() {
            const instance = _this.socketInstances[region][instanceNumber][socketInstanceIndex];
            if (instance) {
                while(!instance.socket.connected && !instance.isReconnecting && instance.connected){
                    yield _this._tryReconnect(instanceNumber, socketInstanceIndex, region);
                }
            }
        })();
    }
    _tryReconnect(instanceNumber, socketInstanceIndex, region) {
        const instance = this.socketInstances[region][instanceNumber][socketInstanceIndex];
        instance.reconnectWaitTime = Math.min(instance.reconnectWaitTime * 2, 30000);
        var _this = this;
        return new Promise((resolve)=>setTimeout(/*#__PURE__*/ _async_to_generator(function*() {
                if (!instance.socket.connected && !instance.isReconnecting && instance.connected) {
                    try {
                        instance.sessionId = randomstring.generate(32);
                        const clientId = Math.random();
                        instance.socket.close();
                        instance.socket.io.opts.extraHeaders['Client-Id'] = clientId;
                        instance.socket.io.opts.query.clientId = clientId;
                        instance.isReconnecting = true;
                        instance.socket.io.uri = yield _this._getServerUrl(instanceNumber, socketInstanceIndex, region);
                        instance.socket.connect();
                    } catch (error) {
                        instance.isReconnecting = false;
                    }
                }
                resolve();
            }), instance.reconnectWaitTime));
    }
    /**
   * Simulataneously sends RPC requests to all synchronized instances
   * @param {String} accountId metatrader account id
   * @param {Object} request base request data
   * @param {String} [reliability] account reliability
   * @param {Number} [timeoutInSeconds] request timeout in seconds
   */ rpcRequestAllInstances(accountId, request, reliability, timeoutInSeconds) {
        var _this = this;
        return _async_to_generator(function*() {
            if (reliability === 'high') {
                try {
                    return yield any([
                        0,
                        1
                    ].map((instanceNumber)=>{
                        return _this.rpcRequest(accountId, Object.assign({}, request, {
                            instanceIndex: instanceNumber
                        }), timeoutInSeconds);
                    }));
                } catch (error) {
                    throw error.errors[0];
                }
            } else {
                return yield _this.rpcRequest(accountId, request, timeoutInSeconds);
            }
        })();
    }
    /**
   * Makes a RPC request
   * @param {String} accountId metatrader account id
   * @param {Object} request base request data
   * @param {Number} [timeoutInSeconds] request timeout in seconds
   */ //eslint-disable-next-line complexity, max-statements
    rpcRequest(accountId, request, timeoutInSeconds) {
        var _this = this;
        return _async_to_generator(function*() {
            const ignoredRequestTypes = [
                'subscribe',
                'synchronize',
                'refreshMarketDataSubscriptions',
                'unsubscribe'
            ];
            const primaryAccountId = _this._accountsByReplicaId[accountId];
            let connectedInstance = _this._latencyService.getActiveAccountInstances(primaryAccountId)[0];
            if (!ignoredRequestTypes.includes(request.type)) {
                if (!connectedInstance) {
                    connectedInstance = yield _this._latencyService.waitConnectedInstance(accountId);
                }
                const activeRegion = connectedInstance.split(':')[1];
                accountId = _this._accountReplicas[primaryAccountId][activeRegion];
            }
            let socketInstanceIndex = null;
            let instanceNumber = 0;
            const region = _this.getAccountRegion(accountId);
            _this._refreshAccountRegion(accountId);
            if (request.instanceIndex !== undefined) {
                instanceNumber = request.instanceIndex;
            } else {
                if (connectedInstance) {
                    instanceNumber = Number(connectedInstance.split(':')[2]);
                }
                if (request.application !== 'RPC') {
                    request = Object.assign({}, request, {
                        instanceIndex: instanceNumber
                    });
                }
            }
            if (!_this._socketInstancesByAccounts[instanceNumber]) {
                _this._socketInstancesByAccounts[instanceNumber] = {};
            }
            if (!_this._socketInstances[region]) {
                _this._socketInstances[region] = {};
            }
            if (!_this._socketInstances[region][instanceNumber]) {
                _this._socketInstances[region][instanceNumber] = [];
            }
            if (_this._socketInstancesByAccounts[instanceNumber][accountId] !== undefined) {
                socketInstanceIndex = _this._socketInstancesByAccounts[instanceNumber][accountId];
            } else {
                _this._logger.debug(`${accountId}:${instanceNumber}: creating socket instance on RPC request`);
                yield _this._createSocketInstanceByAccount(accountId, instanceNumber);
                socketInstanceIndex = _this._socketInstancesByAccounts[instanceNumber][accountId];
            }
            const instance = _this._socketInstances[region][instanceNumber][socketInstanceIndex];
            if (!instance.connected) {
                _this._logger.debug(`${accountId}:${instanceNumber}: connecting socket instance on RPC request`);
                yield _this.connect(instanceNumber, region);
            } else if (!_this.connected(instanceNumber, socketInstanceIndex, region)) {
                yield instance.connectResult;
            }
            if (request.type === 'subscribe') {
                request.sessionId = instance.sessionId;
            }
            if ([
                'trade',
                'subscribe'
            ].includes(request.type)) {
                return _this._makeRequest(accountId, instanceNumber, request, timeoutInSeconds);
            }
            let retryCounter = 0;
            while(true){
                try {
                    return yield _this._makeRequest(accountId, instanceNumber, request, timeoutInSeconds);
                } catch (err) {
                    if (err.name === 'TooManyRequestsError') {
                        let calcRetryCounter = retryCounter;
                        let calcRequestTime = 0;
                        while(calcRetryCounter < _this._retries){
                            calcRetryCounter++;
                            calcRequestTime += Math.min(Math.pow(2, calcRetryCounter) * _this._minRetryDelayInSeconds, _this._maxRetryDelayInSeconds) * 1000;
                        }
                        const retryTime = new Date(err.metadata.recommendedRetryTime).getTime();
                        if (Date.now() + calcRequestTime > retryTime && retryCounter < _this._retries) {
                            if (Date.now() < retryTime) {
                                yield new Promise((res)=>setTimeout(res, retryTime - Date.now()));
                            }
                            retryCounter++;
                        } else {
                            throw err;
                        }
                    } else if ([
                        'NotSynchronizedError',
                        'TimeoutError',
                        'NotAuthenticatedError',
                        'InternalError'
                    ].includes(err.name) && retryCounter < _this._retries) {
                        yield new Promise((res)=>setTimeout(res, Math.min(Math.pow(2, retryCounter) * _this._minRetryDelayInSeconds, _this._maxRetryDelayInSeconds) * 1000));
                        retryCounter++;
                    } else {
                        throw err;
                    }
                    if (_this._socketInstancesByAccounts[instanceNumber][accountId] === undefined) {
                        throw err;
                    }
                }
            }
        })();
    }
    _makeRequest(accountId, instanceNumber, request, timeoutInSeconds) {
        const socketInstance = this._getSocketInstanceByAccount(accountId, instanceNumber);
        let requestId = request.requestId || randomstring.generate(32);
        request.timestamps = {
            clientProcessingStarted: new Date()
        };
        let result = Promise.race([
            new Promise((resolve, reject)=>socketInstance.requestResolves[requestId] = {
                    resolve,
                    reject,
                    type: request.type
                }),
            new Promise((resolve, reject)=>setTimeout(()=>{
                    reject(new TimeoutError(`MetaApi websocket client request ${request.requestId} of type ${request.type} ` + 'timed out. Please make sure your account is connected to broker before retrying your request.'));
                    delete socketInstance.requestResolves[requestId];
                }, timeoutInSeconds * 1000 || this._requestTimeout))
        ]);
        request.accountId = accountId;
        request.application = request.application || this._application;
        if (!request.requestId) {
            request.requestId = requestId;
        }
        if (request.type === 'unsubscribe' || request.application === 'RPC' || request.instanceIndex === socketInstance.instanceNumber) {
            this._logger.debug(()=>`${accountId}: Sending request: ${JSON.stringify(request)}`);
            socketInstance.socket.emit('request', request);
            return result;
        } else {
            this._logger.trace(()=>`${accountId}:${request.instanceIndex}: skipping request because it is being sent to ` + `the socket of the wrong instance index, request=${JSON.stringify(request)}`);
            return result;
        }
    }
    // eslint-disable-next-line complexity
    _convertError(data) {
        if (data.error === 'ValidationError') {
            return new ValidationError(data.message, data.details);
        } else if (data.error === 'NotFoundError') {
            return new NotFoundError(data.message);
        } else if (data.error === 'NotSynchronizedError') {
            return new NotSynchronizedError(data.message);
        } else if (data.error === 'TimeoutError') {
            return new TimeoutError(data.message);
        } else if (data.error === 'NotAuthenticatedError') {
            return new NotConnectedError(data.message);
        } else if (data.error === 'ForbiddenError') {
            return new ForbiddenError(data.message);
        } else if (data.error === 'TradeError') {
            return new TradeError(data.message, data.numericCode, data.stringCode);
        } else if (data.error === 'UnauthorizedError') {
            this.close();
            return new UnauthorizedError(data.message);
        } else if (data.error === 'TooManyRequestsError') {
            return new TooManyRequestsError(data.message, data.metadata);
        } else {
            return new InternalError(data.message);
        }
    }
    // eslint-disable-next-line complexity
    _convertIsoTimeToDate(packet) {
        // eslint-disable-next-line guard-for-in
        for(let field in packet){
            let value = packet[field];
            if (typeof value === 'string' && field.match(/time$|Time$/) && !field.match(/brokerTime$|BrokerTime$|timeframe$/)) {
                packet[field] = new Date(value);
            }
            if (Array.isArray(value)) {
                for (let item of value){
                    this._convertIsoTimeToDate(item);
                }
            }
            if (typeof value === 'object') {
                this._convertIsoTimeToDate(value);
            }
        }
        if (packet && packet.timestamps) {
            // eslint-disable-next-line guard-for-in
            for(let field in packet.timestamps){
                packet.timestamps[field] = new Date(packet.timestamps[field]);
            }
        }
        if (packet && packet.type === 'prices') {
            for (let price of packet.prices || []){
                if (price.timestamps) {
                    // eslint-disable-next-line guard-for-in
                    for(let field in price.timestamps){
                        price.timestamps[field] = new Date(price.timestamps[field]);
                    }
                }
            }
        }
    }
    /**
   * MetaTrader symbol specification. Contains symbol specification (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolSpecification/)
   * @typedef {Object} MetatraderSymbolSpecification
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} tickSize tick size
   * @property {Number} minVolume minimum order volume for the symbol
   * @property {Number} maxVolume maximum order volume for the symbol
   * @property {Number} volumeStep order volume step for the symbol
   * @property {Array<String>} list of allowed order filling modes. Can contain ORDER_FILLING_FOK, ORDER_FILLING_IOC or
   * both. See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_filling_mode for more
   * details.
   * @property {String} deal execution mode. Possible values are SYMBOL_TRADE_EXECUTION_REQUEST,
   * SYMBOL_TRADE_EXECUTION_INSTANT, SYMBOL_TRADE_EXECUTION_MARKET, SYMBOL_TRADE_EXECUTION_EXCHANGE. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_execution for more
   * details.
   * @property {Number} contractSize trade contract size
   * @property {MetatraderSessions} quoteSessions quote sessions, indexed by day of week
   * @property {MetatraderSessions} tradeSessions trade sessions, indexed by day of week
   * @property {String} [tradeMode] order execution type. Possible values are SYMBOL_TRADE_MODE_DISABLED,
   * SYMBOL_TRADE_MODE_LONGONLY, SYMBOL_TRADE_MODE_SHORTONLY, SYMBOL_TRADE_MODE_CLOSEONLY, SYMBOL_TRADE_MODE_FULL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_trade_mode for more
   * details
   * @property {Number} [bondAccruedInterest] accrued interest – accumulated coupon interest, i.e. part of the coupon
   * interest calculated in proportion to the number of days since the coupon bond issuance or the last coupon interest
   * payment
   * @property {Number} [bondFaceValue] face value – initial bond value set by the issuer
   * @property {Number} [optionStrike] the strike price of an option. The price at which an option buyer can buy (in a
   * Call option) or sell (in a Put option) the underlying asset, and the option seller is obliged to sell or buy the
   * appropriate amount of the underlying asset.
   * @property {Number} [optionPriceSensivity] option/warrant sensitivity shows by how many points the price of the
   * option's underlying asset should change so that the price of the option changes by one point
   * @property {Number} [liquidityRate] liquidity Rate is the share of the asset that can be used for the margin
   * @property {Number} initialMargin initial margin means the amount in the margin currency required for opening a
   * position with the volume of one lot. It is used for checking a client's assets when he or she enters the market
   * @property {Number} maintenanceMargin the maintenance margin. If it is set, it sets the margin amount in the margin
   * currency of the symbol, charged from one lot. It is used for checking a client's assets when his/her account state
   * changes. If the maintenance margin is equal to 0, the initial margin is used
   * @property {Number} hedgedMargin contract size or margin value per one lot of hedged positions (oppositely directed
   * positions of one symbol). Two margin calculation methods are possible for hedged positions. The calculation method
   * is defined by the broker
   * @property {Boolean} [hedgedMarginUsesLargerLeg] calculating hedging margin using the larger leg (Buy or Sell)
   * @property {String} marginCurrency margin currency
   * @property {String} priceCalculationMode contract price calculation mode. One of SYMBOL_CALC_MODE_UNKNOWN,
   * SYMBOL_CALC_MODE_FOREX, SYMBOL_CALC_MODE_FOREX_NO_LEVERAGE, SYMBOL_CALC_MODE_FUTURES, SYMBOL_CALC_MODE_CFD,
   * SYMBOL_CALC_MODE_CFDINDEX, SYMBOL_CALC_MODE_CFDLEVERAGE, SYMBOL_CALC_MODE_EXCH_STOCKS,
   * SYMBOL_CALC_MODE_EXCH_FUTURES, SYMBOL_CALC_MODE_EXCH_FUTURES_FORTS, SYMBOL_CALC_MODE_EXCH_BONDS,
   * SYMBOL_CALC_MODE_EXCH_STOCKS_MOEX, SYMBOL_CALC_MODE_EXCH_BONDS_MOEX, SYMBOL_CALC_MODE_SERV_COLLATERAL. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_calc_mode for more details
   * @property {String} baseCurrency base currency
   * @property {String} [profitCurrency] profit currency
   * @property {String} swapMode swap calculation model. Allowed values are SYMBOL_SWAP_MODE_DISABLED,
   * SYMBOL_SWAP_MODE_POINTS, SYMBOL_SWAP_MODE_CURRENCY_SYMBOL, SYMBOL_SWAP_MODE_CURRENCY_MARGIN,
   * SYMBOL_SWAP_MODE_CURRENCY_DEPOSIT, SYMBOL_SWAP_MODE_INTEREST_CURRENT, SYMBOL_SWAP_MODE_INTEREST_OPEN,
   * SYMBOL_SWAP_MODE_REOPEN_CURRENT, SYMBOL_SWAP_MODE_REOPEN_BID. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_swap_mode for more details
   * @property {Number} [swapLong] long swap value
   * @property {Number} [swapShort] short swap value
   * @property {String} [swapRollover3Days] day of week to charge 3 days swap rollover. Allowed values are SUNDAY,
   * MONDAY, TUESDAY, WEDNESDAY, THURDAY, FRIDAY, SATURDAY, NONE
   * @property {Array<String>} allowedExpirationModes allowed order expiration modes. Allowed values are
   * SYMBOL_EXPIRATION_GTC, SYMBOL_EXPIRATION_DAY, SYMBOL_EXPIRATION_SPECIFIED, SYMBOL_EXPIRATION_SPECIFIED_DAY.
   * See https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_expiration_mode for more
   * details
   * @property {Array<String>} allowedOrderTypes allowed order types. Allowed values are SYMBOL_ORDER_MARKET,
   * SYMBOL_ORDER_LIMIT, SYMBOL_ORDER_STOP, SYMBOL_ORDER_STOP_LIMIT, SYMBOL_ORDER_SL, SYMBOL_ORDER_TP,
   * SYMBOL_ORDER_CLOSEBY. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#symbol_order_mode for more details
   * @property {String} orderGTCMode if the expirationMode property is set to SYMBOL_EXPIRATION_GTC (good till
   * canceled), the expiration of pending orders, as well as of Stop Loss/Take Profit orders should be additionally set
   * using this enumeration. Allowed values are SYMBOL_ORDERS_GTC, SYMBOL_ORDERS_DAILY,
   * SYMBOL_ORDERS_DAILY_EXCLUDING_STOPS. See
   * https://www.mql5.com/en/docs/constants/environment_state/marketinfoconstants#enum_symbol_order_gtc_mode for more
   * details
   * @property {Number} digits digits after a decimal point
   * @property {Number} point point size
   * @property {String} [path] path in the symbol tree
   * @property {String} description symbol description
   * @property {Date} [startTime] date of the symbol trade beginning (usually used for futures)
   * @property {Date} [expirationTime] date of the symbol trade end (usually used for futures)
   * @property {number} [pipSize] size of a pip. Pip size is defined for spot and CFD symbols only
   * @property {number} stopsLevel minimal distance from the current market price to stop price (SL, TP, open price) in
   * points. The SL, TP, open price can not be placed closer to market price than this distance
   * @property {number} freezeLevel distance in points from market price to pending order open price to freeze updates
   * on the pending order. If the distance between order open price and current market price is less than this value,
   * then you are not allowed to modify the pending order
   */ /**
   * Metatrader trade or quote session container, indexed by weekday
   * @typedef {Object} MetatraderSessions
   * @property {Array<MetatraderSession>} [SUNDAY] array of sessions for SUNDAY
   * @property {Array<MetatraderSession>} [MONDAY] array of sessions for MONDAY
   * @property {Array<MetatraderSession>} [TUESDAY] array of sessions for TUESDAY
   * @property {Array<MetatraderSession>} [WEDNESDAY] array of sessions for WEDNESDAY
   * @property {Array<MetatraderSession>} [THURSDAY] array of sessions for THURSDAY
   * @property {Array<MetatraderSession>} [FRIDAY] array of sessions for FRIDAY
   * @property {Array<MetatraderSession>} [SATURDAY] array of sessions for SATURDAY
   */ /**
   * Metatrader trade or quote session
   * @typedef {Object} MetatraderSession
   * @property {String} from session start time, in hh.mm.ss.SSS format
   * @property {String} to session end time, in hh.mm.ss.SSS format
   */ /**
   * MetaTrader symbol price. Contains current price for a symbol (see
   * https://metaapi.cloud/docs/client/models/metatraderSymbolPrice/)
   * @typedef {Object} MetatraderSymbolPrice
   * @property {String} symbol symbol (e.g. a currency pair or an index)
   * @property {Number} bid bid price
   * @property {Number} ask ask price
   * @property {Number} profitTickValue tick value for a profitable position
   * @property {Number} lossTickValue tick value for a losing position
   * @property {Number} [accountCurrencyExchangeRate] current exchange rate of account currency into account base
   * currency (USD if you did not override it)
   * @property {Date} time quote time, in ISO format
   * @property {String} brokerTime time quote time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */ /**
   * MetaTrader candle
   * @typedef {Object} MetatraderCandle
   * @property {string} symbol symbol (e.g. currency pair or an index)
   * @property {string} timeframe timeframe candle was generated for, e.g. 1h. One of 1m, 2m, 3m, 4m, 5m, 6m, 10m, 12m,
   * 15m, 20m, 30m, 1h, 2h, 3h, 4h, 6h, 8h, 12h, 1d, 1w, 1mn
   * @property {Date} time candle opening time
   * @property {string} brokerTime candle opening time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} open open price
   * @property {number} high high price
   * @property {number} low low price
   * @property {number} close close price
   * @property {number} tickVolume tick volume, i.e. number of ticks inside the candle
   * @property {number} spread spread in points
   * @property {number} volume trade volume
   */ /**
   * MetaTrader tick data
   * @typedef {Object} MetatraderTick
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {number} [bid] bid price
   * @property {number} [ask] ask price
   * @property {number} [last] last deal price
   * @property {number} [volume] volume for the current last deal price
   * @property {string} side is tick a result of buy or sell deal, one of buy or sell
   */ /**
   * MetaTrader order book
   * @typedef {Object} MetatraderBook
   * @property {string} symbol symbol (e.g. a currency pair or an index)
   * @property {Date} time time
   * @property {string} brokerTime time, in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   * @property {Array<MetatraderBookEntry>} book list of order book entries
   */ /**
   * MetaTrader order book entry
   * @typedef {Object} MetatraderBookEntry
   * @property {string} type entry type, one of BOOK_TYPE_SELL, BOOK_TYPE_BUY, BOOK_TYPE_SELL_MARKET,
   * BOOK_TYPE_BUY_MARKET
   * @property {number} price price
   * @property {number} volume volume
   */ // eslint-disable-next-line complexity,max-statements
    _processSynchronizationPacket(data) {
        var _this = this;
        return _async_to_generator(function*() {
            try {
                const instanceNumber = data.instanceIndex || 0;
                const socketInstance = _this._getSocketInstanceByAccount(data.accountId, instanceNumber);
                if (data.synchronizationId && socketInstance) {
                    socketInstance.synchronizationThrottler.updateSynchronizationId(data.synchronizationId);
                }
                const region = _this.getAccountRegion(data.accountId);
                const primaryAccountId = _this._accountsByReplicaId[data.accountId];
                let instanceId = primaryAccountId + ':' + region + ':' + instanceNumber + ':' + (data.host || 0);
                let instanceIndex = region + ':' + instanceNumber + ':' + (data.host || 0);
                const isOnlyActiveInstance = ()=>{
                    const activeInstanceIds = Object.keys(_this._connectedHosts).filter((instance)=>instance.startsWith(primaryAccountId + ':' + region + ':' + instanceNumber));
                    return !activeInstanceIds.length || activeInstanceIds.length === 1 && activeInstanceIds[0] === instanceId;
                };
                const cancelDisconnectTimer = ()=>{
                    if (_this._statusTimers[instanceId]) {
                        clearTimeout(_this._statusTimers[instanceId]);
                    }
                };
                const resetDisconnectTimer = ()=>{
                    cancelDisconnectTimer();
                    _this._statusTimers[instanceId] = setTimeout(()=>{
                        _this._logger.warn(`${data.accountId}:${instanceIndex}: timed out waiting for connection status`);
                        if (isOnlyActiveInstance()) {
                            _this._subscriptionManager.onTimeout(data.accountId, 0);
                            _this._subscriptionManager.onTimeout(data.accountId, 1);
                        }
                        _this.queueEvent(primaryAccountId, `${instanceIndex}:onDisconnected`, ()=>onDisconnected(true));
                        clearTimeout(_this._statusTimers[instanceId]);
                    }, 60000);
                };
                // eslint-disable-next-line complexity
                const onDisconnected = function() {
                    var _ref = _async_to_generator(function*(isTimeout = false) {
                        if (_this._connectedHosts[instanceId]) {
                            _this._latencyService.onDisconnected(instanceId);
                            if (isOnlyActiveInstance()) {
                                for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                                    yield _this._processEvent(()=>listener.onDisconnected(instanceIndex), `${primaryAccountId}:${instanceIndex}:onDisconnected`);
                                }
                            }
                            _this._packetOrderer.onStreamClosed(instanceId);
                            if (socketInstance) {
                                socketInstance.synchronizationThrottler.removeIdByParameters(data.accountId, instanceNumber, data.host);
                            }
                            for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                                yield _this._processEvent(()=>listener.onStreamClosed(instanceIndex), `${primaryAccountId}:${instanceIndex}:onStreamClosed`);
                            }
                            delete _this._connectedHosts[instanceId];
                            if (isOnlyActiveInstance() && !isTimeout) {
                                yield _this._subscriptionManager.onDisconnected(data.accountId, 0);
                                yield _this._subscriptionManager.onDisconnected(data.accountId, 1);
                            }
                        }
                    });
                    return function onDisconnected() {
                        return _ref.apply(this, arguments);
                    };
                }();
                if (data.type === 'authenticated') {
                    resetDisconnectTimer();
                    if (!data.sessionId || socketInstance && data.sessionId === socketInstance.sessionId) {
                        _this._latencyService.onConnected(instanceId);
                        _this._connectedHosts[instanceId] = data.host;
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onConnected(instanceIndex, data.replicas), `${primaryAccountId}:${instanceIndex}:onConnected`);
                        }
                        _this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
                        if (data.replicas === 1) {
                            _this._subscriptionManager.cancelAccount(data.accountId);
                        } else {
                            _this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
                        }
                    }
                } else if (data.type === 'disconnected') {
                    cancelDisconnectTimer();
                    yield onDisconnected();
                } else if (data.type === 'synchronizationStarted') {
                    _this._updateEvents[instanceId] = [];
                    _this._synchronizationFlags[data.synchronizationId] = {
                        accountId: data.accountId,
                        instanceNumber,
                        specificationsUpdated: data.specificationsHashIndex === undefined,
                        positionsUpdated: data.positionsHashIndex === undefined,
                        ordersUpdated: data.ordersHashIndex === undefined
                    };
                    _this._synchronizationIdByInstance[instanceId] = data.synchronizationId;
                    const specificationsHash = data.specificationsHashIndex !== undefined ? _this._synchronizationHashes[data.synchronizationId] && _this._synchronizationHashes[data.synchronizationId].specificationsHashes[data.specificationsHashIndex] : undefined;
                    const positionsHash = data.positionsHashIndex !== undefined ? _this._synchronizationHashes[data.synchronizationId] && _this._synchronizationHashes[data.synchronizationId].positionsHashes[data.positionsHashIndex] : undefined;
                    const ordersHash = data.ordersHashIndex !== undefined ? _this._synchronizationHashes[data.synchronizationId] && _this._synchronizationHashes[data.synchronizationId].ordersHashes[data.ordersHashIndex] : undefined;
                    delete _this._synchronizationHashes[data.synchronizationId];
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onSynchronizationStarted`);
                    }
                } else if (data.type === 'accountInformation') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    if (data.accountInformation) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            try {
                                yield _this._processEvent(()=>listener.onAccountInformationUpdated(instanceIndex, data.accountInformation), `${primaryAccountId}:${instanceIndex}:onAccountInformationUpdated`, true);
                                // eslint-disable-next-line max-depth
                                if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].positionsUpdated) {
                                    yield _this._processEvent(()=>listener.onPositionsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPositionsSynchronized`, true);
                                    // eslint-disable-next-line max-depth
                                    if (!_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                                        yield _this._processEvent(()=>listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
                                    }
                                }
                            } catch (err) {
                                _this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about accountInformation event', err);
                            }
                        }
                        if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].positionsUpdated && !_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                            delete _this._synchronizationFlags[data.synchronizationId];
                        }
                    }
                } else if (data.type === 'deals') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let deal of data.deals || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onDealAdded(instanceIndex, deal), `${primaryAccountId}:${instanceIndex}:onDealAdded`);
                        }
                    }
                } else if (data.type === 'orders') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        try {
                            yield _this._processEvent(()=>listener.onPendingOrdersReplaced(instanceIndex, data.orders || []), `${primaryAccountId}:${instanceIndex}:onPendingOrdersReplaced`, true);
                            yield _this._processEvent(()=>listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
                        } catch (err) {
                            _this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about orders event', err);
                        }
                    }
                    if (_this._synchronizationFlags[data.synchronizationId]) {
                        delete _this._synchronizationFlags[data.synchronizationId];
                    }
                } else if (data.type === 'historyOrders') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let historyOrder of data.historyOrders || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onHistoryOrderAdded(instanceIndex, historyOrder), `${primaryAccountId}:${instanceIndex}:onHistoryOrderAdded`);
                        }
                    }
                } else if (data.type === 'positions') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        try {
                            yield _this._processEvent(()=>listener.onPositionsReplaced(instanceIndex, data.positions || []), `${primaryAccountId}:${instanceIndex}:onPositionsReplaced`, true);
                            yield _this._processEvent(()=>listener.onPositionsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPositionsSynchronized`, true);
                            if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                                yield _this._processEvent(()=>listener.onPendingOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onPendingOrdersSynchronized`, true);
                            }
                        } catch (err) {
                            _this._logger.error(`${primaryAccountId}:${instanceIndex}: Failed to notify listener ` + 'about positions event', err);
                        }
                    }
                    if (_this._synchronizationFlags[data.synchronizationId] && !_this._synchronizationFlags[data.synchronizationId].ordersUpdated) {
                        delete _this._synchronizationFlags[data.synchronizationId];
                    }
                } else if (data.type === 'update') {
                    if (_this._updateEvents[instanceId]) {
                        _this._updateEvents[instanceId].push(data);
                    }
                    if (data.accountInformation) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onAccountInformationUpdated(instanceIndex, data.accountInformation), `${primaryAccountId}:${instanceIndex}:onAccountInformationUpdated`);
                        }
                    }
                    const updatedPositions = data.updatedPositions || [];
                    const removedPositionIds = data.removedPositionIds || [];
                    if (updatedPositions.length || removedPositionIds.length) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPositionsUpdated(instanceIndex, updatedPositions, removedPositionIds), `${primaryAccountId}:${instanceIndex}:onPositionsUpdated`);
                        }
                    }
                    for (let position of updatedPositions){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPositionUpdated(instanceIndex, position), `${primaryAccountId}:${instanceIndex}:onPositionUpdated`);
                        }
                    }
                    for (let positionId of removedPositionIds){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPositionRemoved(instanceIndex, positionId), `${primaryAccountId}:${instanceIndex}:onPositionRemoved`);
                        }
                    }
                    const updatedOrders = data.updatedOrders || [];
                    const completedOrderIds = data.completedOrderIds || [];
                    if (updatedOrders.length || completedOrderIds.length) {
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPendingOrdersUpdated(instanceIndex, updatedOrders, completedOrderIds), `${primaryAccountId}:${instanceIndex}:onPendingOrdersUpdated`);
                        }
                    }
                    for (let order of updatedOrders){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPendingOrderUpdated(instanceIndex, order), `${primaryAccountId}:${instanceIndex}:onPendingOrderUpdated`);
                        }
                    }
                    for (let orderId of completedOrderIds){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onPendingOrderCompleted(instanceIndex, orderId), `${primaryAccountId}:${instanceIndex}:onPendingOrderCompleted`);
                        }
                    }
                    for (let historyOrder of data.historyOrders || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onHistoryOrderAdded(instanceIndex, historyOrder), `${primaryAccountId}:${instanceIndex}:onHistoryOrderAdded`);
                        }
                    }
                    for (let deal of data.deals || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onDealAdded(instanceIndex, deal), `${primaryAccountId}:${instanceIndex}:onDealAdded`);
                        }
                    }
                    if (data.timestamps) {
                        data.timestamps.clientProcessingFinished = new Date();
                        // eslint-disable-next-line max-depth
                        for (let listener of _this._latencyListeners || []){
                            yield _this._processEvent(()=>listener.onUpdate(data.accountId, data.timestamps), `${primaryAccountId}:${instanceIndex}:onUpdate`);
                        }
                    }
                } else if (data.type === 'dealSynchronizationFinished') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        delete _this._synchronizationIdByInstance[instanceId];
                        return;
                    }
                    _this._latencyService.onDealsSynchronized(instanceId);
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        if (socketInstance) {
                            socketInstance.synchronizationThrottler.removeSynchronizationId(data.synchronizationId);
                        }
                        yield _this._processEvent(()=>listener.onDealsSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onDealsSynchronized`);
                    }
                    if (_this._updateEvents[instanceId]) {
                        _this._updateEvents[instanceId] = _this._updateEvents[instanceId].map((packet)=>()=>Promise.resolve(_this._processSynchronizationPacket(packet)));
                        if (_this._eventQueues[primaryAccountId]) {
                            _this._eventQueues[primaryAccountId] = _this._updateEvents[instanceId].concat(_this._eventQueues[primaryAccountId]);
                            delete _this._updateEvents[instanceId];
                        } else {
                            _this._eventQueues[primaryAccountId] = _this._updateEvents[instanceId];
                            delete _this._updateEvents[instanceId];
                            _this._callAccountEvents(primaryAccountId);
                        }
                    }
                } else if (data.type === 'orderSynchronizationFinished') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onHistoryOrdersSynchronized(instanceIndex, data.synchronizationId), `${primaryAccountId}:${instanceIndex}:onHistoryOrdersSynchronized`);
                    }
                } else if (data.type === 'status') {
                    if (!_this._connectedHosts[instanceId]) {
                        if (_this._statusTimers[instanceId] && data.authenticated && (_this._subscriptionManager.isDisconnectedRetryMode(data.accountId, instanceNumber) || !_this._subscriptionManager.isAccountSubscribing(data.accountId, instanceNumber))) {
                            _this._subscriptionManager.cancelSubscribe(data.accountId + ':' + instanceNumber);
                            yield new Promise((res)=>setTimeout(res, 10));
                            // eslint-disable-next-line no-console
                            _this._logger.info('it seems like we are not connected to a running API ' + 'server yet, retrying subscription for account ' + instanceId);
                            _this.ensureSubscribe(data.accountId, instanceNumber);
                        }
                    } else {
                        resetDisconnectTimer();
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onBrokerConnectionStatusChanged(instanceIndex, !!data.connected), `${primaryAccountId}:${instanceIndex}:onBrokerConnectionStatusChanged`);
                        }
                        if (data.healthStatus) {
                            // eslint-disable-next-line max-depth
                            for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                                yield _this._processEvent(()=>listener.onHealthStatus(instanceIndex, data.healthStatus), `${primaryAccountId}:${instanceIndex}:onHealthStatus`);
                            }
                        }
                    }
                } else if (data.type === 'downgradeSubscription') {
                    _this._logger.info(`${primaryAccountId}:${instanceIndex}: Market data subscriptions for symbol ` + `${data.symbol} were downgraded by the server due to rate limits. Updated subscriptions: ` + `${JSON.stringify(data.updates)}, removed subscriptions: ${JSON.stringify(data.unsubscriptions)}. ` + 'Please read https://metaapi.cloud/docs/client/rateLimiting/ for more details.');
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onSubscriptionDowngraded(instanceIndex, data.symbol, data.updates, data.unsubscriptions), `${primaryAccountId}:${instanceIndex}:onSubscriptionDowngraded`);
                    }
                } else if (data.type === 'specifications') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        yield _this._processEvent(()=>listener.onSymbolSpecificationsUpdated(instanceIndex, data.specifications || [], data.removedSymbols || []), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationsUpdated`);
                    }
                    for (let specification of data.specifications || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onSymbolSpecificationUpdated(instanceIndex, specification), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationUpdated`);
                        }
                    }
                    for (let removedSymbol of data.removedSymbols || []){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onSymbolSpecificationRemoved(instanceIndex, removedSymbol), `${primaryAccountId}:${instanceIndex}:onSymbolSpecificationRemoved`);
                        }
                    }
                } else if (data.type === 'prices') {
                    if (data.synchronizationId && data.synchronizationId !== _this._synchronizationIdByInstance[instanceId]) {
                        return;
                    }
                    let prices = data.prices || [];
                    let candles = data.candles || [];
                    let ticks = data.ticks || [];
                    let books = data.books || [];
                    for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                        if (prices.length) {
                            yield _this._processEvent(()=>listener.onSymbolPricesUpdated(instanceIndex, prices, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onSymbolPricesUpdated`);
                        }
                        if (candles.length) {
                            yield _this._processEvent(()=>listener.onCandlesUpdated(instanceIndex, candles, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onCandlesUpdated`);
                        }
                        if (ticks.length) {
                            yield _this._processEvent(()=>listener.onTicksUpdated(instanceIndex, ticks, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onTicksUpdated`);
                        }
                        if (books.length) {
                            yield _this._processEvent(()=>listener.onBooksUpdated(instanceIndex, books, data.equity, data.margin, data.freeMargin, data.marginLevel, data.accountCurrencyExchangeRate), `${primaryAccountId}:${instanceIndex}:onBooksUpdated`);
                        }
                    }
                    for (let price of prices){
                        for (let listener of _this._synchronizationListeners[primaryAccountId] || []){
                            yield _this._processEvent(()=>listener.onSymbolPriceUpdated(instanceIndex, price), `${primaryAccountId}:${instanceIndex}:onSymbolPriceUpdated`);
                        }
                    }
                    for (let price of prices){
                        if (price.timestamps) {
                            price.timestamps.clientProcessingFinished = new Date();
                            // eslint-disable-next-line max-depth
                            for (let listener of _this._latencyListeners || []){
                                yield _this._processEvent(()=>listener.onSymbolPrice(data.accountId, price.symbol, price.timestamps), `${primaryAccountId}:${instanceIndex}:onSymbolPrice`);
                            }
                        }
                    }
                }
            } catch (err) {
                _this._logger.error('Failed to process incoming synchronization packet', err);
            }
        })();
    }
    _processEvent(callable, label, throwError) {
        var _this = this;
        return _async_to_generator(function*() {
            const startTime = Date.now();
            let isLongEvent = false;
            let isEventDone = false;
            const checkLongEvent = function() {
                var _ref = _async_to_generator(function*() {
                    yield new Promise((res)=>setTimeout(res, 1000));
                    if (!isEventDone) {
                        isLongEvent = true;
                        _this._logger.warn(`${label}: event is taking more than 1 second to process`);
                    }
                });
                return function checkLongEvent() {
                    return _ref.apply(this, arguments);
                };
            }();
            checkLongEvent();
            try {
                yield callable();
            } catch (err) {
                if (throwError) {
                    throw err;
                }
                _this._logger.error(`${label}: event failed with error`, err);
            }
            isEventDone = true;
            if (isLongEvent) {
                _this._logger.warn(`${label}: finished in ${Math.floor((Date.now() - startTime) / 1000)} seconds`);
            }
        })();
    }
    _fireReconnected(instanceNumber, socketInstanceIndex, region) {
        var _this = this;
        return _async_to_generator(function*() {
            try {
                const reconnectListeners = [];
                for (let listener of _this._reconnectListeners){
                    if (_this._socketInstancesByAccounts[instanceNumber][listener.accountId] === socketInstanceIndex && _this.getAccountRegion(listener.accountId) === region) {
                        reconnectListeners.push(listener);
                    }
                }
                Object.keys(_this._synchronizationFlags).forEach((synchronizationId)=>{
                    const accountId = _this._synchronizationFlags[synchronizationId].accountId;
                    if (_this._socketInstancesByAccounts[instanceNumber][accountId] === socketInstanceIndex && _this._synchronizationFlags[synchronizationId].instanceNumber === instanceNumber && _this._regionsByAccounts[accountId] && _this._regionsByAccounts[accountId].region === region) {
                        delete _this._synchronizationFlags[synchronizationId];
                    }
                });
                const reconnectAccountIds = reconnectListeners.map((listener)=>listener.accountId);
                _this._subscriptionManager.onReconnected(instanceNumber, socketInstanceIndex, reconnectAccountIds);
                _this._packetOrderer.onReconnected(reconnectAccountIds);
                for (let listener of reconnectListeners){
                    Promise.resolve(listener.listener.onReconnected(region, instanceNumber)).catch((err)=>_this._logger.error('Failed to notify reconnect listener', err));
                }
            } catch (err) {
                _this._logger.error('Failed to process reconnected event', err);
            }
        })();
    }
    _getSocketInstanceByAccount(accountId, instanceNumber) {
        const region = this.getAccountRegion(accountId);
        return this._socketInstances[region][instanceNumber][this._socketInstancesByAccounts[instanceNumber][accountId]];
    }
    getUrlSettings(instanceNumber, region) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._url) {
                return {
                    url: _this._url,
                    isSharedClientApi: true
                };
            }
            const urlSettings = yield _this._domainClient.getSettings();
            const getUrl = (hostname)=>`https://${hostname}.${region}-${String.fromCharCode(97 + Number(instanceNumber))}.${urlSettings.domain}`;
            let url;
            if (_this._useSharedClientApi) {
                url = getUrl(_this._hostname);
            } else {
                url = getUrl(urlSettings.hostname);
            }
            const isSharedClientApi = url === getUrl(_this._hostname);
            return {
                url,
                isSharedClientApi
            };
        })();
    }
    // eslint-disable-next-line complexity
    _getServerUrl(instanceNumber, socketInstanceIndex, region) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this._url) {
                return _this._url;
            }
            while(_this.socketInstances[region][instanceNumber][socketInstanceIndex].connected){
                try {
                    const urlSettings = yield _this.getUrlSettings(instanceNumber, region);
                    const url = urlSettings.url;
                    const isSharedClientApi = urlSettings.isSharedClientApi;
                    let logMessage = 'Connecting MetaApi websocket client to the MetaApi server ' + `via ${url} ${isSharedClientApi ? 'shared' : 'dedicated'} server.`;
                    if (_this._firstConnect && !isSharedClientApi) {
                        logMessage += ' Please note that it can take up to 3 minutes for your dedicated server to start for the ' + 'first time. During this time it is OK if you see some connection errors.';
                        _this._firstConnect = false;
                    }
                    _this._logger.info(logMessage);
                    return url;
                } catch (err) {
                    _this._logger.error('Failed to retrieve server URL', err);
                    yield new Promise((res)=>setTimeout(res, 1000));
                }
            }
        })();
    }
    _throttleRequest(type, accountId, instanceNumber, timeInMs) {
        this._lastRequestsTime[instanceNumber] = this._lastRequestsTime[instanceNumber] || {};
        this._lastRequestsTime[instanceNumber][type] = this._lastRequestsTime[instanceNumber][type] || {};
        let lastTime = this._lastRequestsTime[instanceNumber][type][accountId];
        if (!lastTime || lastTime < Date.now() - timeInMs) {
            this._lastRequestsTime[instanceNumber][type][accountId] = Date.now();
            return !!lastTime;
        }
        return false;
    }
    _refreshAccountRegion(accountId) {
        if (this._regionsByAccounts[accountId]) {
            this._regionsByAccounts[accountId].lastUsed = Date.now();
        }
    }
    //eslint-disable-next-line complexity
    _createSocketInstanceByAccount(accountId, instanceNumber) {
        var _this = this;
        return _async_to_generator(function*() {
            const region = _this.getAccountRegion(accountId);
            if (_this._socketInstancesByAccounts[instanceNumber][accountId] === undefined) {
                let socketInstanceIndex = null;
                while(_this._subscribeLock && (new Date(_this._subscribeLock.recommendedRetryTime).getTime() > Date.now() && _this.subscribedAccountIds(instanceNumber, undefined, region).length < _this._subscribeLock.lockedAtAccounts || new Date(_this._subscribeLock.lockedAtTime).getTime() + _this._subscribeCooldownInSeconds * 1000 > Date.now() && _this.subscribedAccountIds(instanceNumber, undefined, region).length >= _this._subscribeLock.lockedAtAccounts)){
                    yield new Promise((res)=>setTimeout(res, 1000));
                }
                for(let index = 0; index < _this._socketInstances[region][instanceNumber].length; index++){
                    const accountCounter = _this.getAssignedAccounts(instanceNumber, index, region).length;
                    const instance = _this.socketInstances[region][instanceNumber][index];
                    if (instance.subscribeLock) {
                        if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_USER_PER_SERVER' && (new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() || _this.subscribedAccountIds(instanceNumber, index, region).length >= instance.subscribeLock.lockedAtAccounts)) {
                            continue;
                        }
                        if (instance.subscribeLock.type === 'LIMIT_ACCOUNT_SUBSCRIPTIONS_PER_SERVER' && new Date(instance.subscribeLock.recommendedRetryTime).getTime() > Date.now() && _this.subscribedAccountIds(instanceNumber, index, region).length >= instance.subscribeLock.lockedAtAccounts) {
                            continue;
                        }
                    }
                    if (accountCounter < _this._maxAccountsPerInstance) {
                        socketInstanceIndex = index;
                        break;
                    }
                }
                if (socketInstanceIndex === null) {
                    socketInstanceIndex = _this._socketInstances[region][instanceNumber].length;
                    yield _this.connect(instanceNumber, region);
                }
                _this._socketInstancesByAccounts[instanceNumber][accountId] = socketInstanceIndex;
            }
        })();
    }
    _clearAccountCacheJob() {
        const date = Date.now();
        Object.keys(this._regionsByAccounts).forEach((replicaId)=>{
            const data = this._regionsByAccounts[replicaId];
            if (data && data.connections === 0 && date - data.lastUsed > 2 * 60 * 60 * 1000) {
                const primaryAccountId = this._accountsByReplicaId[replicaId];
                const replicas = Object.values(this._accountReplicas[primaryAccountId] || {});
                replicas.forEach((replica)=>{
                    delete this._accountsByReplicaId[replica];
                    delete this._regionsByAccounts[replica];
                });
                delete this._accountReplicas[primaryAccountId];
                this._logger.debug(`${primaryAccountId}: removed expired account replicas data`);
            }
        });
    }
    _clearInactiveSyncDataJob() {
        const date = Date.now();
        Object.keys(this._synchronizationHashes).keys((synchronizationId)=>{
            if (this._synchronizationHashes[synchronizationId].lastUpdated < date - 30 * 60 * 1000) {
                delete this._synchronizationHashes[synchronizationId];
            }
        });
    }
    /**
   * @typedef MetaApiWebsocketClientOptions MetaApi websocket client options
   * @property {string} [region] region to connect
   * @property {Boolean} [disableInternalJobs] whether to not run internal interval jobs. Used for tests only
   */ /**
   * Constructs MetaApi websocket API client instance
   * @param {MetaApi} metaApi metaApi instance
   * @param {DomainClient} domainClient domain client
   * @param {String} token authorization token
   * @param {MetaApiWebsocketClientOptions} opts websocket client options
   */ // eslint-disable-next-line complexity,max-statements
    constructor(metaApi, domainClient, token, opts){
        const validator = new OptionsValidator();
        opts = opts || {};
        opts.packetOrderingTimeout = validator.validateNonZero(opts.packetOrderingTimeout, 60, 'packetOrderingTimeout');
        opts.synchronizationThrottler = opts.synchronizationThrottler || {};
        this._domainClient = domainClient;
        this._application = opts.application || 'MetaApi';
        this._domain = opts.domain || 'agiliumtrade.agiliumtrade.ai';
        this._region = opts.region;
        this._hostname = 'mt-client-api-v1';
        this._metaApi = metaApi;
        this._url = null;
        this._requestTimeout = validator.validateNonZero(opts.requestTimeout, 60, 'requestTimeout') * 1000;
        this._connectTimeout = validator.validateNonZero(opts.connectTimeout, 60, 'connectTimeout') * 1000;
        const retryOpts = opts.retryOpts || {};
        this._retries = validator.validateNumber(retryOpts.retries, 5, 'retryOpts.retries');
        this._minRetryDelayInSeconds = validator.validateNonZero(retryOpts.minDelayInSeconds, 1, 'retryOpts.minDelayInSeconds');
        this._maxRetryDelayInSeconds = validator.validateNonZero(retryOpts.maxDelayInSeconds, 30, 'retryOpts.maxDelayInSeconds');
        this._maxAccountsPerInstance = 100;
        this._subscribeCooldownInSeconds = validator.validateNonZero(retryOpts.subscribeCooldownInSeconds, 600, 'retryOpts.subscribeCooldownInSeconds');
        this._sequentialEventProcessing = true;
        this._useSharedClientApi = validator.validateBoolean(opts.useSharedClientApi, false, 'useSharedClientApi');
        this._unsubscribeThrottlingInterval = validator.validateNonZero(opts.unsubscribeThrottlingIntervalInSeconds, 10, 'unsubscribeThrottlingIntervalInSeconds') * 1000;
        this._socketMinimumReconnectTimeout = 500;
        this._latencyService = new LatencyService(this, token, this._connectTimeout);
        this._token = token;
        this._synchronizationListeners = {};
        this._latencyListeners = [];
        this._reconnectListeners = [];
        this._connectedHosts = {};
        this._socketInstances = {};
        this._socketInstancesByAccounts = {};
        this._regionsByAccounts = {};
        this._accountsByReplicaId = {};
        this._accountReplicas = {};
        this._synchronizationThrottlerOpts = opts.synchronizationThrottler;
        this._subscriptionManager = new SubscriptionManager(this, metaApi);
        this._statusTimers = {};
        this._eventQueues = {};
        this._synchronizationFlags = {};
        this._synchronizationIdByInstance = {};
        this._subscribeLock = null;
        this._firstConnect = true;
        this._lastRequestsTime = {};
        this._packetOrderer = new PacketOrderer(this, opts.packetOrderingTimeout);
        this._packetOrderer.start();
        this._synchronizationHashes = {};
        this._updateEvents = {};
        if (opts.packetLogger && opts.packetLogger.enabled) {
            this._packetLogger = new PacketLogger(opts.packetLogger);
            this._packetLogger.start();
        }
        this._logger = LoggerManager.getLogger('MetaApiWebsocketClient');
        if (!opts.disableInternalJobs) {
            this._clearAccountCacheInterval = setInterval(this._clearAccountCacheJob.bind(this), 30 * 60 * 1000);
            this._clearInactiveSyncDataJob = setInterval(this._clearInactiveSyncDataJob.bind(this), 5 * 60 * 1000);
        }
    }
};
/**
 * MetaApi websocket API client (see https://metaapi.cloud/docs/client/websocket/overview/)
 */ export { MetaApiWebsocketClient as default };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBzb2NrZXRJTyBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBUaW1lb3V0RXJyb3IgZnJvbSAnLi4vdGltZW91dEVycm9yJztcbmltcG9ydCB7VmFsaWRhdGlvbkVycm9yLCBOb3RGb3VuZEVycm9yLCBJbnRlcm5hbEVycm9yLCBVbmF1dGhvcml6ZWRFcnJvciwgVG9vTWFueVJlcXVlc3RzRXJyb3IsIEZvcmJpZGRlbkVycm9yfVxuICBmcm9tICcuLi9lcnJvckhhbmRsZXInO1xuaW1wb3J0IE9wdGlvbnNWYWxpZGF0b3IgZnJvbSAnLi4vb3B0aW9uc1ZhbGlkYXRvcic7XG5pbXBvcnQgTm90U3luY2hyb25pemVkRXJyb3IgZnJvbSAnLi9ub3RTeW5jaHJvbml6ZWRFcnJvcic7XG5pbXBvcnQgTm90Q29ubmVjdGVkRXJyb3IgZnJvbSAnLi9ub3RDb25uZWN0ZWRFcnJvcic7XG5pbXBvcnQgVHJhZGVFcnJvciBmcm9tICcuL3RyYWRlRXJyb3InO1xuaW1wb3J0IFBhY2tldE9yZGVyZXIgZnJvbSAnLi9wYWNrZXRPcmRlcmVyJztcbmltcG9ydCBTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgZnJvbSAnLi9zeW5jaHJvbml6YXRpb25UaHJvdHRsZXInO1xuaW1wb3J0IFN1YnNjcmlwdGlvbk1hbmFnZXIgZnJvbSAnLi9zdWJzY3JpcHRpb25NYW5hZ2VyJztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgYW55IGZyb20gJ3Byb21pc2UuYW55JztcbmltcG9ydCBMYXRlbmN5U2VydmljZSBmcm9tICcuL2xhdGVuY3lTZXJ2aWNlJztcblxubGV0IFBhY2tldExvZ2dlcjtcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgeyAvLyBkb24ndCBpbXBvcnQgUGFja2V0TG9nZ2VyIGZvciBicm93c2VyIHZlcnNpb25cbiAgUGFja2V0TG9nZ2VyID0gcmVxdWlyZSgnLi9wYWNrZXRMb2dnZXInKS5kZWZhdWx0O1xufVxuXG4vKipcbiAqIE1ldGFBcGkgd2Vic29ja2V0IEFQSSBjbGllbnQgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvd2Vic29ja2V0L292ZXJ2aWV3LylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YUFwaVdlYnNvY2tldENsaWVudCB7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIE1ldGFBcGlXZWJzb2NrZXRDbGllbnRPcHRpb25zIE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBvcHRpb25zXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcmVnaW9uXSByZWdpb24gdG8gY29ubmVjdFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkaXNhYmxlSW50ZXJuYWxKb2JzXSB3aGV0aGVyIHRvIG5vdCBydW4gaW50ZXJuYWwgaW50ZXJ2YWwgam9icy4gVXNlZCBmb3IgdGVzdHMgb25seVxuICAgKi9cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBNZXRhQXBpIHdlYnNvY2tldCBBUEkgY2xpZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TWV0YUFwaX0gbWV0YUFwaSBtZXRhQXBpIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7RG9tYWluQ2xpZW50fSBkb21haW5DbGllbnQgZG9tYWluIGNsaWVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gYXV0aG9yaXphdGlvbiB0b2tlblxuICAgKiBAcGFyYW0ge01ldGFBcGlXZWJzb2NrZXRDbGllbnRPcHRpb25zfSBvcHRzIHdlYnNvY2tldCBjbGllbnQgb3B0aW9uc1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IobWV0YUFwaSwgZG9tYWluQ2xpZW50LCB0b2tlbiwgb3B0cykge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBPcHRpb25zVmFsaWRhdG9yKCk7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cy5wYWNrZXRPcmRlcmluZ1RpbWVvdXQgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMucGFja2V0T3JkZXJpbmdUaW1lb3V0LCA2MCwgJ3BhY2tldE9yZGVyaW5nVGltZW91dCcpO1xuICAgIG9wdHMuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyID0gb3B0cy5zeW5jaHJvbml6YXRpb25UaHJvdHRsZXIgfHwge307XG4gICAgdGhpcy5fZG9tYWluQ2xpZW50ID0gZG9tYWluQ2xpZW50O1xuICAgIHRoaXMuX2FwcGxpY2F0aW9uID0gb3B0cy5hcHBsaWNhdGlvbiB8fCAnTWV0YUFwaSc7XG4gICAgdGhpcy5fZG9tYWluID0gb3B0cy5kb21haW4gfHwgJ2FnaWxpdW10cmFkZS5hZ2lsaXVtdHJhZGUuYWknO1xuICAgIHRoaXMuX3JlZ2lvbiA9IG9wdHMucmVnaW9uO1xuICAgIHRoaXMuX2hvc3RuYW1lID0gJ210LWNsaWVudC1hcGktdjEnO1xuICAgIHRoaXMuX21ldGFBcGkgPSBtZXRhQXBpO1xuICAgIHRoaXMuX3VybCA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdFRpbWVvdXQgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMucmVxdWVzdFRpbWVvdXQsIDYwLCAncmVxdWVzdFRpbWVvdXQnKSAqIDEwMDA7XG4gICAgdGhpcy5fY29ubmVjdFRpbWVvdXQgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMuY29ubmVjdFRpbWVvdXQsIDYwLCAnY29ubmVjdFRpbWVvdXQnKSAqIDEwMDA7XG4gICAgY29uc3QgcmV0cnlPcHRzID0gb3B0cy5yZXRyeU9wdHMgfHwge307XG4gICAgdGhpcy5fcmV0cmllcyA9IHZhbGlkYXRvci52YWxpZGF0ZU51bWJlcihyZXRyeU9wdHMucmV0cmllcywgNSwgJ3JldHJ5T3B0cy5yZXRyaWVzJyk7XG4gICAgdGhpcy5fbWluUmV0cnlEZWxheUluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmV0cnlPcHRzLm1pbkRlbGF5SW5TZWNvbmRzLCAxLFxuICAgICAgJ3JldHJ5T3B0cy5taW5EZWxheUluU2Vjb25kcycpO1xuICAgIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKHJldHJ5T3B0cy5tYXhEZWxheUluU2Vjb25kcywgMzAsXG4gICAgICAncmV0cnlPcHRzLm1heERlbGF5SW5TZWNvbmRzJyk7XG4gICAgdGhpcy5fbWF4QWNjb3VudHNQZXJJbnN0YW5jZSA9IDEwMDtcbiAgICB0aGlzLl9zdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcyA9IHZhbGlkYXRvci52YWxpZGF0ZU5vblplcm8ocmV0cnlPcHRzLnN1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzLCA2MDAsIFxuICAgICAgJ3JldHJ5T3B0cy5zdWJzY3JpYmVDb29sZG93bkluU2Vjb25kcycpO1xuICAgIHRoaXMuX3NlcXVlbnRpYWxFdmVudFByb2Nlc3NpbmcgPSB0cnVlO1xuICAgIHRoaXMuX3VzZVNoYXJlZENsaWVudEFwaSA9IHZhbGlkYXRvci52YWxpZGF0ZUJvb2xlYW4ob3B0cy51c2VTaGFyZWRDbGllbnRBcGksIGZhbHNlLCAndXNlU2hhcmVkQ2xpZW50QXBpJyk7XG4gICAgdGhpcy5fdW5zdWJzY3JpYmVUaHJvdHRsaW5nSW50ZXJ2YWwgPSB2YWxpZGF0b3IudmFsaWRhdGVOb25aZXJvKG9wdHMudW5zdWJzY3JpYmVUaHJvdHRsaW5nSW50ZXJ2YWxJblNlY29uZHMsIDEwLFxuICAgICAgJ3Vuc3Vic2NyaWJlVGhyb3R0bGluZ0ludGVydmFsSW5TZWNvbmRzJykgKiAxMDAwO1xuICAgIHRoaXMuX3NvY2tldE1pbmltdW1SZWNvbm5lY3RUaW1lb3V0ID0gNTAwO1xuICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlID0gbmV3IExhdGVuY3lTZXJ2aWNlKHRoaXMsIHRva2VuLCB0aGlzLl9jb25uZWN0VGltZW91dCk7XG4gICAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fY29ubmVjdGVkSG9zdHMgPSB7fTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXMgPSB7fTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzID0ge307XG4gICAgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHMgPSB7fTtcbiAgICB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkID0ge307XG4gICAgdGhpcy5fYWNjb3VudFJlcGxpY2FzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0cyA9IG9wdHMuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcih0aGlzLCBtZXRhQXBpKTtcbiAgICB0aGlzLl9zdGF0dXNUaW1lcnMgPSB7fTtcbiAgICB0aGlzLl9ldmVudFF1ZXVlcyA9IHt9O1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzID0ge307XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlID0ge307XG4gICAgdGhpcy5fc3Vic2NyaWJlTG9jayA9IG51bGw7XG4gICAgdGhpcy5fZmlyc3RDb25uZWN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lID0ge307XG4gICAgdGhpcy5fcGFja2V0T3JkZXJlciA9IG5ldyBQYWNrZXRPcmRlcmVyKHRoaXMsIG9wdHMucGFja2V0T3JkZXJpbmdUaW1lb3V0KTtcbiAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLnN0YXJ0KCk7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzID0ge307XG4gICAgdGhpcy5fdXBkYXRlRXZlbnRzID0ge307XG4gICAgaWYgKG9wdHMucGFja2V0TG9nZ2VyICYmIG9wdHMucGFja2V0TG9nZ2VyLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3BhY2tldExvZ2dlciA9IG5ldyBQYWNrZXRMb2dnZXIob3B0cy5wYWNrZXRMb2dnZXIpO1xuICAgICAgdGhpcy5fcGFja2V0TG9nZ2VyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlck1hbmFnZXIuZ2V0TG9nZ2VyKCdNZXRhQXBpV2Vic29ja2V0Q2xpZW50Jyk7XG4gICAgaWYgKCFvcHRzLmRpc2FibGVJbnRlcm5hbEpvYnMpIHtcbiAgICAgIHRoaXMuX2NsZWFyQWNjb3VudENhY2hlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLl9jbGVhckFjY291bnRDYWNoZUpvYi5iaW5kKHRoaXMpLCAzMCAqIDYwICogMTAwMCk7XG4gICAgICB0aGlzLl9jbGVhckluYWN0aXZlU3luY0RhdGFKb2IgPSBzZXRJbnRlcnZhbCh0aGlzLl9jbGVhckluYWN0aXZlU3luY0RhdGFKb2IuYmluZCh0aGlzKSwgNSAqIDYwICogMTAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RhcnRzIHRoZSBhY2NvdW50IHN5bmNocm9uaXphdGlvbiBwcm9jZXNzIG9uIGFuIG91dCBvZiBvcmRlciBwYWNrZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZUluZGV4IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBleHBlY3RlZFNlcXVlbmNlTnVtYmVyIGV4cGVjdGVkIHMvblxuICAgKiBAcGFyYW0ge051bWJlcn0gYWN0dWFsU2VxdWVuY2VOdW1iZXIgYWN0dWFsIHMvblxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IHBhY2tldCBkYXRhXG4gICAqIEBwYXJhbSB7RGF0ZX0gcmVjZWl2ZWRBdCB0aW1lIHRoZSBwYWNrZXQgd2FzIHJlY2VpdmVkIGF0XG4gICAqL1xuICBvbk91dE9mT3JkZXJQYWNrZXQoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4LCBleHBlY3RlZFNlcXVlbmNlTnVtYmVyLCBhY3R1YWxTZXF1ZW5jZU51bWJlciwgcGFja2V0LCByZWNlaXZlZEF0KSB7XG4gICAgY29uc3QgcHJpbWFyeUFjY291bnRJZCA9IHRoaXMuX2FjY291bnRzQnlSZXBsaWNhSWRbYWNjb3VudElkXTtcbiAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5pc1N1YnNjcmlwdGlvbkFjdGl2ZShhY2NvdW50SWQpKSB7XG4gICAgICBjb25zdCBsZXZlbCA9IHRoaXMuX2xhdGVuY3lTZXJ2aWNlLmdldFN5bmNocm9uaXplZEFjY291bnRJbnN0YW5jZXMocHJpbWFyeUFjY291bnRJZCkubGVuZ3RoID8gJ2RlYnVnJyA6ICdlcnJvcic7XG4gICAgICB0aGlzLl9sb2dnZXJbbGV2ZWxdKCdNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgcmVjZWl2ZWQgYW4gb3V0IG9mIG9yZGVyICcgK1xuICAgICAgICBgcGFja2V0IHR5cGUgJHtwYWNrZXQudHlwZX0gZm9yIGFjY291bnQgaWQgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH0uIEV4cGVjdGVkIHMvbiBgICtcbiAgICAgICAgYCR7ZXhwZWN0ZWRTZXF1ZW5jZU51bWJlcn0gZG9lcyBub3QgbWF0Y2ggdGhlIGFjdHVhbCBvZiAke2FjdHVhbFNlcXVlbmNlTnVtYmVyfWApO1xuICAgICAgdGhpcy5lbnN1cmVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGF0Y2ggc2VydmVyIFVSTCBmb3IgdXNlIGluIHVuaXQgdGVzdHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBwYXRjaGVkIHNlcnZlciBVUkxcbiAgICovXG4gIHNldCB1cmwodXJsKSB7XG4gICAgdGhpcy5fdXJsID0gdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlYnNvY2tldCBjbGllbnQgcHJlZGVmaW5lZCByZWdpb25cbiAgICogQHJldHVybnMge1N0cmluZ30gcHJlZGVmaW5lZCByZWdpb25cbiAgICovXG4gIGdldCByZWdpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZ2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHNvY2tldCBpbnN0YW5jZSBkaWN0aW9uYXJpZXNcbiAgICogQHJldHVybiB7T2JqZWN0W119IGxpc3Qgb2Ygc29ja2V0IGluc3RhbmNlIGRpY3Rpb25hcmllc1xuICAgKi9cbiAgZ2V0IHNvY2tldEluc3RhbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc29ja2V0SW5zdGFuY2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpY3Rpb25hcnkgb2Ygc29ja2V0IGluc3RhbmNlcyBieSBhY2NvdW50IGlkc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRpY3Rpb25hcnkgb2Ygc29ja2V0IGluc3RhbmNlcyBieSBhY2NvdW50IGlkc1xuICAgKi9cbiAgZ2V0IHNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGljdGlvbmFyeSBvZiBhY2NvdW50IHJlcGxpY2FzIGJ5IHJlZ2lvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGRpY3Rpb25hcnkgb2YgYWNjb3VudCByZXBsaWNhcyBieSByZWdpb25cbiAgICovXG4gIGdldCBhY2NvdW50UmVwbGljYXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjY291bnRSZXBsaWNhcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaWN0aW9uYXJ5IG9mIHByaW1hcnkgYWNjb3VudCBpZHMgYnkgcmVwbGljYSBpZHNcbiAgICogQHJldHVybiB7T2JqZWN0fSBkaWN0aW9uYXJ5IG9mIHByaW1hcnkgYWNjb3VudCBpZHMgYnkgcmVwbGljYSBpZHNcbiAgICovXG4gIGdldCBhY2NvdW50c0J5UmVwbGljYUlkKCkge1xuICAgIHJldHVybiB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY2xlYXIgYWNjb3VudCBjYWNoZSBqb2IuIFVzZWQgZm9yIHRlc3RzXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBjbGVhciBhY2NvdW50IGNhY2hlIGpvYlxuICAgKi9cbiAgZ2V0IGNsZWFyQWNjb3VudENhY2hlSm9iKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGVhckFjY291bnRDYWNoZUpvYi5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbGF0ZW5jeSBzZXJ2aWNlXG4gICAqIEByZXR1cm5zIHtMYXRlbmN5U2VydmljZX0gbGF0ZW5jeSBzZXJ2aWNlXG4gICAqL1xuICBnZXQgbGF0ZW5jeVNlcnZpY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhdGVuY3lTZXJ2aWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2Ygc3Vic2NyaWJlZCBhY2NvdW50IGlkc1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzb2NrZXRJbnN0YW5jZUluZGV4IHNvY2tldCBpbnN0YW5jZSBpbmRleFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnaW9uIHNlcnZlciByZWdpb25cbiAgICogQHJldHVybiB7c3RyaW5nW119IGxpc3Qgb2Ygc3Vic2NyaWJlZCBhY2NvdW50IGlkc1xuICAgKi9cbiAgc3Vic2NyaWJlZEFjY291bnRJZHMoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIGNvbnN0IGNvbm5lY3RlZElkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXSkge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fY29ubmVjdGVkSG9zdHMpLmZvckVhY2goaW5zdGFuY2VJZCA9PiB7XG4gICAgICAgIGNvbnN0IGFjY291bnRJZCA9IGluc3RhbmNlSWQuc3BsaXQoJzonKVswXTtcbiAgICAgICAgY29uc3QgYWNjb3VudFJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgICAgICBpZiAoIWNvbm5lY3RlZElkcy5pbmNsdWRlcyhhY2NvdW50SWQpICYmIFxuICAgICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdICE9PSB1bmRlZmluZWQgJiYgKFxuICAgICAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gPT09IHNvY2tldEluc3RhbmNlSW5kZXggfHwgXG4gICAgICAgIHNvY2tldEluc3RhbmNlSW5kZXggPT09IHVuZGVmaW5lZCkgJiYgYWNjb3VudFJlZ2lvbiA9PT0gcmVnaW9uKSB7XG4gICAgICAgICAgY29ubmVjdGVkSWRzLnB1c2goYWNjb3VudElkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb25uZWN0ZWRJZHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3ZWJzb2NrZXQgY2xpZW50IGNvbm5lY3Rpb24gc3RhdHVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNvY2tldEluc3RhbmNlSW5kZXggc29ja2V0IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWdpb24gc2VydmVyIHJlZ2lvblxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gd2Vic29ja2V0IGNsaWVudCBjb25uZWN0aW9uIHN0YXR1c1xuICAgKi9cbiAgY29ubmVjdGVkKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pIHtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dICYmIFxuICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdLmxlbmd0aCA+IHNvY2tldEluc3RhbmNlSW5kZXggPyBcbiAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtzb2NrZXRJbnN0YW5jZUluZGV4XSA6IG51bGw7XG4gICAgcmV0dXJuIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5zb2NrZXQgJiYgaW5zdGFuY2Uuc29ja2V0LmNvbm5lY3RlZCkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBsaXN0IG9mIGFjY291bnRzIGFzc2lnbmVkIHRvIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbnN0YW5jZU51bWJlciBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNvY2tldEluc3RhbmNlSW5kZXggc29ja2V0IGluc3RhbmNlIGluZGV4XG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWdpb24gc2VydmVyIHJlZ2lvblxuICAgKiBAcmV0dXJucyBcbiAgICovXG4gIGdldEFzc2lnbmVkQWNjb3VudHMoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIGNvbnN0IGFjY291bnRJZHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgYWNjb3VudFJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihrZXkpO1xuICAgICAgaWYgKGFjY291bnRSZWdpb24gPT09IHJlZ2lvbiAmJlxuICAgICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVtrZXldID09PSBzb2NrZXRJbnN0YW5jZUluZGV4KSB7XG4gICAgICAgIGFjY291bnRJZHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhY2NvdW50SWRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWNjb3VudCByZWdpb24gYnkgaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IGFjY291bnQgcmVnaW9uXG4gICAqL1xuICBnZXRBY2NvdW50UmVnaW9uKGFjY291bnRJZCkge1xuICAgIHJldHVybiB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdICYmIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0ucmVnaW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYWNjb3VudCBjYWNoZSBpbmZvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVwbGljYXMgYWNjb3VudCByZXBsaWNhc1xuICAgKi9cbiAgYWRkQWNjb3VudENhY2hlKGFjY291bnRJZCwgcmVwbGljYXMpIHtcbiAgICB0aGlzLl9hY2NvdW50UmVwbGljYXNbYWNjb3VudElkXSA9IHJlcGxpY2FzO1xuICAgIE9iamVjdC5rZXlzKHJlcGxpY2FzKS5mb3JFYWNoKHJlZ2lvbiA9PiB7XG4gICAgICBjb25zdCByZXBsaWNhSWQgPSByZXBsaWNhc1tyZWdpb25dO1xuICAgICAgaWYgKCF0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhSWRdKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW3JlcGxpY2FJZF0gPSB7XG4gICAgICAgICAgcmVnaW9uLFxuICAgICAgICAgIGNvbm5lY3Rpb25zOiAxLFxuICAgICAgICAgIGxhc3RVc2VkOiBEYXRlLm5vdygpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhSWRdLmNvbm5lY3Rpb25zKys7XG4gICAgICB9XG4gICAgICB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW3JlcGxpY2FJZF0gPSBhY2NvdW50SWQ7XG4gICAgfSk7XG4gICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke2FjY291bnRJZH06IGFkZGVkIGFjY291bnQgY2FjaGVgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGFjY291bnQgY2FjaGUgaW5mb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcGxpY2FzIGFjY291bnQgcmVwbGljYXNcbiAgICovXG4gIHVwZGF0ZUFjY291bnRDYWNoZShhY2NvdW50SWQsIHJlcGxpY2FzKSB7XG4gICAgY29uc3Qgb2xkUmVwbGljYXMgPSB0aGlzLl9hY2NvdW50UmVwbGljYXNbYWNjb3VudElkXTtcbiAgICBpZiAob2xkUmVwbGljYXMpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25Db3VudCA9IHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0uY29ubmVjdGlvbnM7XG4gICAgICBPYmplY3Qua2V5cyhvbGRSZXBsaWNhcykuZm9yRWFjaChyZWdpb24gPT4ge1xuICAgICAgICBjb25zdCByZXBsaWNhSWQgPSByZXBsaWNhc1tyZWdpb25dO1xuICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhSWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbcmVwbGljYUlkXTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fYWNjb3VudFJlcGxpY2FzW2FjY291bnRJZF0gPSByZXBsaWNhcztcbiAgICAgIE9iamVjdC5rZXlzKHJlcGxpY2FzKS5mb3JFYWNoKHJlZ2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IHJlcGxpY2FJZCA9IHJlcGxpY2FzW3JlZ2lvbl07XG4gICAgICAgIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW3JlcGxpY2FJZF0gPSB7XG4gICAgICAgICAgcmVnaW9uLFxuICAgICAgICAgIGNvbm5lY3Rpb25zOiBjb25uZWN0aW9uQ291bnQsXG4gICAgICAgICAgbGFzdFVzZWQ6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhSWRdID0gYWNjb3VudElkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfTogdXBkYXRlZCBhY2NvdW50IGNhY2hlYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWNjb3VudCByZWdpb24gaW5mb1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGFjY291bnQgaWRcbiAgICovXG4gIHJlbW92ZUFjY291bnRDYWNoZShhY2NvdW50SWQpIHtcbiAgICBpZiAodGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXSkge1xuICAgICAgaWYgKHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0uY29ubmVjdGlvbnMgPiAwKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0uY29ubmVjdGlvbnMtLTsgXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvY2tzIHN1YnNjcmlwdGlvbiBmb3IgYSBzb2NrZXQgaW5zdGFuY2UgYmFzZWQgb24gVG9vTWFueVJlcXVlc3RzRXJyb3IgbWV0YWRhdGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc29ja2V0SW5zdGFuY2VJbmRleCBzb2NrZXQgaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlZ2lvbiBzZXJ2ZXIgcmVnaW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSBUb29NYW55UmVxdWVzdHNFcnJvciBtZXRhZGF0YVxuICAgKi9cbiAgYXN5bmMgbG9ja1NvY2tldEluc3RhbmNlKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24sIG1ldGFkYXRhKSB7XG4gICAgaWYgKG1ldGFkYXRhLnR5cGUgPT09ICdMSU1JVF9BQ0NPVU5UX1NVQlNDUklQVElPTlNfUEVSX1VTRVInKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVMb2NrID0ge1xuICAgICAgICByZWNvbW1lbmRlZFJldHJ5VGltZTogbWV0YWRhdGEucmVjb21tZW5kZWRSZXRyeVRpbWUsXG4gICAgICAgIGxvY2tlZEF0QWNjb3VudHM6IHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5zdGFuY2VOdW1iZXIsIHVuZGVmaW5lZCwgcmVnaW9uKS5sZW5ndGgsXG4gICAgICAgIGxvY2tlZEF0VGltZTogRGF0ZS5ub3coKVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3Vic2NyaWJlZEFjY291bnRzID0gdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKTtcbiAgICAgIGlmIChzdWJzY3JpYmVkQWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldEluc3RhbmNlID0gdGhpcy5zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl1bc29ja2V0SW5zdGFuY2VJbmRleF07XG4gICAgICAgIHNvY2tldEluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgICAgICBpbnN0YW5jZS5zdWJzY3JpYmVMb2NrID0ge1xuICAgICAgICAgIHJlY29tbWVuZGVkUmV0cnlUaW1lOiBtZXRhZGF0YS5yZWNvbW1lbmRlZFJldHJ5VGltZSxcbiAgICAgICAgICB0eXBlOiBtZXRhZGF0YS50eXBlLFxuICAgICAgICAgIGxvY2tlZEF0QWNjb3VudHM6IHN1YnNjcmliZWRBY2NvdW50cy5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gTWV0YUFwaSBzZXJ2ZXIgdmlhIHNvY2tldC5pbyBwcm90b2NvbFxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWdpb24gc2VydmVyIHJlZ2lvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAgICovXG4gIGFzeW5jIGNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIHJlZ2lvbikge1xuICAgIGlmICh0aGlzLl9yZWdpb24gJiYgcmVnaW9uICE9PSB0aGlzLl9yZWdpb24pIHtcbiAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoYFRyeWluZyB0byBjb25uZWN0IHRvICR7cmVnaW9ufSByZWdpb24sIGJ1dCBjb25maWd1cmVkIHdpdGggJHt0aGlzLl9yZWdpb259YCk7XG4gICAgfVxuICAgIGxldCBjbGllbnRJZCA9IE1hdGgucmFuZG9tKCk7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICB9KTtcbiAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXSB8fD0ge307XG4gICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdIHx8PSBbXTtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdLmxlbmd0aDtcbiAgICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICAgIGlkOiBzb2NrZXRJbnN0YW5jZUluZGV4LFxuICAgICAgcmVjb25uZWN0V2FpdFRpbWU6IHRoaXMuX3NvY2tldE1pbmltdW1SZWNvbm5lY3RUaW1lb3V0LFxuICAgICAgY29ubmVjdGVkOiBmYWxzZSxcbiAgICAgIHJlcXVlc3RSZXNvbHZlczoge30sXG4gICAgICByZXNvbHZlZDogZmFsc2UsXG4gICAgICBjb25uZWN0UmVzdWx0OiByZXN1bHQsXG4gICAgICBzZXNzaW9uSWQ6IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSgzMiksXG4gICAgICBpc1JlY29ubmVjdGluZzogZmFsc2UsXG4gICAgICBzb2NrZXQ6IG51bGwsXG4gICAgICBzeW5jaHJvbml6YXRpb25UaHJvdHRsZXI6IG5ldyBTeW5jaHJvbml6YXRpb25UaHJvdHRsZXIodGhpcywgc29ja2V0SW5zdGFuY2VJbmRleCwgaW5zdGFuY2VOdW1iZXIsIHJlZ2lvbixcbiAgICAgICAgdGhpcy5fc3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0cyksXG4gICAgICBzdWJzY3JpYmVMb2NrOiBudWxsLFxuICAgICAgaW5zdGFuY2VOdW1iZXJcbiAgICB9O1xuICAgIGluc3RhbmNlLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdLnB1c2goaW5zdGFuY2UpO1xuICAgIGluc3RhbmNlLnN5bmNocm9uaXphdGlvblRocm90dGxlci5zdGFydCgpO1xuICAgIGNvbnN0IHNlcnZlclVybCA9IGF3YWl0IHRoaXMuX2dldFNlcnZlclVybChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKTtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHNvY2tldElPKHNlcnZlclVybCwge1xuICAgICAgcGF0aDogJy93cycsXG4gICAgICByZWNvbm5lY3Rpb246IHRydWUsXG4gICAgICByZWNvbm5lY3Rpb25EZWxheTogMTAwMCxcbiAgICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4OiA1MDAwLFxuICAgICAgcmVjb25uZWN0aW9uQXR0ZW1wdHM6IEluZmluaXR5LFxuICAgICAgdGltZW91dDogdGhpcy5fY29ubmVjdFRpbWVvdXQsXG4gICAgICBleHRyYUhlYWRlcnM6IHtcbiAgICAgICAgJ0NsaWVudC1JZCc6IGNsaWVudElkXG4gICAgICB9LFxuICAgICAgcXVlcnk6IHtcbiAgICAgICAgJ2F1dGgtdG9rZW4nOiB0aGlzLl90b2tlbixcbiAgICAgICAgY2xpZW50SWQ6IGNsaWVudElkLFxuICAgICAgICBwcm90b2NvbDogM1xuICAgICAgfVxuICAgIH0pO1xuICAgIGluc3RhbmNlLnNvY2tldCA9IHNvY2tldEluc3RhbmNlO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdjb25uZWN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBjb25uZWN0ZWQgdG8gdGhlIE1ldGFBcGkgc2VydmVyYCk7XG4gICAgICBpbnN0YW5jZS5yZWNvbm5lY3RXYWl0VGltZSA9IHRoaXMuX3NvY2tldE1pbmltdW1SZWNvbm5lY3RUaW1lb3V0O1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGlmICghaW5zdGFuY2UucmVzb2x2ZWQpIHtcbiAgICAgICAgaW5zdGFuY2UucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLl9maXJlUmVjb25uZWN0ZWQoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFpbnN0YW5jZS5jb25uZWN0ZWQpIHtcbiAgICAgICAgaW5zdGFuY2Uuc29ja2V0LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3JlY29ubmVjdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9sb2dnZXIuaW5mbyhgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9OiBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgcmVjb25uZWN0ZWRgKTtcbiAgICAgIGF3YWl0IHRoaXMuX2ZpcmVSZWNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgaW5zdGFuY2UuaWQsIHJlZ2lvbik7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Nvbm5lY3RfZXJyb3InLCBhc3luYyAoZXJyKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBjb25uZWN0aW9uIGVycm9yYCwgZXJyKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdjb25uZWN0X3RpbWVvdXQnLCBhc3luYyAodGltZW91dCkgPT4ge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHtyZWdpb259OiR7aW5zdGFuY2VOdW1iZXJ9OiBNZXRhQXBpIHdlYnNvY2tldCBjbGllbnQgY29ubmVjdGlvbiB0aW1lb3V0YCk7XG4gICAgICBpbnN0YW5jZS5pc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgaWYgKCFpbnN0YW5jZS5yZXNvbHZlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdkaXNjb25uZWN0JywgYXN5bmMgKHJlYXNvbikgPT4ge1xuICAgICAgaW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLm9uRGlzY29ubmVjdCgpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgYCArXG4gICAgICAgIGBNZXRhQXBpIHNlcnZlciBiZWNhdXNlIG9mICR7cmVhc29ufWApO1xuICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgIGF3YWl0IHRoaXMuX3JlY29ubmVjdChpbnN0YW5jZU51bWJlciwgaW5zdGFuY2UuaWQsIHJlZ2lvbik7XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ2Vycm9yJywgYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKGAke3JlZ2lvbn06JHtpbnN0YW5jZU51bWJlcn06IE1ldGFBcGkgd2Vic29ja2V0IGNsaWVudCBlcnJvcmAsIGVycm9yKTtcbiAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICBhd2FpdCB0aGlzLl9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIGluc3RhbmNlLmlkLCByZWdpb24pO1xuICAgIH0pO1xuICAgIHNvY2tldEluc3RhbmNlLm9uKCdyZXNwb25zZScsIGRhdGEgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygoKSA9PiBgJHtkYXRhLmFjY291bnRJZH06IFJlc3BvbnNlIHJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCwgdGltZXN0YW1wczogZGF0YS50aW1lc3RhbXBzfSl9YCk7XG4gICAgICBsZXQgcmVxdWVzdFJlc29sdmUgPSAoaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzW2RhdGEucmVxdWVzdElkXSB8fCB7cmVzb2x2ZTogKCkgPT4ge30sIHJlamVjdDogKCkgPT4ge319KTtcbiAgICAgIGRlbGV0ZSBpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbZGF0YS5yZXF1ZXN0SWRdO1xuICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoZGF0YSk7XG4gICAgICByZXF1ZXN0UmVzb2x2ZS5yZXNvbHZlKGRhdGEpO1xuICAgICAgaWYgKGRhdGEudGltZXN0YW1wcyAmJiByZXF1ZXN0UmVzb2x2ZS50eXBlKSB7XG4gICAgICAgIGRhdGEudGltZXN0YW1wcy5jbGllbnRQcm9jZXNzaW5nRmluaXNoZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzKSB7XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHJlcXVlc3RSZXNvbHZlLnR5cGUgPT09ICd0cmFkZScgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5vblRyYWRlKGRhdGEuYWNjb3VudElkLCBkYXRhLnRpbWVzdGFtcHMpIDpcbiAgICAgICAgICAgICAgbGlzdGVuZXIub25SZXNwb25zZShkYXRhLmFjY291bnRJZCwgcmVxdWVzdFJlc29sdmUudHlwZSwgZGF0YS50aW1lc3RhbXBzKSlcbiAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIG9uUmVzcG9uc2UgZXZlbnQgZm9yIGFjY291bnQgJyArXG4gICAgICAgICAgICAgIGRhdGEuYWNjb3VudElkICsgJywgcmVxdWVzdCB0eXBlICcgKyByZXF1ZXN0UmVzb2x2ZS50eXBlLCBlcnJvcikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3Byb2Nlc3NpbmdFcnJvcicsIGRhdGEgPT4ge1xuICAgICAgbGV0IHJlcXVlc3RSZXNvbHZlID0gKGluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tkYXRhLnJlcXVlc3RJZF0gfHwge3Jlc29sdmU6ICgpID0+IHt9LCByZWplY3Q6ICgpID0+IHt9fSk7XG4gICAgICBkZWxldGUgaW5zdGFuY2UucmVxdWVzdFJlc29sdmVzW2RhdGEucmVxdWVzdElkXTtcbiAgICAgIHJlcXVlc3RSZXNvbHZlLnJlamVjdCh0aGlzLl9jb252ZXJ0RXJyb3IoZGF0YSkpO1xuICAgIH0pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgc29ja2V0SW5zdGFuY2Uub24oJ3N5bmNocm9uaXphdGlvbicsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLmluc3RhbmNlSW5kZXggJiYgZGF0YS5pbnN0YW5jZUluZGV4ICE9PSBpbnN0YW5jZU51bWJlcikge1xuICAgICAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7ZGF0YS5hY2NvdW50SWR9OiR7ZGF0YS5pbnN0YW5jZU51bWJlcn06IHJlY2VpdmVkIHBhY2tldCB3aXRoIHdyb25nIGluc3RhbmNlIGAgK1xuICAgICAgICAgIGBpbmRleCB2aWEgYSBzb2NrZXQgd2l0aCBpbnN0YW5jZSBudW1iZXIgb2YgJHtpbnN0YW5jZU51bWJlcn0sIGRhdGE9JHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsIHNlcXVlbmNlTnVtYmVyOiBkYXRhLnNlcXVlbmNlTnVtYmVyLCBzZXF1ZW5jZVRpbWVzdGFtcDogZGF0YS5zZXF1ZW5jZVRpbWVzdGFtcCxcbiAgICAgICAgICAgIHN5bmNocm9uaXphdGlvbklkOiBkYXRhLnN5bmNocm9uaXphdGlvbklkLCBhcHBsaWNhdGlvbjogZGF0YS5hcHBsaWNhdGlvbiwgaG9zdDogZGF0YS5ob3N0LFxuICAgICAgICAgICAgc3BlY2lmaWNhdGlvbnNVcGRhdGVkOiBkYXRhLnNwZWNpZmljYXRpb25zVXBkYXRlZCwgcG9zaXRpb25zVXBkYXRlZDogZGF0YS5wb3NpdGlvbnNVcGRhdGVkLFxuICAgICAgICAgICAgb3JkZXJzVXBkYXRlZDogZGF0YS5vcmRlcnNVcGRhdGVkLFxuICAgICAgICAgICAgc3BlY2lmaWNhdGlvbnM6IGRhdGEuc3BlY2lmaWNhdGlvbnMgPyAoZGF0YS5zcGVjaWZpY2F0aW9ucyB8fCBbXSkubGVuZ3RoIDogdW5kZWZpbmVkfSl9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbZGF0YS5hY2NvdW50SWRdKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2RhdGEuYWNjb3VudElkXSA9IHtyZWdpb24sIGNvbm5lY3Rpb25zOiAwLCBsYXN0VXNlZDogRGF0ZS5ub3coKX07XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7ZGF0YS5hY2NvdW50SWR9OiR7ZGF0YS5pbnN0YW5jZUluZGV4fTogU3luYyBwYWNrZXQgcmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB0eXBlOiBkYXRhLnR5cGUsIHNlcXVlbmNlTnVtYmVyOiBkYXRhLnNlcXVlbmNlTnVtYmVyLCBzZXF1ZW5jZVRpbWVzdGFtcDogZGF0YS5zZXF1ZW5jZVRpbWVzdGFtcCxcbiAgICAgICAgc3luY2hyb25pemF0aW9uSWQ6IGRhdGEuc3luY2hyb25pemF0aW9uSWQsIGFwcGxpY2F0aW9uOiBkYXRhLmFwcGxpY2F0aW9uLCBob3N0OiBkYXRhLmhvc3QsIFxuICAgICAgICBzcGVjaWZpY2F0aW9uc1VwZGF0ZWQ6IGRhdGEuc3BlY2lmaWNhdGlvbnNVcGRhdGVkLCBwb3NpdGlvbnNVcGRhdGVkOiBkYXRhLnBvc2l0aW9uc1VwZGF0ZWQsXG4gICAgICAgIG9yZGVyc1VwZGF0ZWQ6IGRhdGEub3JkZXJzVXBkYXRlZCwgXG4gICAgICAgIHNwZWNpZmljYXRpb25zOiBkYXRhLnNwZWNpZmljYXRpb25zID8gKGRhdGEuc3BlY2lmaWNhdGlvbnMgfHwgW10pLmxlbmd0aCA6IHVuZGVmaW5lZH0pfSwgYCArXG4gICAgICAgIGBhY3RpdmUgbGlzdGVuZXJzOiAkeyh0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbZGF0YS5hY2NvdW50SWRdIHx8IFtdKS5sZW5ndGh9YCk7XG4gICAgICBsZXQgYWN0aXZlU3luY2hyb25pemF0aW9uSWRzID0gaW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLmFjdGl2ZVN5bmNocm9uaXphdGlvbklkczsgXG4gICAgICBpZiAoIWRhdGEuc3luY2hyb25pemF0aW9uSWQgfHwgYWN0aXZlU3luY2hyb25pemF0aW9uSWRzLmluY2x1ZGVzKGRhdGEuc3luY2hyb25pemF0aW9uSWQpKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWNrZXRMb2dnZXIpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9wYWNrZXRMb2dnZXIubG9nUGFja2V0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlnbm9yZWRQYWNrZXRUeXBlcyA9IFsnZGlzY29ubmVjdGVkJywgJ3N0YXR1cycsICdrZWVwYWxpdmUnXTtcbiAgICAgICAgaWYgKCF0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmlzU3Vic2NyaXB0aW9uQWN0aXZlKGRhdGEuYWNjb3VudElkKSAmJiBcbiAgICAgICAgICAhaWdub3JlZFBhY2tldFR5cGVzLmluY2x1ZGVzKGRhdGEudHlwZSkpIHtcbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7ZGF0YS5hY2NvdW50SWR9OiBQYWNrZXQgYXJyaXZlZCB0byBpbmFjdGl2ZSBjb25uZWN0aW9uLCBhdHRlbXB0aW5nYCArXG4gICAgICAgICAgICBgIHVuc3Vic2NyaWJlLCBwYWNrZXQ6ICR7ZGF0YS50eXBlfWApO1xuICAgICAgICAgIGlmICh0aGlzLl90aHJvdHRsZVJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgZGF0YS5hY2NvdW50SWQsIGRhdGEuaW5zdGFuY2VJbmRleCwgXG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZVRocm90dGxpbmdJbnRlcnZhbCkpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoZGF0YS5hY2NvdW50SWQpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGAke2RhdGEuYWNjb3VudElkfToke2RhdGEuaW5zdGFuY2VJbmRleCB8fCAwfTogZmFpbGVkIHRvIHVuc3Vic2NyaWJlYCwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLnR5cGUgPSAnbm9vcCc7XG4gICAgICB9XG4gICAgICB0aGlzLnF1ZXVlUGFja2V0KGRhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIGNvbm5lY3Rpb24gdG8gTWV0YUFwaSBzZXJ2ZXJcbiAgICovXG4gIGNsb3NlKCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3NvY2tldEluc3RhbmNlcykuZm9yRWFjaChyZWdpb24gPT4ge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl0pLmZvckVhY2goaW5zdGFuY2VOdW1iZXIgPT4ge1xuICAgICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0uZm9yRWFjaChhc3luYyAoaW5zdGFuY2UpID0+IHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgcmVxdWVzdFJlc29sdmUgb2YgT2JqZWN0LnZhbHVlcyhpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXMpKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3RSZXNvbHZlLnJlamVjdChuZXcgRXJyb3IoJ01ldGFBcGkgY29ubmVjdGlvbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXSA9IHt9O1xuICAgICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0gPSBbXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVycyA9IHt9O1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLnN0b3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyB0aGUgY2xpZW50XG4gICAqL1xuICBzdG9wKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2xlYXJBY2NvdW50Q2FjaGVJbnRlcnZhbCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jbGVhckluYWN0aXZlU3luY0RhdGFKb2IpO1xuICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlLnN0b3AoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFjY291bnQgaW5mb3JtYXRpb24gZm9yIGEgc3BlY2lmaWVkIE1ldGFUcmFkZXIgYWNjb3VudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtHZXRBY2NvdW50SW5mb3JtYXRpb25PcHRpb25zfSBbb3B0aW9uc10gYWRkaXRpb25hbCByZXF1ZXN0IG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckFjY291bnRJbmZvcm1hdGlvbj59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9ybWF0aW9uKGFjY291bnRJZCwgb3B0aW9ucykge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRBY2NvdW50SW5mb3JtYXRpb24nLCAuLi5vcHRpb25zfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFjY291bnRJbmZvcm1hdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBvc2l0aW9ucyBmb3IgYSBzcGVjaWZpZWQgTWV0YVRyYWRlciBhY2NvdW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge0dldFBvc2l0aW9uc09wdGlvbnN9IFtvcHRpb25zXSBhZGRpdGlvbmFsIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyUG9zaXRpb24+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGFycmF5IG9mIG9wZW4gcG9zaXRpb25zXG4gICAqL1xuICBhc3luYyBnZXRQb3NpdGlvbnMoYWNjb3VudElkLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFBvc2l0aW9ucycsIC4uLm9wdGlvbnN9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UucG9zaXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3BlY2lmaWMgcG9zaXRpb24gZm9yIGEgTWV0YVRyYWRlciBhY2NvdW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGZvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb25JZCBwb3NpdGlvbiBpZFxuICAgKiBAcGFyYW0ge0dldFBvc2l0aW9uT3B0aW9uc30gW29wdGlvbnNdIGFkZGl0aW9uYWwgcmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWV0YXRyYWRlclBvc2l0aW9uPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBNZXRhVHJhZGVyIHBvc2l0aW9uIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRQb3NpdGlvbihhY2NvdW50SWQsIHBvc2l0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0UG9zaXRpb24nLCBwb3NpdGlvbklkLCAuLi5vcHRpb25zfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnBvc2l0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgb3BlbiBvcmRlcnMgZm9yIGEgc3BlY2lmaWVkIE1ldGFUcmFkZXIgYWNjb3VudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtHZXRPcmRlcnNPcHRpb25zfSBbb3B0aW9uc10gYWRkaXRpb25hbCByZXF1ZXN0IG9wdGlvbnNcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxNZXRhdHJhZGVyT3JkZXI+Pn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBvcGVuIE1ldGFUcmFkZXIgb3JkZXJzXG4gICAqL1xuICBhc3luYyBnZXRPcmRlcnMoYWNjb3VudElkLCBvcHRpb25zKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldE9yZGVycycsIC4uLm9wdGlvbnN9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uub3JkZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgc3BlY2lmaWMgb3BlbiBvcmRlciBmb3IgYSBNZXRhVHJhZGVyIGFjY291bnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkICh0aWNrZXQgbnVtYmVyKVxuICAgKiBAcGFyYW0ge0dldE9yZGVyT3B0aW9uc30gW29wdGlvbnNdIGFkZGl0aW9uYWwgcmVxdWVzdCBvcHRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2U8TWV0YXRyYWRlck9yZGVyPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCBtZXRhdHJhZGVyIG9yZGVyIGZvdW5kXG4gICAqL1xuICBhc3luYyBnZXRPcmRlcihhY2NvdW50SWQsIG9yZGVySWQsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0T3JkZXInLCBvcmRlcklkLCAuLi5vcHRpb25zfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLm9yZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgaGlzdG9yeSBvcmRlcnMgc2VhcmNoIHF1ZXJ5IHJlc3BvbnNlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlck9yZGVyPn0gaGlzdG9yeU9yZGVycyBhcnJheSBvZiBoaXN0b3J5IG9yZGVycyByZXR1cm5lZFxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHN5bmNocm9uaXppbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgaGlzdG9yeSBvcmRlciBpbml0aWFsIHN5bmNocm9uaXphdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuICAgKiBhbmQgdGh1cyBzZWFyY2ggcmVzdWx0cyBtYXkgYmUgaW5jb21wbGV0ZVxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHRpY2tldCBudW1iZXIuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aWNrZXQgdGlja2V0IG51bWJlciAob3JkZXIgaWQpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0KGFjY291bnRJZCwgdGlja2V0KSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEhpc3RvcnlPcmRlcnNCeVRpY2tldCcsIHRpY2tldH0pO1xuICAgIHJldHVybiB7XG4gICAgICBoaXN0b3J5T3JkZXJzOiByZXNwb25zZS5oaXN0b3J5T3JkZXJzLFxuICAgICAgc3luY2hyb25pemluZzogcmVzcG9uc2Uuc3luY2hyb25pemluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlzdG9yeSBvZiBjb21wbGV0ZWQgb3JkZXJzIGZvciBhIHNwZWNpZmljIHBvc2l0aW9uIGlkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbklkIHBvc2l0aW9uIGlkXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJIaXN0b3J5T3JkZXJzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBoaXN0b3J5IG9yZGVycyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0SGlzdG9yeU9yZGVyc0J5UG9zaXRpb24oYWNjb3VudElkLCBwb3NpdGlvbklkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEhpc3RvcnlPcmRlcnNCeVBvc2l0aW9uJyxcbiAgICAgIHBvc2l0aW9uSWR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaGlzdG9yeU9yZGVyczogcmVzcG9uc2UuaGlzdG9yeU9yZGVycyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhpc3Rvcnkgb2YgY29tcGxldGVkIG9yZGVycyBmb3IgYSBzcGVjaWZpYyB0aW1lIHJhbmdlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRUaW1lIHN0YXJ0IG9mIHRpbWUgcmFuZ2UsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0ge0RhdGV9IGVuZFRpbWUgZW5kIG9mIHRpbWUgcmFuZ2UsIGV4Y2x1c2l2ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IHBhZ2luYXRpb24gb2Zmc2V0LCBkZWZhdWx0IGlzIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IHBhZ2luYXRpb24gbGltaXQsIGRlZmF1bHQgaXMgMTAwMFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVySGlzdG9yeU9yZGVycz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgaGlzdG9yeSBvcmRlcnMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZShhY2NvdW50SWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgb2Zmc2V0ID0gMCwgbGltaXQgPSAxMDAwKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZScsXG4gICAgICBzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldCwgbGltaXR9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaGlzdG9yeU9yZGVyczogcmVzcG9uc2UuaGlzdG9yeU9yZGVycyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgaGlzdG9yeSBkZWFscyBzZWFyY2ggcXVlcnkgcmVzcG9uc2VcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckRlYWxzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlckRlYWw+fSBkZWFscyBhcnJheSBvZiBoaXN0b3J5IGRlYWxzIHJldHVybmVkXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc3luY2hyb25pemluZyBmbGFnIGluZGljYXRpbmcgdGhhdCBkZWFsIGluaXRpYWwgc3luY2hyb25pemF0aW9uIGlzIHN0aWxsIGluIHByb2dyZXNzXG4gICAqIGFuZCB0aHVzIHNlYXJjaCByZXN1bHRzIG1heSBiZSBpbmNvbXBsZXRlXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIGRlYWxcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlckRlYWxcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGlkIGRlYWwgaWQgKHRpY2tldCBudW1iZXIpXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIGRlYWwgdHlwZSAob25lIG9mIERFQUxfVFlQRV9CVVksIERFQUxfVFlQRV9TRUxMLCBERUFMX1RZUEVfQkFMQU5DRSwgREVBTF9UWVBFX0NSRURJVCxcbiAgICogREVBTF9UWVBFX0NIQVJHRSwgREVBTF9UWVBFX0NPUlJFQ1RJT04sIERFQUxfVFlQRV9CT05VUywgREVBTF9UWVBFX0NPTU1JU1NJT04sIERFQUxfVFlQRV9DT01NSVNTSU9OX0RBSUxZLFxuICAgKiBERUFMX1RZUEVfQ09NTUlTU0lPTl9NT05USExZLCBERUFMX1RZUEVfQ09NTUlTU0lPTl9BR0VOVF9EQUlMWSwgREVBTF9UWVBFX0NPTU1JU1NJT05fQUdFTlRfTU9OVEhMWSxcbiAgICogREVBTF9UWVBFX0lOVEVSRVNULCBERUFMX1RZUEVfQlVZX0NBTkNFTEVELCBERUFMX1RZUEVfU0VMTF9DQU5DRUxFRCwgREVBTF9ESVZJREVORCwgREVBTF9ESVZJREVORF9GUkFOS0VELFxuICAgKiBERUFMX1RBWCkuIFNlZSBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy90cmFkaW5nY29uc3RhbnRzL2RlYWxwcm9wZXJ0aWVzI2VudW1fZGVhbF90eXBlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBlbnRyeVR5cGUgZGVhbCBlbnRyeSB0eXBlIChvbmUgb2YgREVBTF9FTlRSWV9JTiwgREVBTF9FTlRSWV9PVVQsIERFQUxfRU5UUllfSU5PVVQsXG4gICAqIERFQUxfRU5UUllfT1VUX0JZKS4gU2VlIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL3RyYWRpbmdjb25zdGFudHMvZGVhbHByb3BlcnRpZXMjZW51bV9kZWFsX2VudHJ5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3ltYm9sXSBzeW1ib2wgZGVhbCByZWxhdGVzIHRvXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWFnaWNdIGRlYWwgbWFnaWMgbnVtYmVyLCBpZGVudGlmaWVzIHRoZSBFQSB3aGljaCBpbml0aWF0ZWQgdGhlIGRlYWxcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIHRpbWUgdGhlIGRlYWwgd2FzIGNvbmR1Y3RlZCBhdFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyVGltZSB0aW1lIHRpbWUgdGhlIGRlYWwgd2FzIGNvbmR1Y3RlZCBhdCwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFt2b2x1bWVdIGRlYWwgdm9sdW1lXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcHJpY2VdIHRoZSBwcmljZSB0aGUgZGVhbCB3YXMgY29uZHVjdGVkIGF0XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbY29tbWlzc2lvbl0gZGVhbCBjb21taXNzaW9uXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3dhcF0gZGVhbCBzd2FwXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBwcm9maXQgZGVhbCBwcm9maXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtwb3NpdGlvbklkXSBpZCBvZiBwb3NpdGlvbiB0aGUgZGVhbCByZWxhdGVzIHRvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3JkZXJJZF0gaWQgb2Ygb3JkZXIgdGhlIGRlYWwgcmVsYXRlcyB0b1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbW1lbnRdIGRlYWwgY29tbWVudC4gVGhlIHN1bSBvZiB0aGUgbGluZSBsZW5ndGhzIG9mIHRoZSBjb21tZW50IGFuZCB0aGUgY2xpZW50SWRcbiAgICogbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMjYuIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvY2xpZW50SWRVc2FnZS9cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFticm9rZXJDb21tZW50XSBjdXJyZW50IGNvbW1lbnQgdmFsdWUgb24gYnJva2VyIHNpZGUgKHBvc3NpYmx5IG92ZXJyaWRlbiBieSB0aGUgYnJva2VyKVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NsaWVudElkXSBjbGllbnQtYXNzaWduZWQgaWQuIFRoZSBpZCB2YWx1ZSBjYW4gYmUgYXNzaWduZWQgd2hlbiBzdWJtaXR0aW5nIGEgdHJhZGUgYW5kXG4gICAqIHdpbGwgYmUgcHJlc2VudCBvbiBwb3NpdGlvbiwgaGlzdG9yeSBvcmRlcnMgYW5kIGhpc3RvcnkgZGVhbHMgcmVsYXRlZCB0byB0aGUgdHJhZGUuIFlvdSBjYW4gdXNlIHRoaXMgZmllbGQgdG8gYmluZFxuICAgKiB5b3VyIHRyYWRlcyB0byBvYmplY3RzIGluIHlvdXIgYXBwbGljYXRpb24gYW5kIHRoZW4gdHJhY2sgdHJhZGUgcHJvZ3Jlc3MuIFRoZSBzdW0gb2YgdGhlIGxpbmUgbGVuZ3RocyBvZiB0aGVcbiAgICogY29tbWVudCBhbmQgdGhlIGNsaWVudElkIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIDI2LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L2NsaWVudElkVXNhZ2UvXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwbGF0Zm9ybSBwbGF0Zm9ybSBpZCAobXQ0IG9yIG10NSlcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtyZWFzb25dIG9wdGlvbmFsIGRlYWwgZXhlY3V0aW9uIHJlYXNvbi4gT25lIG9mIERFQUxfUkVBU09OX0NMSUVOVCwgREVBTF9SRUFTT05fTU9CSUxFLFxuICAgKiBERUFMX1JFQVNPTl9XRUIsIERFQUxfUkVBU09OX0VYUEVSVCwgREVBTF9SRUFTT05fU0wsIERFQUxfUkVBU09OX1RQLCBERUFMX1JFQVNPTl9TTywgREVBTF9SRUFTT05fUk9MTE9WRVIsXG4gICAqIERFQUxfUkVBU09OX1ZNQVJHSU4sIERFQUxfUkVBU09OX1NQTElULCBERUFMX1JFQVNPTl9VTktOT1dOLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvdHJhZGluZ2NvbnN0YW50cy9kZWFscHJvcGVydGllcyNlbnVtX2RlYWxfcmVhc29uLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2FjY291bnRDdXJyZW5jeUV4Y2hhbmdlUmF0ZV0gY3VycmVudCBleGNoYW5nZSByYXRlIG9mIGFjY291bnQgY3VycmVuY3kgaW50byBhY2NvdW50IGJhc2VcbiAgICogY3VycmVuY3kgKFVTRCBpZiB5b3UgZGlkIG5vdCBvdmVycmlkZSBpdClcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdG9wTG9zc10gZGVhbCBzdG9wIGxvc3MuIEZvciBNVDUgb3BlbmluZyBkZWFsIHRoaXMgaXMgdGhlIFNMIG9mIHRoZSBvcmRlciBvcGVuaW5nIHRoZSBcbiAgICogcG9zaXRpb24uIEZvciBNVDQgZGVhbHMgb3IgTVQ1IGNsb3NpbmcgZGVhbCB0aGlzIGlzIHRoZSBsYXN0IGtub3duIHBvc2l0aW9uIFNMLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3Rha2VQcm9maXRdIGRlYWwgdGFrZSBwcm9maXQuIEZvciBNVDUgb3BlbmluZyBkZWFsIHRoaXMgaXMgdGhlIFRQIG9mIHRoZSBvcmRlciBvcGVuaW5nIHRoZSBcbiAgICogcG9zaXRpb24uIEZvciBNVDQgZGVhbHMgb3IgTVQ1IGNsb3NpbmcgZGVhbCB0aGlzIGlzIHRoZSBsYXN0IGtub3duIHBvc2l0aW9uIFRQLlxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBoaXN0b3J5IGRlYWxzIHdpdGggYSBzcGVjaWZpYyB0aWNrZXQgbnVtYmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gaW5mb3JtYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aWNrZXQgdGlja2V0IG51bWJlciAoZGVhbCBpZCBmb3IgTVQ1IG9yIG9yZGVyIGlkIGZvciBNVDQpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldERlYWxzQnlUaWNrZXQoYWNjb3VudElkLCB0aWNrZXQpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0RGVhbHNCeVRpY2tldCcsIHRpY2tldH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkZWFsczogcmVzcG9uc2UuZGVhbHMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGhpc3RvcnkgZGVhbHMgZm9yIGEgc3BlY2lmaWMgcG9zaXRpb24gaWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWRcbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlckRlYWxzPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCByZXF1ZXN0IHJlc3VsdHMgY29udGFpbmluZyBkZWFscyBmb3VuZFxuICAgKi9cbiAgYXN5bmMgZ2V0RGVhbHNCeVBvc2l0aW9uKGFjY291bnRJZCwgcG9zaXRpb25JZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXREZWFsc0J5UG9zaXRpb24nLCBwb3NpdGlvbklkfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWxzOiByZXNwb25zZS5kZWFscyxcbiAgICAgIHN5bmNocm9uaXppbmc6IHJlc3BvbnNlLnN5bmNocm9uaXppbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGlzdG9yeSBkZWFscyB3aXRoIGZvciBhIHNwZWNpZmljIHRpbWUgcmFuZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHVybiBpbmZvcm1hdGlvbiBmb3JcbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydFRpbWUgc3RhcnQgb2YgdGltZSByYW5nZSwgaW5jbHVzaXZlXG4gICAqIEBwYXJhbSB7RGF0ZX0gZW5kVGltZSBlbmQgb2YgdGltZSByYW5nZSwgZXhjbHVzaXZlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgcGFnaW5hdGlvbiBvZmZzZXQsIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge051bWJlcn0gbGltaXQgcGFnaW5hdGlvbiBsaW1pdCwgZGVmYXVsdCBpcyAxMDAwXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJEZWFscz59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcmVxdWVzdCByZXN1bHRzIGNvbnRhaW5pbmcgZGVhbHMgZm91bmRcbiAgICovXG4gIGFzeW5jIGdldERlYWxzQnlUaW1lUmFuZ2UoYWNjb3VudElkLCBzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldCA9IDAsIGxpbWl0ID0gMTAwMCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXREZWFsc0J5VGltZVJhbmdlJywgc3RhcnRUaW1lLFxuICAgICAgZW5kVGltZSwgb2Zmc2V0LCBsaW1pdH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkZWFsczogcmVzcG9uc2UuZGVhbHMsXG4gICAgICBzeW5jaHJvbml6aW5nOiByZXNwb25zZS5zeW5jaHJvbml6aW5nXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIG9yZGVyIGFuZCB0cmFuc2FjdGlvbiBoaXN0b3J5IG9mIGEgc3BlY2lmaWVkIGFwcGxpY2F0aW9uIGFuZCByZW1vdmVzIHRoZSBhcHBsaWNhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmVtb3ZlIGhpc3RvcnkgYW5kIGFwcGxpY2F0aW9uIGZvclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHJlc29sdmluZyB3aGVuIHRoZSBoaXN0b3J5IGlzIGNsZWFyZWRcbiAgICovXG4gIHJlbW92ZUFwcGxpY2F0aW9uKGFjY291bnRJZCkge1xuICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3JlbW92ZUFwcGxpY2F0aW9uJ30pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgdHJhZGUgcmVzcG9uc2VcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclRyYWRlUmVzcG9uc2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG51bWVyaWNDb2RlIG51bWVyaWMgcmVzcG9uc2UgY29kZSwgc2VlXG4gICAqIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vycm9yc3dhcm5pbmdzL2VudW1fdHJhZGVfcmV0dXJuX2NvZGVzIGFuZFxuICAgKiBodHRwczovL2Jvb2subXFsNC5jb20vYXBwZW5kaXgvZXJyb3JzLiBSZXNwb25zZSBjb2RlcyB3aGljaCBpbmRpY2F0ZSBzdWNjZXNzIGFyZSAwLCAxMDAwOC0xMDAxMCwgMTAwMjUuIFRoZSByZXN0XG4gICAqIGNvZGVzIGFyZSBlcnJvcnNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHN0cmluZ0NvZGUgc3RyaW5nIHJlc3BvbnNlIGNvZGUsIHNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lcnJvcnN3YXJuaW5ncy9lbnVtX3RyYWRlX3JldHVybl9jb2RlcyBhbmRcbiAgICogaHR0cHM6Ly9ib29rLm1xbDQuY29tL2FwcGVuZGl4L2Vycm9ycy4gUmVzcG9uc2UgY29kZXMgd2hpY2ggaW5kaWNhdGUgc3VjY2VzcyBhcmUgRVJSX05PX0VSUk9SLFxuICAgKiBUUkFERV9SRVRDT0RFX1BMQUNFRCwgVFJBREVfUkVUQ09ERV9ET05FLCBUUkFERV9SRVRDT0RFX0RPTkVfUEFSVElBTCwgVFJBREVfUkVUQ09ERV9OT19DSEFOR0VTLiBUaGUgcmVzdCBjb2RlcyBhcmVcbiAgICogZXJyb3JzLlxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gbWVzc2FnZSBodW1hbi1yZWFkYWJsZSByZXNwb25zZSBtZXNzYWdlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBvcmRlcklkIG9yZGVyIGlkIHdoaWNoIHdhcyBjcmVhdGVkL21vZGlmaWVkIGR1cmluZyB0aGUgdHJhZGVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHBvc2l0aW9uSWQgcG9zaXRpb24gaWQgd2hpY2ggd2FzIG1vZGlmaWVkIGR1cmluZyB0aGUgdHJhZGVcbiAgICovXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSB0cmFkZSBvbiBhIGNvbm5lY3RlZCBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIGV4ZWN1dGUgdHJhZGUgZm9yXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlclRyYWRlfSB0cmFkZSB0cmFkZSB0byBleGVjdXRlIChzZWUgZG9jcyBmb3IgcG9zc2libGUgdHJhZGUgdHlwZXMpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbYXBwbGljYXRpb25dIGFwcGxpY2F0aW9uIHRvIHVzZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlbGlhYmlsaXR5XSBhY2NvdW50IHJlbGlhYmlsaXR5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJUcmFkZVJlc3BvbnNlPn0gcHJvbWlzZSByZXNvbHZpbmcgd2l0aCB0cmFkZSByZXN1bHRcbiAgICogQHRocm93cyB7VHJhZGVFcnJvcn0gb24gdHJhZGUgZXJyb3IsIGNoZWNrIGVycm9yIHByb3BlcnRpZXMgZm9yIGVycm9yIGNvZGUgZGV0YWlsc1xuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgYXN5bmMgdHJhZGUoYWNjb3VudElkLCB0cmFkZSwgYXBwbGljYXRpb24sIHJlbGlhYmlsaXR5KSB7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIGlmIChhcHBsaWNhdGlvbiA9PT0gJ1JQQycpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICd0cmFkZScsIHRyYWRlLCBhcHBsaWNhdGlvbn0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsIHt0eXBlOiAndHJhZGUnLCB0cmFkZSxcbiAgICAgICAgYXBwbGljYXRpb246IGFwcGxpY2F0aW9uIHx8IHRoaXMuX2FwcGxpY2F0aW9uLCByZXF1ZXN0SWQ6IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSgzMil9LCByZWxpYWJpbGl0eSk7XG4gICAgfVxuICAgIHJlc3BvbnNlLnJlc3BvbnNlID0gcmVzcG9uc2UucmVzcG9uc2UgfHwge307XG4gICAgcmVzcG9uc2UucmVzcG9uc2Uuc3RyaW5nQ29kZSA9IHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUgfHwgcmVzcG9uc2UucmVzcG9uc2UuZGVzY3JpcHRpb247XG4gICAgcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgPSByZXNwb25zZS5yZXNwb25zZS5udW1lcmljQ29kZSAhPT0gdW5kZWZpbmVkID8gcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUgOlxuICAgICAgcmVzcG9uc2UucmVzcG9uc2UuZXJyb3I7XG4gICAgaWYgKFsnRVJSX05PX0VSUk9SJywgJ1RSQURFX1JFVENPREVfUExBQ0VEJywgJ1RSQURFX1JFVENPREVfRE9ORScsICdUUkFERV9SRVRDT0RFX0RPTkVfUEFSVElBTCcsXG4gICAgICAnVFJBREVfUkVUQ09ERV9OT19DSEFOR0VTJ10uaW5jbHVkZXMocmVzcG9uc2UucmVzcG9uc2Uuc3RyaW5nQ29kZSB8fCByZXNwb25zZS5yZXNwb25zZS5kZXNjcmlwdGlvbikpIHtcbiAgICAgIHJldHVybiByZXNwb25zZS5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFRyYWRlRXJyb3IocmVzcG9uc2UucmVzcG9uc2UubWVzc2FnZSwgcmVzcG9uc2UucmVzcG9uc2UubnVtZXJpY0NvZGUsIHJlc3BvbnNlLnJlc3BvbnNlLnN0cmluZ0NvZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdGFzayB0aGF0IGVuc3VyZXMgdGhlIGFjY291bnQgZ2V0cyBzdWJzY3JpYmVkIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkIHRvIHN1YnNjcmliZVxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqL1xuICBlbnN1cmVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuc2NoZWR1bGVTdWJzY3JpYmUoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcik7XG4gIH1cblxuICAvKipcbiAgICogU3Vic2NyaWJlcyB0byB0aGUgTWV0YXRyYWRlciB0ZXJtaW5hbCBldmVudHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHN1YnNjcmliZSB0b1xuICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VOdW1iZXIgaW5zdGFuY2UgaW5kZXggbnVtYmVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHN1YnNjcmliZShhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuc3Vic2NyaWJlKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSB0ZXJtaW5hbCB0byBzdGFydCBzeW5jaHJvbml6YXRpb24gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gc3luY2hyb25pemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlSW5kZXggaW5zdGFuY2UgaW5kZXhcbiAgICogQHBhcmFtIHtTdHJpbmd9IGhvc3QgbmFtZSBvZiBob3N0IHRvIHN5bmNocm9uaXplIHdpdGhcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bmNocm9uaXphdGlvbklkIHN5bmNocm9uaXphdGlvbiByZXF1ZXN0IGlkXG4gICAqIEBwYXJhbSB7RGF0ZX0gc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lIGZyb20gd2hhdCBkYXRlIHRvIHN0YXJ0IHN5bmNocm9uaXppbmcgaGlzdG9yeSBvcmRlcnMgZnJvbS4gSWYgbm90IHNwZWNpZmllZCxcbiAgICogdGhlIGVudGlyZSBvcmRlciBoaXN0b3J5IHdpbGwgYmUgZG93bmxvYWRlZC5cbiAgICogQHBhcmFtIHtEYXRlfSBzdGFydGluZ0RlYWxUaW1lIGZyb20gd2hhdCBkYXRlIHRvIHN0YXJ0IGRlYWwgc3luY2hyb25pemF0aW9uIGZyb20uIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gYWxsXG4gICAqIGhpc3RvcnkgZGVhbHMgd2lsbCBiZSBkb3dubG9hZGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRIYXNoZXMgZnVuY3Rpb24gdG8gZ2V0IHRlcm1pbmFsIHN0YXRlIGhhc2hlc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiBzdGFydGVkXG4gICAqL1xuICBhc3luYyBzeW5jaHJvbml6ZShhY2NvdW50SWQsIGluc3RhbmNlSW5kZXgsIGhvc3QsIHN5bmNocm9uaXphdGlvbklkLCBzdGFydGluZ0hpc3RvcnlPcmRlclRpbWUsIHN0YXJ0aW5nRGVhbFRpbWUsICBcbiAgICBoYXNoZXMpIHtcbiAgICBpZiAodGhpcy5fZ2V0U29ja2V0SW5zdGFuY2VCeUFjY291bnQoYWNjb3VudElkLCBpbnN0YW5jZUluZGV4KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBjcmVhdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gc3luY2hyb25pemVgKTtcbiAgICAgIGF3YWl0IHRoaXMuX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IHN5bmNUaHJvdHRsZXIgPSB0aGlzLl9nZXRTb2NrZXRJbnN0YW5jZUJ5QWNjb3VudChhY2NvdW50SWQsIGluc3RhbmNlSW5kZXgpXG4gICAgICAuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tzeW5jaHJvbml6YXRpb25JZF0gPSBoYXNoZXM7XG4gICAgdGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzW3N5bmNocm9uaXphdGlvbklkXS5sYXN0VXBkYXRlZCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHN5bmNUaHJvdHRsZXIuc2NoZWR1bGVTeW5jaHJvbml6ZShhY2NvdW50SWQsIHtyZXF1ZXN0SWQ6IHN5bmNocm9uaXphdGlvbklkLCB2ZXJzaW9uOiAyLFxuICAgICAgdHlwZTogJ3N5bmNocm9uaXplJywgc3RhcnRpbmdIaXN0b3J5T3JkZXJUaW1lLCBzdGFydGluZ0RlYWxUaW1lLCBpbnN0YW5jZUluZGV4LCBob3N0fSwgaGFzaGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0cyBmb3Igc2VydmVyLXNpZGUgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIHRvIGNvbXBsZXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byBzeW5jaHJvbml6ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luc3RhbmNlTnVtYmVyXSBpbnN0YW5jZSBpbmRleCBudW1iZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwcGxpY2F0aW9uUGF0dGVybiBNZXRhQXBpIGFwcGxpY2F0aW9uIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuLCBkZWZhdWx0IGlzIC4qXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0SW5TZWNvbmRzIHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMDAgc2Vjb25kc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2FwcGxpY2F0aW9uXSBhcHBsaWNhdGlvbiB0byBzeW5jaHJvbml6ZSB3aXRoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHN0YXJ0ZWRcbiAgICovXG4gIHdhaXRTeW5jaHJvbml6ZWQoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgYXBwbGljYXRpb25QYXR0ZXJuLCB0aW1lb3V0SW5TZWNvbmRzLCBhcHBsaWNhdGlvbikge1xuICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7dHlwZTogJ3dhaXRTeW5jaHJvbml6ZWQnLCBhcHBsaWNhdGlvblBhdHRlcm4sIHRpbWVvdXRJblNlY29uZHMsXG4gICAgICBpbnN0YW5jZUluZGV4OiBpbnN0YW5jZU51bWJlciwgYXBwbGljYXRpb246IGFwcGxpY2F0aW9uIHx8IHRoaXMuX2FwcGxpY2F0aW9ufSxcbiAgICB0aW1lb3V0SW5TZWNvbmRzICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogTWFya2V0IGRhdGEgc3Vic2NyaXB0aW9uXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmtldERhdGFTdWJzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgc3Vic2NyaXB0aW9uIHR5cGUsIG9uZSBvZiBxdW90ZXMsIGNhbmRsZXMsIHRpY2tzLCBvciBtYXJrZXREZXB0aFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpbWVmcmFtZV0gd2hlbiBzdWJzY3JpcHRpb24gdHlwZSBpcyBjYW5kbGVzLCBkZWZpbmVzIHRoZSB0aW1lZnJhbWUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZVxuICAgKiBjYW5kbGVzIG11c3QgYmUgZ2VuZXJhdGVkLiBBbGxvd2VkIHZhbHVlcyBmb3IgTVQ1IGFyZSAxbSwgMm0sIDNtLCA0bSwgNW0sIDZtLCAxMG0sIDEybSwgMTVtLCAyMG0sIDMwbSwgMWgsIDJoLCAzaCxcbiAgICogNGgsIDZoLCA4aCwgMTJoLCAxZCwgMXcsIDFtbi4gQWxsb3dlZCB2YWx1ZXMgZm9yIE1UNCBhcmUgMW0sIDVtLCAxNW0gMzBtLCAxaCwgNGgsIDFkLCAxdywgMW1uXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaW50ZXJ2YWxJbk1pbGxpc2Vjb25kc10gZGVmaW5lcyBob3cgZnJlcXVlbnRseSB0aGUgdGVybWluYWwgd2lsbCBzdHJlYW0gZGF0YSB0byBjbGllbnQuIElmIG5vdFxuICAgKiBzZXQsIHRoZW4gdGhlIHZhbHVlIGNvbmZpZ3VyZWQgaW4gYWNjb3VudCB3aWxsIGJlIHVzZWRcbiAgICovXG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgb24gbWFya2V0IGRhdGEgb2Ygc3BlY2lmaWVkIHN5bWJvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhU3Vic2NyaXB0aW9uPn0gc3Vic2NyaXB0aW9ucyBhcnJheSBvZiBtYXJrZXQgZGF0YSBzdWJzY3JpcHRpb24gdG8gY3JlYXRlIG9yIHVwZGF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlbGlhYmlsaXR5XSBhY2NvdW50IHJlbGlhYmlsaXR5XG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3Vic2NyaXB0aW9uIHJlcXVlc3Qgd2FzIHByb2Nlc3NlZFxuICAgKi9cbiAgc3Vic2NyaWJlVG9NYXJrZXREYXRhKGFjY291bnRJZCwgc3ltYm9sLCBzdWJzY3JpcHRpb25zLCByZWxpYWJpbGl0eSkge1xuICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3RBbGxJbnN0YW5jZXMoYWNjb3VudElkLFxuICAgICAge3R5cGU6ICdzdWJzY3JpYmVUb01hcmtldERhdGEnLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnN9LCByZWxpYWJpbGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogUmVmcmVzaGVzIG1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgb24gdGhlIHNlcnZlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBleHBpcmluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluc3RhbmNlTnVtYmVyIGluc3RhbmNlIGluZGV4IG51bWJlclxuICAgKiBAcGFyYW0ge0FycmF5fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gcmVmcmVzaFxuICAgKi9cbiAgcmVmcmVzaE1hcmtldERhdGFTdWJzY3JpcHRpb25zKGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHN1YnNjcmlwdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdyZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMnLCBzdWJzY3JpcHRpb25zLFxuICAgICAgaW5zdGFuY2VJbmRleDogaW5zdGFuY2VOdW1iZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXJrZXQgZGF0YSB1bnN1YnNjcmlwdGlvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXJrZXREYXRhVW5zdWJzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgc3Vic2NyaXB0aW9uIHR5cGUsIG9uZSBvZiBxdW90ZXMsIGNhbmRsZXMsIHRpY2tzLCBvciBtYXJrZXREZXB0aFxuICAgKi9cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGZyb20gbWFya2V0IGRhdGEgb2Ygc3BlY2lmaWVkIHN5bWJvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHBhcmFtIHtBcnJheTxNYXJrZXREYXRhVW5zdWJzY3JpcHRpb24+fSBzdWJzY3JpcHRpb25zIGFycmF5IG9mIHN1YnNjcmlwdGlvbnMgdG8gY2FuY2VsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcmVsaWFiaWxpdHldIGFjY291bnQgcmVsaWFiaWxpdHlcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1bnN1YnNjcmlwdGlvbiByZXF1ZXN0IHdhcyBwcm9jZXNzZWRcbiAgICovXG4gIHVuc3Vic2NyaWJlRnJvbU1hcmtldERhdGEoYWNjb3VudElkLCBzeW1ib2wsIHN1YnNjcmlwdGlvbnMsIHJlbGlhYmlsaXR5KSB7XG4gICAgcmV0dXJuIHRoaXMucnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsIHt0eXBlOiAndW5zdWJzY3JpYmVGcm9tTWFya2V0RGF0YScsIHN5bWJvbCwgc3Vic2NyaXB0aW9uc30sXG4gICAgICByZWxpYWJpbGl0eSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHN5bWJvbHMgYXZhaWxhYmxlIG9uIGFuIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIHN5bWJvbHMgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gc3ltYm9scyBhcmUgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRTeW1ib2xzKGFjY291bnRJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTeW1ib2xzJ30pO1xuICAgIHJldHVybiByZXNwb25zZS5zeW1ib2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBzcGVjaWZpY2F0aW9uIGZvciBhIHN5bWJvbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHNwZWNpZmljYXRpb24gZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHNwZWNpZmljYXRpb24gZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNwZWNpZmljYXRpb24gaXMgcmV0cmlldmVkXG4gICAqL1xuICBhc3luYyBnZXRTeW1ib2xTcGVjaWZpY2F0aW9uKGFjY291bnRJZCwgc3ltYm9sKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldFN5bWJvbFNwZWNpZmljYXRpb24nLCBzeW1ib2x9KTtcbiAgICByZXR1cm4gcmVzcG9uc2Uuc3BlY2lmaWNhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgcHJpY2UgZm9yIGEgc3ltYm9sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgcHJpY2UgZm9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHByaWNlIGZvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdWJzY3JpcHRpb24gaWYgc2V0IHRvIHRydWUsIHRoZSBhY2NvdW50IHdpbGwgZ2V0IGEgbG9uZy10ZXJtIHN1YnNjcmlwdGlvbiB0byBzeW1ib2wgbWFya2V0XG4gICAqIGRhdGEuIExvbmctdGVybSBzdWJzY3JpcHRpb24gbWVhbnMgdGhhdCBvbiBzdWJzZXF1ZW50IGNhbGxzIHlvdSB3aWxsIGdldCB1cGRhdGVkIHZhbHVlIGZhc3Rlci4gSWYgc2V0IHRvIGZhbHNlIG9yXG4gICAqIG5vdCBzZXQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBzZXQgdG8gZXhwaXJlIGluIDEyIG1pbnV0ZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xQcmljZT59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBwcmljZSBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFN5bWJvbFByaWNlKGFjY291bnRJZCwgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9uID0gZmFsc2UpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb246ICdSUEMnLCB0eXBlOiAnZ2V0U3ltYm9sUHJpY2UnLCBzeW1ib2wsXG4gICAgICBrZWVwU3Vic2NyaXB0aW9ufSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnByaWNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBwcmljZSBmb3IgYSBzeW1ib2xcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFjY291bnRJZCBpZCBvZiB0aGUgTWV0YVRyYWRlciBhY2NvdW50IHRvIHJldHJpZXZlIGNhbmRsZSBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgY2FuZGxlIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGltZWZyYW1lIGRlZmluZXMgdGhlIHRpbWVmcmFtZSBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIGNhbmRsZSBtdXN0IGJlIGdlbmVyYXRlZC4gQWxsb3dlZCB2YWx1ZXMgZm9yXG4gICAqIE1UNSBhcmUgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW4uIEFsbG93ZWQgdmFsdWVzXG4gICAqIGZvciBNVDQgYXJlIDFtLCA1bSwgMTVtIDMwbSwgMWgsIDRoLCAxZCwgMXcsIDFtblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBTdWJzY3JpcHRpb24gaWYgc2V0IHRvIHRydWUsIHRoZSBhY2NvdW50IHdpbGwgZ2V0IGEgbG9uZy10ZXJtIHN1YnNjcmlwdGlvbiB0byBzeW1ib2wgbWFya2V0XG4gICAqIGRhdGEuIExvbmctdGVybSBzdWJzY3JpcHRpb24gbWVhbnMgdGhhdCBvbiBzdWJzZXF1ZW50IGNhbGxzIHlvdSB3aWxsIGdldCB1cGRhdGVkIHZhbHVlIGZhc3Rlci4gSWYgc2V0IHRvIGZhbHNlIG9yXG4gICAqIG5vdCBzZXQsIHRoZSBzdWJzY3JpcHRpb24gd2lsbCBiZSBzZXQgdG8gZXhwaXJlIGluIDEyIG1pbnV0ZXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE1ldGF0cmFkZXJDYW5kbGU+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gY2FuZGxlIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0Q2FuZGxlKGFjY291bnRJZCwgc3ltYm9sLCB0aW1lZnJhbWUsIGtlZXBTdWJzY3JpcHRpb24gPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRDYW5kbGUnLCBzeW1ib2wsIHRpbWVmcmFtZSxcbiAgICAgIGtlZXBTdWJzY3JpcHRpb259KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuY2FuZGxlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBsYXRlc3QgdGljayBmb3IgYSBzeW1ib2wuIE1UNCBHMSBhY2NvdW50cyBkbyBub3Qgc3VwcG9ydCB0aGlzIEFQSVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gcmV0cmlldmUgc3ltYm9sIHRpY2sgZm9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW1ib2wgc3ltYm9sIHRvIHJldHJpZXZlIHRpY2sgZm9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFN1YnNjcmlwdGlvbiBpZiBzZXQgdG8gdHJ1ZSwgdGhlIGFjY291bnQgd2lsbCBnZXQgYSBsb25nLXRlcm0gc3Vic2NyaXB0aW9uIHRvIHN5bWJvbCBtYXJrZXRcbiAgICogZGF0YS4gTG9uZy10ZXJtIHN1YnNjcmlwdGlvbiBtZWFucyB0aGF0IG9uIHN1YnNlcXVlbnQgY2FsbHMgeW91IHdpbGwgZ2V0IHVwZGF0ZWQgdmFsdWUgZmFzdGVyLiBJZiBzZXQgdG8gZmFsc2Ugb3JcbiAgICogbm90IHNldCwgdGhlIHN1YnNjcmlwdGlvbiB3aWxsIGJlIHNldCB0byBleHBpcmUgaW4gMTIgbWludXRlcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8TWV0YXRyYWRlclRpY2s+fSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGljayBpcyByZXRyaWV2ZWRcbiAgICovXG4gIGFzeW5jIGdldFRpY2soYWNjb3VudElkLCBzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb24gPSBmYWxzZSkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRUaWNrJywgc3ltYm9sLCBrZWVwU3Vic2NyaXB0aW9ufSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnRpY2s7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGxhdGVzdCBvcmRlciBib29rIGZvciBhIHN5bWJvbC4gTVQ0IGFjY291bnRzIGRvIG5vdCBzdXBwb3J0IHRoaXMgQVBJXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXRyaWV2ZSBzeW1ib2wgb3JkZXIgYm9vayBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgdG8gcmV0cmlldmUgb3JkZXIgYm9vayBmb3JcbiAgICogQHBhcmFtIHtib29sZWFufSBrZWVwU3Vic2NyaXB0aW9uIGlmIHNldCB0byB0cnVlLCB0aGUgYWNjb3VudCB3aWxsIGdldCBhIGxvbmctdGVybSBzdWJzY3JpcHRpb24gdG8gc3ltYm9sIG1hcmtldFxuICAgKiBkYXRhLiBMb25nLXRlcm0gc3Vic2NyaXB0aW9uIG1lYW5zIHRoYXQgb24gc3Vic2VxdWVudCBjYWxscyB5b3Ugd2lsbCBnZXQgdXBkYXRlZCB2YWx1ZSBmYXN0ZXIuIElmIHNldCB0byBmYWxzZSBvclxuICAgKiBub3Qgc2V0LCB0aGUgc3Vic2NyaXB0aW9uIHdpbGwgYmUgc2V0IHRvIGV4cGlyZSBpbiAxMiBtaW51dGVzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNZXRhdHJhZGVyQm9vaz59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBvcmRlciBib29rIGlzIHJldHJpZXZlZFxuICAgKi9cbiAgYXN5bmMgZ2V0Qm9vayhhY2NvdW50SWQsIHN5bWJvbCwga2VlcFN1YnNjcmlwdGlvbiA9IGZhbHNlKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ2dldEJvb2snLCBzeW1ib2wsIGtlZXBTdWJzY3JpcHRpb259KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYm9vaztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgcmVmcmVzaCBvZiBtb3N0IHJlY2VudCBxdW90ZSB1cGRhdGVzIGZvciBzeW1ib2xzIHN1YnNjcmliZWQgdG8gYnkgdGhlIHRlcm1pbmFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2l0aCByZWNlbnQgcXVvdGUgc3ltYm9scyB0aGF0IHdhcyBpbml0aWF0ZWQgdG8gcHJvY2Vzc1xuICAgKi9cbiAgYXN5bmMgcmVmcmVzaFRlcm1pbmFsU3RhdGUoYWNjb3VudElkKSB7XG4gICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge2FwcGxpY2F0aW9uOiAnUlBDJywgdHlwZTogJ3JlZnJlc2hUZXJtaW5hbFN0YXRlJ30pO1xuICAgIHJldHVybiByZXNwb25zZS5zeW1ib2xzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyByZWZyZXNoIGFuZCByZXRyaWV2ZXMgbGF0ZXN0IHF1b3RlcyBmb3IgYSBzdWJzZXQgb2Ygc3ltYm9scyB0aGUgdGVybWluYWwgaXMgc3Vic2NyaWJlZCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gc3ltYm9scyBxdW90ZSBzeW1ib2xzIHRvIHJlZnJlc2hcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVmcmVzaGVkUXVvdGVzPn0gcmVmcmVzaGVkIHF1b3RlcyBhbmQgYmFzaWMgYWNjb3VudCBpbmZvcm1hdGlvbiBpbmZvXG4gICAqL1xuICBhc3luYyByZWZyZXNoU3ltYm9sUXVvdGVzKGFjY291bnRJZCwgc3ltYm9scykge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdyZWZyZXNoU3ltYm9sUXVvdGVzJywgc3ltYm9sc30pO1xuICAgIHJldHVybiByZXNwb25zZS5yZWZyZXNoZWRRdW90ZXM7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgY2xpZW50IHVwdGltZSBzdGF0cyB0byB0aGUgc2VydmVyLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIGlkIG9mIHRoZSBNZXRhVHJhZGVyIGFjY291bnQgdG8gc2F2ZSB1cHRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IHVwdGltZSB1cHRpbWUgc3RhdGlzdGljcyB0byBzZW5kIHRvIHRoZSBzZXJ2ZXJcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB1cHRpbWUgc3RhdGlzdGljcyBpcyBzdWJtaXR0ZWRcbiAgICovXG4gIHNhdmVVcHRpbWUoYWNjb3VudElkLCB1cHRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ycGNSZXF1ZXN0KGFjY291bnRJZCwge3R5cGU6ICdzYXZlVXB0aW1lJywgdXB0aW1lfSk7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byB1bnN1YnNjcmliZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHNvY2tldCB1bnN1YnNjcmliZWRcbiAgICovXG4gIGFzeW5jIHVuc3Vic2NyaWJlKGFjY291bnRJZCkge1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlLm9uVW5zdWJzY3JpYmUoYWNjb3VudElkKTtcbiAgICBjb25zdCB1cGRhdGVFdmVudHNUb1JlbW92ZSA9IE9iamVjdC5rZXlzKHRoaXMuX3VwZGF0ZUV2ZW50cykuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChhY2NvdW50SWQpKTtcbiAgICB1cGRhdGVFdmVudHNUb1JlbW92ZS5mb3JFYWNoKGtleSA9PiBkZWxldGUgdGhpcy5fdXBkYXRlRXZlbnRzW2tleV0pO1xuICAgIGlmICh0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXSkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmtleXModGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl0pLm1hcChhc3luYyBpbnN0YW5jZU51bWJlciA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci51bnN1YnNjcmliZShhY2NvdW50SWQsIE51bWJlcihpbnN0YW5jZU51bWJlcikpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVthY2NvdW50SWRdO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoIShbJ1RpbWVvdXRFcnJvcicsICdOb3RGb3VuZEVycm9yJ10uaW5jbHVkZXMoZXJyLm5hbWUpKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYCR7YWNjb3VudElkfToke2luc3RhbmNlTnVtYmVyfTogZmFpbGVkIHRvIHVuc3Vic2NyaWJlYCwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCBzZXJ2ZXIgdGltZSAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvc2VydmVyVGltZS8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcnZlclRpbWVcbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIGN1cnJlbnQgc2VydmVyIHRpbWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGJyb2tlclRpbWUgY3VycmVudCBicm9rZXIgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtEYXRlfSBbbGFzdFF1b3RlVGltZV0gbGFzdCBxdW90ZSB0aW1lXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbbGFzdFF1b3RlQnJva2VyVGltZV0gbGFzdCBxdW90ZSB0aW1lLCBpbiBicm9rZXIgdGltZXpvbmUsIFlZWVktTU0tREQgSEg6bW06c3MuU1NTIGZvcm1hdFxuICAgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBzZXJ2ZXIgdGltZSBmb3IgYSBzcGVjaWZpZWQgTWV0YVRyYWRlciBhY2NvdW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIE1ldGFUcmFkZXIgYWNjb3VudCB0byByZXR1cm4gc2VydmVyIHRpbWUgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNlcnZlclRpbWU+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIHNlcnZlciB0aW1lXG4gICAqL1xuICBhc3luYyBnZXRTZXJ2ZXJUaW1lKGFjY291bnRJZCkge1xuICAgIGxldCByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHthcHBsaWNhdGlvbjogJ1JQQycsIHR5cGU6ICdnZXRTZXJ2ZXJUaW1lJ30pO1xuICAgIHJldHVybiByZXNwb25zZS5zZXJ2ZXJUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmdpbiByZXF1aXJlZCB0byBvcGVuIGEgdHJhZGUgKHNlZSBodHRwczovL21ldGFhcGkuY2xvdWQvZG9jcy9jbGllbnQvbW9kZWxzL21hcmdpbi8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1hcmdpblxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW21hcmdpbl0gbWFyZ2luIHJlcXVpcmVkIHRvIG9wZW4gYSB0cmFkZS4gSWYgbWFyZ2luIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiB0aGlzIGZpZWxkIGlzXG4gICAqIG5vdCBkZWZpbmVkXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb250YWlucyBvcmRlciB0byBjYWxjdWxhdGUgbWFyZ2luIGZvciAoc2VlIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvbWFyZ2luT3JkZXIvKVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNYXJnaW5PcmRlclxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3ltYm9sIG9yZGVyIHN5bWJvbFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZSBvcmRlciB0eXBlLCBvbmUgb2YgT1JERVJfVFlQRV9CVVkgb3IgT1JERVJfVFlQRV9TRUxMXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b2x1bWUgb3JkZXIgdm9sdW1lLCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvcGVuUHJpY2Ugb3JkZXIgb3BlbiBwcmljZSwgbXVzdCBiZSBncmVhdGVyIHRoYW4gMFxuICAgKi9cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBtYXJnaW4gcmVxdWlyZWQgdG8gb3BlbiBhIHRyYWRlIG9uIHRoZSBzcGVjaWZpZWQgdHJhZGluZyBhY2NvdW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgaWQgb2YgdGhlIHRyYWRpbmcgYWNjb3VudCB0byBjYWxjdWxhdGUgbWFyZ2luIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwbGljYXRpb24gYXBwbGljYXRpb24gdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVsaWFiaWxpdHkgYWNjb3VudCByZWxpYWJpbGl0eVxuICAgKiBAcGFyYW0ge01hcmdpbk9yZGVyfSBvcmRlciBvcmRlciB0byBjYWxjdWxhdGUgbWFyZ2luIGZvclxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNYXJnaW4+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIG1hcmdpbiBjYWxjdWxhdGlvbiByZXN1bHRcbiAgICovXG4gIGFzeW5jIGNhbGN1bGF0ZU1hcmdpbihhY2NvdW50SWQsIGFwcGxpY2F0aW9uLCByZWxpYWJpbGl0eSwgb3JkZXIpIHtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgaWYgKGFwcGxpY2F0aW9uID09PSAnUlBDJykge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCB7YXBwbGljYXRpb24sIHR5cGU6ICdjYWxjdWxhdGVNYXJnaW4nLCBvcmRlcn0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMucnBjUmVxdWVzdEFsbEluc3RhbmNlcyhhY2NvdW50SWQsIHthcHBsaWNhdGlvbiwgdHlwZTogJ2NhbGN1bGF0ZU1hcmdpbicsIG9yZGVyfSxcbiAgICAgICAgcmVsaWFiaWxpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UubWFyZ2luO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIG9uVW5zdWJzY3JpYmVSZWdpb24gbGlzdGVuZXIgZXZlbnQgXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVnaW9uIGFjY291bnQgcmVnaW9uIHRvIHVuc3Vic2NyaWJlXG4gICAqL1xuICBhc3luYyB1bnN1YnNjcmliZUFjY291bnRSZWdpb24oYWNjb3VudElkLCByZWdpb24pIHtcbiAgICBjb25zdCB1bnN1YnNjcmliZVByb21pc2VzID0gW107XG4gICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2FjY291bnRJZF0gfHwgW10pIHtcbiAgICAgIHVuc3Vic2NyaWJlUHJvbWlzZXMucHVzaChcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25VbnN1YnNjcmliZVJlZ2lvbihyZWdpb24pLFxuICAgICAgICAgICAgYCR7YWNjb3VudElkfToke3JlZ2lvbn06b25VbnN1YnNjcmliZVJlZ2lvbmAsIHRydWUpO1xuICAgICAgICB9KSgpKVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4gdGhpcy5fbG9nZ2VyLmVycm9yKGAke2FjY291bnRJZH06JHtyZWdpb259OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgJ2Fib3V0IG9uVW5zdWJzY3JpYmVSZWdpb24gZXZlbnQnLCBlcnIpKVxuICAgICAgKTtcbiAgICB9XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodW5zdWJzY3JpYmVQcm9taXNlcyk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgZm9yIHNwZWNpZmljIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uTGlzdGVuZXJ9IGxpc3RlbmVyIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lciB0byBhZGRcbiAgICovXG4gIGFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnRJZCwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoYCR7YWNjb3VudElkfTogQWRkZWQgc3luY2hyb25pemF0aW9uIGxpc3RlbmVyYCk7XG4gICAgbGV0IGxpc3RlbmVycyA9IHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdO1xuICAgIGlmICghbGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdID0gbGlzdGVuZXJzO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXIgZm9yIHNwZWNpZmljIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7U3luY2hyb25pemF0aW9uTGlzdGVuZXJ9IGxpc3RlbmVyIHN5bmNocm9uaXphdGlvbiBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZVN5bmNocm9uaXphdGlvbkxpc3RlbmVyKGFjY291bnRJZCwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoYCR7YWNjb3VudElkfTogUmVtb3ZlZCBzeW5jaHJvbml6YXRpb24gbGlzdGVuZXJgKTtcbiAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW2FjY291bnRJZF07XG4gICAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1thY2NvdW50SWRdID0gbGlzdGVuZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgbGF0ZW5jeSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0xhdGVuY3lMaXN0ZW5lcn0gbGlzdGVuZXIgbGF0ZW5jeSBsaXN0ZW5lciB0byBhZGRcbiAgICovXG4gIGFkZExhdGVuY3lMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBsYXRlbmN5IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7TGF0ZW5jeUxpc3RlbmVyfSBsaXN0ZW5lciBsYXRlbmN5IGxpc3RlbmVyIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlTGF0ZW5jeUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyA9IHRoaXMuX2xhdGVuY3lMaXN0ZW5lcnMuZmlsdGVyKGwgPT4gbCAhPT0gbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgcmVjb25uZWN0IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7UmVjb25uZWN0TGlzdGVuZXJ9IGxpc3RlbmVyIHJlY29ubmVjdCBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRJZCBhY2NvdW50IGlkIG9mIGxpc3RlbmVyXG4gICAqL1xuICBhZGRSZWNvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lciwgYWNjb3VudElkKSB7XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzLnB1c2goe2FjY291bnRJZCwgbGlzdGVuZXJ9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHJlY29ubmVjdCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge1JlY29ubmVjdExpc3RlbmVyfSBsaXN0ZW5lciBsaXN0ZW5lciB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZVJlY29ubmVjdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzID0gdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzLmZpbHRlcihsID0+IGwubGlzdGVuZXIgIT09IGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMuIEludGVuZGVkIGZvciB1c2UgaW4gdW5pdCB0ZXN0cy5cbiAgICovXG4gIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9yZWNvbm5lY3RMaXN0ZW5lcnMgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWNjb3VudCBvciByZXBsaWNhIGRhdGEgZnJvbSBjbGllbnQgcmVjb3JkcyBhbmQgdW5zdWJzY3JpYmVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZCB0byBwcm9jZXNzIHRoZSByZW1vdmFsIG9mXG4gICAqL1xuICBvbkFjY291bnREZWxldGVkKGFjY291bnRJZCkge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsQWNjb3VudChhY2NvdW50SWQpO1xuICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlLm9uVW5zdWJzY3JpYmUoYWNjb3VudElkKTtcbiAgICBjb25zdCBtYXN0ZXJBY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW2FjY291bnRJZF07XG4gICAgaWYgKG1hc3RlckFjY291bnRJZCkge1xuICAgICAgaWYgKG1hc3RlckFjY291bnRJZCA9PT0gYWNjb3VudElkKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvbkRhdGEgPSB0aGlzLl9hY2NvdW50UmVwbGljYXNbbWFzdGVyQWNjb3VudElkXTtcbiAgICAgICAgY29uc3QgcmVwbGljYXMgPSBPYmplY3QudmFsdWVzKHJlZ2lvbkRhdGEpO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2UpXG4gICAgICAgICAgLmZpbHRlcihpbnN0YW5jZSA9PiBpbnN0YW5jZS5zdGFydHNXaXRoKGAke21hc3RlckFjY291bnRJZH1gKSlcbiAgICAgICAgICAuZm9yRWFjaChpbnN0YW5jZSA9PiBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlXSk7XG4gICAgICAgIHJlcGxpY2FzLmZvckVhY2gocmVwbGljYSA9PiB7XG4gICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzKS5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBpbnN0YW5jZVtyZXBsaWNhXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbcmVwbGljYV07XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudFJlcGxpY2FzW21hc3RlckFjY291bnRJZF07XG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHttYXN0ZXJBY2NvdW50SWR9OiBwcm9jZXNzZWQgcHJpbWFyeSBhY2NvdW50IHJlbW92YWxgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cykuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgZGVsZXRlIGluc3RhbmNlW2FjY291bnRJZF07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWdpb25EYXRhID0gdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXTtcbiAgICAgICAgaWYgKHJlZ2lvbkRhdGEpIHtcbiAgICAgICAgICBjb25zdCByZWdpb24gPSByZWdpb25EYXRhLnJlZ2lvbjtcbiAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2UpXG4gICAgICAgICAgICAuZmlsdGVyKGluc3RhbmNlID0+IGluc3RhbmNlLnN0YXJ0c1dpdGgoYCR7bWFzdGVyQWNjb3VudElkfToke3JlZ2lvbn1gKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGluc3RhbmNlID0+IGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VdKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudFJlcGxpY2FzW21hc3RlckFjY291bnRJZF1bcmVnaW9uXTtcbiAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7bWFzdGVyQWNjb3VudElkfTogcHJvY2Vzc2VkIHJlbW92YWwgb2YgcmVwbGljYSAke2FjY291bnRJZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFthY2NvdW50SWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbYWNjb3VudElkXTtcbiAgICAgIH1cbiAgXG4gICAgfVxuICB9XG4gIFxuICAvKipcbiAgICogUXVldWVzIGFuIGFjY291bnQgcGFja2V0IGZvciBwcm9jZXNzaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgcGFja2V0IHRvIHByb2Nlc3NcbiAgICovXG4gIHF1ZXVlUGFja2V0KHBhY2tldCkge1xuICAgIGNvbnN0IGFjY291bnRJZCA9IHBhY2tldC5hY2NvdW50SWQ7XG4gICAgY29uc3QgcGFja2V0cyA9IHRoaXMuX3BhY2tldE9yZGVyZXIucmVzdG9yZU9yZGVyKHBhY2tldCkuZmlsdGVyKHAgPT4gcC50eXBlICE9PSAnbm9vcCcpO1xuICAgIGlmICh0aGlzLl9zZXF1ZW50aWFsRXZlbnRQcm9jZXNzaW5nICYmIHBhY2tldC5zZXF1ZW5jZU51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBldmVudHMgPSBwYWNrZXRzLm1hcChwYWNrZXRJdGVtID0+ICgpID0+IFxuICAgICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5fcHJvY2Vzc1N5bmNocm9uaXphdGlvblBhY2tldChwYWNrZXRJdGVtKSkpO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0gPSBldmVudHM7XG4gICAgICAgIHRoaXMuX2NhbGxBY2NvdW50RXZlbnRzKGFjY291bnRJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gdGhpcy5fZXZlbnRRdWV1ZXNbYWNjb3VudElkXS5jb25jYXQoZXZlbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0cy5mb3JFYWNoKHBhY2tldEl0ZW0gPT4gdGhpcy5fcHJvY2Vzc1N5bmNocm9uaXphdGlvblBhY2tldChwYWNrZXRJdGVtKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFF1ZXVlcyBhY2NvdW50IGV2ZW50IGZvciBwcm9jZXNzaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBldmVudCBsYWJlbCBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxhYmxlIGFzeW5jIG9yIHJlZ3VsYXIgZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgKi9cbiAgcXVldWVFdmVudChhY2NvdW50SWQsIG5hbWUsIGNhbGxhYmxlKSB7XG4gICAgbGV0IGV2ZW50ID0gKCkgPT4gdGhpcy5fcHJvY2Vzc0V2ZW50KGNhbGxhYmxlLCBgJHthY2NvdW50SWR9OiR7bmFtZX1gKTtcbiAgICBpZiAodGhpcy5fc2VxdWVudGlhbEV2ZW50UHJvY2Vzc2luZykge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdKSB7IFxuICAgICAgICB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdID0gW2V2ZW50XTtcbiAgICAgICAgdGhpcy5fY2FsbEFjY291bnRFdmVudHMoYWNjb3VudElkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0ucHVzaChldmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2NhbGxBY2NvdW50RXZlbnRzKGFjY291bnRJZCkge1xuICAgIGlmICh0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdKSB7XG4gICAgICB3aGlsZSh0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdLmxlbmd0aCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdWzBdKCk7XG4gICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW2FjY291bnRJZF0uc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudFF1ZXVlc1thY2NvdW50SWRdO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9yZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl1bc29ja2V0SW5zdGFuY2VJbmRleF07XG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICB3aGlsZSAoIWluc3RhbmNlLnNvY2tldC5jb25uZWN0ZWQgJiYgIWluc3RhbmNlLmlzUmVjb25uZWN0aW5nICYmIGluc3RhbmNlLmNvbm5lY3RlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLl90cnlSZWNvbm5lY3QoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3RyeVJlY29ubmVjdChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnNvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtzb2NrZXRJbnN0YW5jZUluZGV4XTtcbiAgICBpbnN0YW5jZS5yZWNvbm5lY3RXYWl0VGltZSA9IE1hdGgubWluKGluc3RhbmNlLnJlY29ubmVjdFdhaXRUaW1lICogMiwgMzAwMDApO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWluc3RhbmNlLnNvY2tldC5jb25uZWN0ZWQgJiYgIWluc3RhbmNlLmlzUmVjb25uZWN0aW5nICYmIGluc3RhbmNlLmNvbm5lY3RlZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlLnNlc3Npb25JZCA9IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSgzMik7XG4gICAgICAgICAgY29uc3QgY2xpZW50SWQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5pby5vcHRzLmV4dHJhSGVhZGVyc1snQ2xpZW50LUlkJ10gPSBjbGllbnRJZDtcbiAgICAgICAgICBpbnN0YW5jZS5zb2NrZXQuaW8ub3B0cy5xdWVyeS5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICAgIGluc3RhbmNlLmlzUmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICBpbnN0YW5jZS5zb2NrZXQuaW8udXJpID0gYXdhaXQgdGhpcy5fZ2V0U2VydmVyVXJsKGluc3RhbmNlTnVtYmVyLCBzb2NrZXRJbnN0YW5jZUluZGV4LCByZWdpb24pO1xuICAgICAgICAgIGluc3RhbmNlLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaW5zdGFuY2UuaXNSZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIGluc3RhbmNlLnJlY29ubmVjdFdhaXRUaW1lKSk7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGFuZW91c2x5IHNlbmRzIFJQQyByZXF1ZXN0cyB0byBhbGwgc3luY2hyb25pemVkIGluc3RhbmNlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudElkIG1ldGF0cmFkZXIgYWNjb3VudCBpZFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBiYXNlIHJlcXVlc3QgZGF0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3JlbGlhYmlsaXR5XSBhY2NvdW50IHJlbGlhYmlsaXR5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gcmVxdWVzdCB0aW1lb3V0IGluIHNlY29uZHNcbiAgICovXG4gIGFzeW5jIHJwY1JlcXVlc3RBbGxJbnN0YW5jZXMoYWNjb3VudElkLCByZXF1ZXN0LCByZWxpYWJpbGl0eSwgdGltZW91dEluU2Vjb25kcykge1xuICAgIGlmIChyZWxpYWJpbGl0eSA9PT0gJ2hpZ2gnKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYW55KFswLCAxXS5tYXAoaW5zdGFuY2VOdW1iZXIgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLnJwY1JlcXVlc3QoYWNjb3VudElkLCBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0LCBcbiAgICAgICAgICAgIHtpbnN0YW5jZUluZGV4OiBpbnN0YW5jZU51bWJlcn0pLCB0aW1lb3V0SW5TZWNvbmRzKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuZXJyb3JzWzBdOyBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucnBjUmVxdWVzdChhY2NvdW50SWQsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIFJQQyByZXF1ZXN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50SWQgbWV0YXRyYWRlciBhY2NvdW50IGlkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IGJhc2UgcmVxdWVzdCBkYXRhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dEluU2Vjb25kc10gcmVxdWVzdCB0aW1lb3V0IGluIHNlY29uZHNcbiAgICovXG4gIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksIG1heC1zdGF0ZW1lbnRzXG4gIGFzeW5jIHJwY1JlcXVlc3QoYWNjb3VudElkLCByZXF1ZXN0LCB0aW1lb3V0SW5TZWNvbmRzKSB7XG4gICAgY29uc3QgaWdub3JlZFJlcXVlc3RUeXBlcyA9IFsnc3Vic2NyaWJlJywgJ3N5bmNocm9uaXplJywgJ3JlZnJlc2hNYXJrZXREYXRhU3Vic2NyaXB0aW9ucycsICd1bnN1YnNjcmliZSddO1xuICAgIGNvbnN0IHByaW1hcnlBY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW2FjY291bnRJZF07XG4gICAgbGV0IGNvbm5lY3RlZEluc3RhbmNlID0gdGhpcy5fbGF0ZW5jeVNlcnZpY2UuZ2V0QWN0aXZlQWNjb3VudEluc3RhbmNlcyhwcmltYXJ5QWNjb3VudElkKVswXTtcbiAgICBpZiAoIWlnbm9yZWRSZXF1ZXN0VHlwZXMuaW5jbHVkZXMocmVxdWVzdC50eXBlKSkge1xuICAgICAgaWYgKCFjb25uZWN0ZWRJbnN0YW5jZSkge1xuICAgICAgICBjb25uZWN0ZWRJbnN0YW5jZSA9IGF3YWl0IHRoaXMuX2xhdGVuY3lTZXJ2aWNlLndhaXRDb25uZWN0ZWRJbnN0YW5jZShhY2NvdW50SWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0aXZlUmVnaW9uID0gY29ubmVjdGVkSW5zdGFuY2Uuc3BsaXQoJzonKVsxXTtcbiAgICAgIGFjY291bnRJZCA9IHRoaXMuX2FjY291bnRSZXBsaWNhc1twcmltYXJ5QWNjb3VudElkXVthY3RpdmVSZWdpb25dO1xuICAgIH1cbiAgICBsZXQgc29ja2V0SW5zdGFuY2VJbmRleCA9IG51bGw7XG4gICAgbGV0IGluc3RhbmNlTnVtYmVyID0gMDtcbiAgICBjb25zdCByZWdpb24gPSB0aGlzLmdldEFjY291bnRSZWdpb24oYWNjb3VudElkKTtcbiAgICB0aGlzLl9yZWZyZXNoQWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIGlmIChyZXF1ZXN0Lmluc3RhbmNlSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdGFuY2VOdW1iZXIgPSByZXF1ZXN0Lmluc3RhbmNlSW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb25uZWN0ZWRJbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZU51bWJlciA9IE51bWJlcihjb25uZWN0ZWRJbnN0YW5jZS5zcGxpdCgnOicpWzJdKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXF1ZXN0LmFwcGxpY2F0aW9uICE9PSAnUlBDJykge1xuICAgICAgICByZXF1ZXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCwge2luc3RhbmNlSW5kZXg6IGluc3RhbmNlTnVtYmVyfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl0pIHtcbiAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdID0ge307XG4gICAgfVxuICAgIGlmICghdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl0pIHtcbiAgICAgIHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dID0ge307XG4gICAgfVxuICAgIGlmICghdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdKSB7XG4gICAgICB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl0gPSBbXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZyhgJHthY2NvdW50SWR9OiR7aW5zdGFuY2VOdW1iZXJ9OiBjcmVhdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gUlBDIHJlcXVlc3RgKTtcbiAgICAgIGF3YWl0IHRoaXMuX2NyZWF0ZVNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF07XG4gICAgfVxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdO1xuICAgIGlmICghaW5zdGFuY2UuY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7YWNjb3VudElkfToke2luc3RhbmNlTnVtYmVyfTogY29ubmVjdGluZyBzb2NrZXQgaW5zdGFuY2Ugb24gUlBDIHJlcXVlc3RgKTtcbiAgICAgIGF3YWl0IHRoaXMuY29ubmVjdChpbnN0YW5jZU51bWJlciwgcmVnaW9uKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSkge1xuICAgICAgYXdhaXQgaW5zdGFuY2UuY29ubmVjdFJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3QudHlwZSA9PT0gJ3N1YnNjcmliZScpIHtcbiAgICAgIHJlcXVlc3Quc2Vzc2lvbklkID0gaW5zdGFuY2Uuc2Vzc2lvbklkO1xuICAgIH1cbiAgICBpZiAoWyd0cmFkZScsICdzdWJzY3JpYmUnXS5pbmNsdWRlcyhyZXF1ZXN0LnR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVJlcXVlc3QoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgcmVxdWVzdCwgdGltZW91dEluU2Vjb25kcyk7XG4gICAgfVxuICAgIGxldCByZXRyeUNvdW50ZXIgPSAwO1xuICAgIHdoaWxlICh0cnVlKSB7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9tYWtlUmVxdWVzdChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCByZXF1ZXN0LCB0aW1lb3V0SW5TZWNvbmRzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgICAgICBsZXQgY2FsY1JldHJ5Q291bnRlciA9IHJldHJ5Q291bnRlcjtcbiAgICAgICAgICBsZXQgY2FsY1JlcXVlc3RUaW1lID0gMDtcbiAgICAgICAgICB3aGlsZSAoY2FsY1JldHJ5Q291bnRlciA8IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgICAgICAgIGNhbGNSZXRyeUNvdW50ZXIrKztcbiAgICAgICAgICAgIGNhbGNSZXF1ZXN0VGltZSArPSBNYXRoLm1pbihNYXRoLnBvdygyLCBjYWxjUmV0cnlDb3VudGVyKSAqIHRoaXMuX21pblJldHJ5RGVsYXlJblNlY29uZHMsXG4gICAgICAgICAgICAgIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMpICogMTAwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmV0cnlUaW1lID0gbmV3IERhdGUoZXJyLm1ldGFkYXRhLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgICAgaWYgKERhdGUubm93KCkgKyBjYWxjUmVxdWVzdFRpbWUgPiByZXRyeVRpbWUgJiYgcmV0cnlDb3VudGVyIDwgdGhpcy5fcmV0cmllcykge1xuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgPCByZXRyeVRpbWUpIHtcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCByZXRyeVRpbWUgLSBEYXRlLm5vdygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXRyeUNvdW50ZXIrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChbJ05vdFN5bmNocm9uaXplZEVycm9yJywgJ1RpbWVvdXRFcnJvcicsICdOb3RBdXRoZW50aWNhdGVkRXJyb3InLFxuICAgICAgICAgICdJbnRlcm5hbEVycm9yJ10uaW5jbHVkZXMoZXJyLm5hbWUpICYmIFxuICAgICAgICAgIHJldHJ5Q291bnRlciA8IHRoaXMuX3JldHJpZXMpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5Q291bnRlcikgKiBcbiAgICAgICAgICAgIHRoaXMuX21pblJldHJ5RGVsYXlJblNlY29uZHMsIHRoaXMuX21heFJldHJ5RGVsYXlJblNlY29uZHMpICogMTAwMCkpO1xuICAgICAgICAgIHJldHJ5Q291bnRlcisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX21ha2VSZXF1ZXN0KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIsIHJlcXVlc3QsIHRpbWVvdXRJblNlY29uZHMpIHtcbiAgICBjb25zdCBzb2NrZXRJbnN0YW5jZSA9IHRoaXMuX2dldFNvY2tldEluc3RhbmNlQnlBY2NvdW50KGFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgIGxldCByZXF1ZXN0SWQgPSByZXF1ZXN0LnJlcXVlc3RJZCB8fCByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHJlcXVlc3QudGltZXN0YW1wcyA9IHtjbGllbnRQcm9jZXNzaW5nU3RhcnRlZDogbmV3IERhdGUoKX07XG4gICAgbGV0IHJlc3VsdCA9IFByb21pc2UucmFjZShbXG4gICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzb2NrZXRJbnN0YW5jZS5yZXF1ZXN0UmVzb2x2ZXNbcmVxdWVzdElkXSA9IFxuICAgICAgICB7cmVzb2x2ZSwgcmVqZWN0LCB0eXBlOiByZXF1ZXN0LnR5cGV9KSxcbiAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICByZWplY3QobmV3IFRpbWVvdXRFcnJvcihgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHJlcXVlc3QgJHtyZXF1ZXN0LnJlcXVlc3RJZH0gb2YgdHlwZSAke3JlcXVlc3QudHlwZX0gYCArXG4gICAgICAgICAgJ3RpbWVkIG91dC4gUGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGFjY291bnQgaXMgY29ubmVjdGVkIHRvIGJyb2tlciBiZWZvcmUgcmV0cnlpbmcgeW91ciByZXF1ZXN0LicpKTtcbiAgICAgICAgZGVsZXRlIHNvY2tldEluc3RhbmNlLnJlcXVlc3RSZXNvbHZlc1tyZXF1ZXN0SWRdO1xuICAgICAgfSwgKHRpbWVvdXRJblNlY29uZHMgKiAxMDAwKSB8fCB0aGlzLl9yZXF1ZXN0VGltZW91dCkpXG4gICAgXSk7XG4gICAgcmVxdWVzdC5hY2NvdW50SWQgPSBhY2NvdW50SWQ7XG4gICAgcmVxdWVzdC5hcHBsaWNhdGlvbiA9IHJlcXVlc3QuYXBwbGljYXRpb24gfHwgdGhpcy5fYXBwbGljYXRpb247XG4gICAgaWYgKCFyZXF1ZXN0LnJlcXVlc3RJZCkge1xuICAgICAgcmVxdWVzdC5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gICAgfVxuICAgIGlmIChyZXF1ZXN0LnR5cGUgPT09ICd1bnN1YnNjcmliZScgfHwgcmVxdWVzdC5hcHBsaWNhdGlvbiA9PT0gJ1JQQycgfHxcbiAgICAgIHJlcXVlc3QuaW5zdGFuY2VJbmRleCA9PT0gc29ja2V0SW5zdGFuY2UuaW5zdGFuY2VOdW1iZXIpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygoKSA9PiBgJHthY2NvdW50SWR9OiBTZW5kaW5nIHJlcXVlc3Q6ICR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdCl9YCk7XG4gICAgICBzb2NrZXRJbnN0YW5jZS5zb2NrZXQuZW1pdCgncmVxdWVzdCcsIHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke2FjY291bnRJZH06JHtyZXF1ZXN0Lmluc3RhbmNlSW5kZXh9OiBza2lwcGluZyByZXF1ZXN0IGJlY2F1c2UgaXQgaXMgYmVpbmcgc2VudCB0byBgICtcbiAgICAgICAgYHRoZSBzb2NrZXQgb2YgdGhlIHdyb25nIGluc3RhbmNlIGluZGV4LCByZXF1ZXN0PSR7SlNPTi5zdHJpbmdpZnkocmVxdWVzdCl9YCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIF9jb252ZXJ0RXJyb3IoZGF0YSkge1xuICAgIGlmIChkYXRhLmVycm9yID09PSAnVmFsaWRhdGlvbkVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLmRldGFpbHMpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdOb3RTeW5jaHJvbml6ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90U3luY2hyb25pemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICByZXR1cm4gbmV3IFRpbWVvdXRFcnJvcihkYXRhLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5lcnJvciA9PT0gJ05vdEF1dGhlbnRpY2F0ZWRFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Q29ubmVjdGVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdGb3JiaWRkZW5FcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgRm9yYmlkZGVuRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUcmFkZUVycm9yJykge1xuICAgICAgcmV0dXJuIG5ldyBUcmFkZUVycm9yKGRhdGEubWVzc2FnZSwgZGF0YS5udW1lcmljQ29kZSwgZGF0YS5zdHJpbmdDb2RlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdVbmF1dGhvcml6ZWRFcnJvcicpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZXJyb3IgPT09ICdUb29NYW55UmVxdWVzdHNFcnJvcicpIHtcbiAgICAgIHJldHVybiBuZXcgVG9vTWFueVJlcXVlc3RzRXJyb3IoZGF0YS5tZXNzYWdlLCBkYXRhLm1ldGFkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGRhdGEubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgX2NvbnZlcnRJc29UaW1lVG9EYXRlKHBhY2tldCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKGxldCBmaWVsZCBpbiBwYWNrZXQpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHBhY2tldFtmaWVsZF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBmaWVsZC5tYXRjaCgvdGltZSR8VGltZSQvKSAmJiBcbiAgICAgICAgIWZpZWxkLm1hdGNoKC9icm9rZXJUaW1lJHxCcm9rZXJUaW1lJHx0aW1lZnJhbWUkLykpIHtcbiAgICAgICAgcGFja2V0W2ZpZWxkXSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fY29udmVydElzb1RpbWVUb0RhdGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRJc29UaW1lVG9EYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudGltZXN0YW1wcykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pblxuICAgICAgZm9yIChsZXQgZmllbGQgaW4gcGFja2V0LnRpbWVzdGFtcHMpIHtcbiAgICAgICAgcGFja2V0LnRpbWVzdGFtcHNbZmllbGRdID0gbmV3IERhdGUocGFja2V0LnRpbWVzdGFtcHNbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tldCAmJiBwYWNrZXQudHlwZSA9PT0gJ3ByaWNlcycpIHtcbiAgICAgIGZvciAobGV0IHByaWNlIG9mIHBhY2tldC5wcmljZXMgfHwgW10pIHtcbiAgICAgICAgaWYgKHByaWNlLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gICAgICAgICAgZm9yIChsZXQgZmllbGQgaW4gcHJpY2UudGltZXN0YW1wcykge1xuICAgICAgICAgICAgcHJpY2UudGltZXN0YW1wc1tmaWVsZF0gPSBuZXcgRGF0ZShwcmljZS50aW1lc3RhbXBzW2ZpZWxkXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgc3ltYm9sIHNwZWNpZmljYXRpb24uIENvbnRhaW5zIHN5bWJvbCBzcGVjaWZpY2F0aW9uIChzZWVcbiAgICogaHR0cHM6Ly9tZXRhYXBpLmNsb3VkL2RvY3MvY2xpZW50L21vZGVscy9tZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbi8pXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRpY2tTaXplIHRpY2sgc2l6ZVxuICAgKiBAcHJvcGVydHkge051bWJlcn0gbWluVm9sdW1lIG1pbmltdW0gb3JkZXIgdm9sdW1lIGZvciB0aGUgc3ltYm9sXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBtYXhWb2x1bWUgbWF4aW11bSBvcmRlciB2b2x1bWUgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHZvbHVtZVN0ZXAgb3JkZXIgdm9sdW1lIHN0ZXAgZm9yIHRoZSBzeW1ib2xcbiAgICogQHByb3BlcnR5IHtBcnJheTxTdHJpbmc+fSBsaXN0IG9mIGFsbG93ZWQgb3JkZXIgZmlsbGluZyBtb2Rlcy4gQ2FuIGNvbnRhaW4gT1JERVJfRklMTElOR19GT0ssIE9SREVSX0ZJTExJTkdfSU9DIG9yXG4gICAqIGJvdGguIFNlZSBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9maWxsaW5nX21vZGUgZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGRlYWwgZXhlY3V0aW9uIG1vZGUuIFBvc3NpYmxlIHZhbHVlcyBhcmUgU1lNQk9MX1RSQURFX0VYRUNVVElPTl9SRVFVRVNULFxuICAgKiBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0lOU1RBTlQsIFNZTUJPTF9UUkFERV9FWEVDVVRJT05fTUFSS0VULCBTWU1CT0xfVFJBREVfRVhFQ1VUSU9OX0VYQ0hBTkdFLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9leGVjdXRpb24gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbnRyYWN0U2l6ZSB0cmFkZSBjb250cmFjdCBzaXplXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSBxdW90ZVNlc3Npb25zIHF1b3RlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7TWV0YXRyYWRlclNlc3Npb25zfSB0cmFkZVNlc3Npb25zIHRyYWRlIHNlc3Npb25zLCBpbmRleGVkIGJ5IGRheSBvZiB3ZWVrXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdHJhZGVNb2RlXSBvcmRlciBleGVjdXRpb24gdHlwZS4gUG9zc2libGUgdmFsdWVzIGFyZSBTWU1CT0xfVFJBREVfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1RSQURFX01PREVfTE9OR09OTFksIFNZTUJPTF9UUkFERV9NT0RFX1NIT1JUT05MWSwgU1lNQk9MX1RSQURFX01PREVfQ0xPU0VPTkxZLCBTWU1CT0xfVFJBREVfTU9ERV9GVUxMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF90cmFkZV9tb2RlIGZvciBtb3JlXG4gICAqIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtib25kQWNjcnVlZEludGVyZXN0XSBhY2NydWVkIGludGVyZXN0IOKAkyBhY2N1bXVsYXRlZCBjb3Vwb24gaW50ZXJlc3QsIGkuZS4gcGFydCBvZiB0aGUgY291cG9uXG4gICAqIGludGVyZXN0IGNhbGN1bGF0ZWQgaW4gcHJvcG9ydGlvbiB0byB0aGUgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIGNvdXBvbiBib25kIGlzc3VhbmNlIG9yIHRoZSBsYXN0IGNvdXBvbiBpbnRlcmVzdFxuICAgKiBwYXltZW50XG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYm9uZEZhY2VWYWx1ZV0gZmFjZSB2YWx1ZSDigJMgaW5pdGlhbCBib25kIHZhbHVlIHNldCBieSB0aGUgaXNzdWVyXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbb3B0aW9uU3RyaWtlXSB0aGUgc3RyaWtlIHByaWNlIG9mIGFuIG9wdGlvbi4gVGhlIHByaWNlIGF0IHdoaWNoIGFuIG9wdGlvbiBidXllciBjYW4gYnV5IChpbiBhXG4gICAqIENhbGwgb3B0aW9uKSBvciBzZWxsIChpbiBhIFB1dCBvcHRpb24pIHRoZSB1bmRlcmx5aW5nIGFzc2V0LCBhbmQgdGhlIG9wdGlvbiBzZWxsZXIgaXMgb2JsaWdlZCB0byBzZWxsIG9yIGJ1eSB0aGVcbiAgICogYXBwcm9wcmlhdGUgYW1vdW50IG9mIHRoZSB1bmRlcmx5aW5nIGFzc2V0LlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW29wdGlvblByaWNlU2Vuc2l2aXR5XSBvcHRpb24vd2FycmFudCBzZW5zaXRpdml0eSBzaG93cyBieSBob3cgbWFueSBwb2ludHMgdGhlIHByaWNlIG9mIHRoZVxuICAgKiBvcHRpb24ncyB1bmRlcmx5aW5nIGFzc2V0IHNob3VsZCBjaGFuZ2Ugc28gdGhhdCB0aGUgcHJpY2Ugb2YgdGhlIG9wdGlvbiBjaGFuZ2VzIGJ5IG9uZSBwb2ludFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW2xpcXVpZGl0eVJhdGVdIGxpcXVpZGl0eSBSYXRlIGlzIHRoZSBzaGFyZSBvZiB0aGUgYXNzZXQgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIG1hcmdpblxuICAgKiBAcHJvcGVydHkge051bWJlcn0gaW5pdGlhbE1hcmdpbiBpbml0aWFsIG1hcmdpbiBtZWFucyB0aGUgYW1vdW50IGluIHRoZSBtYXJnaW4gY3VycmVuY3kgcmVxdWlyZWQgZm9yIG9wZW5pbmcgYVxuICAgKiBwb3NpdGlvbiB3aXRoIHRoZSB2b2x1bWUgb2Ygb25lIGxvdC4gSXQgaXMgdXNlZCBmb3IgY2hlY2tpbmcgYSBjbGllbnQncyBhc3NldHMgd2hlbiBoZSBvciBzaGUgZW50ZXJzIHRoZSBtYXJrZXRcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IG1haW50ZW5hbmNlTWFyZ2luIHRoZSBtYWludGVuYW5jZSBtYXJnaW4uIElmIGl0IGlzIHNldCwgaXQgc2V0cyB0aGUgbWFyZ2luIGFtb3VudCBpbiB0aGUgbWFyZ2luXG4gICAqIGN1cnJlbmN5IG9mIHRoZSBzeW1ib2wsIGNoYXJnZWQgZnJvbSBvbmUgbG90LiBJdCBpcyB1c2VkIGZvciBjaGVja2luZyBhIGNsaWVudCdzIGFzc2V0cyB3aGVuIGhpcy9oZXIgYWNjb3VudCBzdGF0ZVxuICAgKiBjaGFuZ2VzLiBJZiB0aGUgbWFpbnRlbmFuY2UgbWFyZ2luIGlzIGVxdWFsIHRvIDAsIHRoZSBpbml0aWFsIG1hcmdpbiBpcyB1c2VkXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBoZWRnZWRNYXJnaW4gY29udHJhY3Qgc2l6ZSBvciBtYXJnaW4gdmFsdWUgcGVyIG9uZSBsb3Qgb2YgaGVkZ2VkIHBvc2l0aW9ucyAob3Bwb3NpdGVseSBkaXJlY3RlZFxuICAgKiBwb3NpdGlvbnMgb2Ygb25lIHN5bWJvbCkuIFR3byBtYXJnaW4gY2FsY3VsYXRpb24gbWV0aG9kcyBhcmUgcG9zc2libGUgZm9yIGhlZGdlZCBwb3NpdGlvbnMuIFRoZSBjYWxjdWxhdGlvbiBtZXRob2RcbiAgICogaXMgZGVmaW5lZCBieSB0aGUgYnJva2VyXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2hlZGdlZE1hcmdpblVzZXNMYXJnZXJMZWddIGNhbGN1bGF0aW5nIGhlZGdpbmcgbWFyZ2luIHVzaW5nIHRoZSBsYXJnZXIgbGVnIChCdXkgb3IgU2VsbClcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG1hcmdpbkN1cnJlbmN5IG1hcmdpbiBjdXJyZW5jeVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gcHJpY2VDYWxjdWxhdGlvbk1vZGUgY29udHJhY3QgcHJpY2UgY2FsY3VsYXRpb24gbW9kZS4gT25lIG9mIFNZTUJPTF9DQUxDX01PREVfVU5LTk9XTixcbiAgICogU1lNQk9MX0NBTENfTU9ERV9GT1JFWCwgU1lNQk9MX0NBTENfTU9ERV9GT1JFWF9OT19MRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9GVVRVUkVTLCBTWU1CT0xfQ0FMQ19NT0RFX0NGRCxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9DRkRJTkRFWCwgU1lNQk9MX0NBTENfTU9ERV9DRkRMRVZFUkFHRSwgU1lNQk9MX0NBTENfTU9ERV9FWENIX1NUT0NLUyxcbiAgICogU1lNQk9MX0NBTENfTU9ERV9FWENIX0ZVVFVSRVMsIFNZTUJPTF9DQUxDX01PREVfRVhDSF9GVVRVUkVTX0ZPUlRTLCBTWU1CT0xfQ0FMQ19NT0RFX0VYQ0hfQk9ORFMsXG4gICAqIFNZTUJPTF9DQUxDX01PREVfRVhDSF9TVE9DS1NfTU9FWCwgU1lNQk9MX0NBTENfTU9ERV9FWENIX0JPTkRTX01PRVgsIFNZTUJPTF9DQUxDX01PREVfU0VSVl9DT0xMQVRFUkFMLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9jYWxjX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYmFzZUN1cnJlbmN5IGJhc2UgY3VycmVuY3lcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtwcm9maXRDdXJyZW5jeV0gcHJvZml0IGN1cnJlbmN5XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzd2FwTW9kZSBzd2FwIGNhbGN1bGF0aW9uIG1vZGVsLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX1NXQVBfTU9ERV9ESVNBQkxFRCxcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9QT0lOVFMsIFNZTUJPTF9TV0FQX01PREVfQ1VSUkVOQ1lfU1lNQk9MLCBTWU1CT0xfU1dBUF9NT0RFX0NVUlJFTkNZX01BUkdJTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9DVVJSRU5DWV9ERVBPU0lULCBTWU1CT0xfU1dBUF9NT0RFX0lOVEVSRVNUX0NVUlJFTlQsIFNZTUJPTF9TV0FQX01PREVfSU5URVJFU1RfT1BFTixcbiAgICogU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQ1VSUkVOVCwgU1lNQk9MX1NXQVBfTU9ERV9SRU9QRU5fQklELiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9zd2FwX21vZGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgKiBAcHJvcGVydHkge051bWJlcn0gW3N3YXBMb25nXSBsb25nIHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzd2FwU2hvcnRdIHNob3J0IHN3YXAgdmFsdWVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtzd2FwUm9sbG92ZXIzRGF5c10gZGF5IG9mIHdlZWsgdG8gY2hhcmdlIDMgZGF5cyBzd2FwIHJvbGxvdmVyLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1VOREFZLFxuICAgKiBNT05EQVksIFRVRVNEQVksIFdFRE5FU0RBWSwgVEhVUkRBWSwgRlJJREFZLCBTQVRVUkRBWSwgTk9ORVxuICAgKiBAcHJvcGVydHkge0FycmF5PFN0cmluZz59IGFsbG93ZWRFeHBpcmF0aW9uTW9kZXMgYWxsb3dlZCBvcmRlciBleHBpcmF0aW9uIG1vZGVzLiBBbGxvd2VkIHZhbHVlcyBhcmVcbiAgICogU1lNQk9MX0VYUElSQVRJT05fR1RDLCBTWU1CT0xfRVhQSVJBVElPTl9EQVksIFNZTUJPTF9FWFBJUkFUSU9OX1NQRUNJRklFRCwgU1lNQk9MX0VYUElSQVRJT05fU1BFQ0lGSUVEX0RBWS5cbiAgICogU2VlIGh0dHBzOi8vd3d3Lm1xbDUuY29tL2VuL2RvY3MvY29uc3RhbnRzL2Vudmlyb25tZW50X3N0YXRlL21hcmtldGluZm9jb25zdGFudHMjc3ltYm9sX2V4cGlyYXRpb25fbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8U3RyaW5nPn0gYWxsb3dlZE9yZGVyVHlwZXMgYWxsb3dlZCBvcmRlciB0eXBlcy4gQWxsb3dlZCB2YWx1ZXMgYXJlIFNZTUJPTF9PUkRFUl9NQVJLRVQsXG4gICAqIFNZTUJPTF9PUkRFUl9MSU1JVCwgU1lNQk9MX09SREVSX1NUT1AsIFNZTUJPTF9PUkRFUl9TVE9QX0xJTUlULCBTWU1CT0xfT1JERVJfU0wsIFNZTUJPTF9PUkRFUl9UUCxcbiAgICogU1lNQk9MX09SREVSX0NMT1NFQlkuIFNlZVxuICAgKiBodHRwczovL3d3dy5tcWw1LmNvbS9lbi9kb2NzL2NvbnN0YW50cy9lbnZpcm9ubWVudF9zdGF0ZS9tYXJrZXRpbmZvY29uc3RhbnRzI3N5bWJvbF9vcmRlcl9tb2RlIGZvciBtb3JlIGRldGFpbHNcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IG9yZGVyR1RDTW9kZSBpZiB0aGUgZXhwaXJhdGlvbk1vZGUgcHJvcGVydHkgaXMgc2V0IHRvIFNZTUJPTF9FWFBJUkFUSU9OX0dUQyAoZ29vZCB0aWxsXG4gICAqIGNhbmNlbGVkKSwgdGhlIGV4cGlyYXRpb24gb2YgcGVuZGluZyBvcmRlcnMsIGFzIHdlbGwgYXMgb2YgU3RvcCBMb3NzL1Rha2UgUHJvZml0IG9yZGVycyBzaG91bGQgYmUgYWRkaXRpb25hbGx5IHNldFxuICAgKiB1c2luZyB0aGlzIGVudW1lcmF0aW9uLiBBbGxvd2VkIHZhbHVlcyBhcmUgU1lNQk9MX09SREVSU19HVEMsIFNZTUJPTF9PUkRFUlNfREFJTFksXG4gICAqIFNZTUJPTF9PUkRFUlNfREFJTFlfRVhDTFVESU5HX1NUT1BTLiBTZWVcbiAgICogaHR0cHM6Ly93d3cubXFsNS5jb20vZW4vZG9jcy9jb25zdGFudHMvZW52aXJvbm1lbnRfc3RhdGUvbWFya2V0aW5mb2NvbnN0YW50cyNlbnVtX3N5bWJvbF9vcmRlcl9ndGNfbW9kZSBmb3IgbW9yZVxuICAgKiBkZXRhaWxzXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkaWdpdHMgZGlnaXRzIGFmdGVyIGEgZGVjaW1hbCBwb2ludFxuICAgKiBAcHJvcGVydHkge051bWJlcn0gcG9pbnQgcG9pbnQgc2l6ZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3BhdGhdIHBhdGggaW4gdGhlIHN5bWJvbCB0cmVlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkZXNjcmlwdGlvbiBzeW1ib2wgZGVzY3JpcHRpb25cbiAgICogQHByb3BlcnR5IHtEYXRlfSBbc3RhcnRUaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgYmVnaW5uaW5nICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gW2V4cGlyYXRpb25UaW1lXSBkYXRlIG9mIHRoZSBzeW1ib2wgdHJhZGUgZW5kICh1c3VhbGx5IHVzZWQgZm9yIGZ1dHVyZXMpXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGlwU2l6ZV0gc2l6ZSBvZiBhIHBpcC4gUGlwIHNpemUgaXMgZGVmaW5lZCBmb3Igc3BvdCBhbmQgQ0ZEIHN5bWJvbHMgb25seVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RvcHNMZXZlbCBtaW5pbWFsIGRpc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgbWFya2V0IHByaWNlIHRvIHN0b3AgcHJpY2UgKFNMLCBUUCwgb3BlbiBwcmljZSkgaW5cbiAgICogcG9pbnRzLiBUaGUgU0wsIFRQLCBvcGVuIHByaWNlIGNhbiBub3QgYmUgcGxhY2VkIGNsb3NlciB0byBtYXJrZXQgcHJpY2UgdGhhbiB0aGlzIGRpc3RhbmNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmVlemVMZXZlbCBkaXN0YW5jZSBpbiBwb2ludHMgZnJvbSBtYXJrZXQgcHJpY2UgdG8gcGVuZGluZyBvcmRlciBvcGVuIHByaWNlIHRvIGZyZWV6ZSB1cGRhdGVzXG4gICAqIG9uIHRoZSBwZW5kaW5nIG9yZGVyLiBJZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBvcmRlciBvcGVuIHByaWNlIGFuZCBjdXJyZW50IG1hcmtldCBwcmljZSBpcyBsZXNzIHRoYW4gdGhpcyB2YWx1ZSxcbiAgICogdGhlbiB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIG1vZGlmeSB0aGUgcGVuZGluZyBvcmRlclxuICAgKi9cblxuICAvKipcbiAgICogTWV0YXRyYWRlciB0cmFkZSBvciBxdW90ZSBzZXNzaW9uIGNvbnRhaW5lciwgaW5kZXhlZCBieSB3ZWVrZGF5XG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJTZXNzaW9uc1xuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1NVTkRBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIFNVTkRBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW01PTkRBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIE1PTkRBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1RVRVNEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBUVUVTREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbV0VETkVTREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgV0VETkVTREFZXG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlclNlc3Npb24+fSBbVEhVUlNEQVldIGFycmF5IG9mIHNlc3Npb25zIGZvciBUSFVSU0RBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW0ZSSURBWV0gYXJyYXkgb2Ygc2Vzc2lvbnMgZm9yIEZSSURBWVxuICAgKiBAcHJvcGVydHkge0FycmF5PE1ldGF0cmFkZXJTZXNzaW9uPn0gW1NBVFVSREFZXSBhcnJheSBvZiBzZXNzaW9ucyBmb3IgU0FUVVJEQVlcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGF0cmFkZXIgdHJhZGUgb3IgcXVvdGUgc2Vzc2lvblxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyU2Vzc2lvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gZnJvbSBzZXNzaW9uIHN0YXJ0IHRpbWUsIGluIGhoLm1tLnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IHRvIHNlc3Npb24gZW5kIHRpbWUsIGluIGhoLm1tLnNzLlNTUyBmb3JtYXRcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgc3ltYm9sIHByaWNlLiBDb250YWlucyBjdXJyZW50IHByaWNlIGZvciBhIHN5bWJvbCAoc2VlXG4gICAqIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9tb2RlbHMvbWV0YXRyYWRlclN5bWJvbFByaWNlLylcbiAgICogQHR5cGVkZWYge09iamVjdH0gTWV0YXRyYWRlclN5bWJvbFByaWNlXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGEgY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGJpZCBiaWQgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzayBhc2sgcHJpY2VcbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByb2ZpdFRpY2tWYWx1ZSB0aWNrIHZhbHVlIGZvciBhIHByb2ZpdGFibGUgcG9zaXRpb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGxvc3NUaWNrVmFsdWUgdGljayB2YWx1ZSBmb3IgYSBsb3NpbmcgcG9zaXRpb25cbiAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFthY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGVdIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBvZiBhY2NvdW50IGN1cnJlbmN5IGludG8gYWNjb3VudCBiYXNlXG4gICAqIGN1cnJlbmN5IChVU0QgaWYgeW91IGRpZCBub3Qgb3ZlcnJpZGUgaXQpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSBxdW90ZSB0aW1lLCBpbiBJU08gZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBicm9rZXJUaW1lIHRpbWUgcXVvdGUgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgY2FuZGxlXG4gICAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGF0cmFkZXJDYW5kbGVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRpbWVmcmFtZSB0aW1lZnJhbWUgY2FuZGxlIHdhcyBnZW5lcmF0ZWQgZm9yLCBlLmcuIDFoLiBPbmUgb2YgMW0sIDJtLCAzbSwgNG0sIDVtLCA2bSwgMTBtLCAxMm0sXG4gICAqIDE1bSwgMjBtLCAzMG0sIDFoLCAyaCwgM2gsIDRoLCA2aCwgOGgsIDEyaCwgMWQsIDF3LCAxbW5cbiAgICogQHByb3BlcnR5IHtEYXRlfSB0aW1lIGNhbmRsZSBvcGVuaW5nIHRpbWVcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJyb2tlclRpbWUgY2FuZGxlIG9wZW5pbmcgdGltZSwgaW4gYnJva2VyIHRpbWV6b25lLCBZWVlZLU1NLUREIEhIOm1tOnNzLlNTUyBmb3JtYXRcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IG9wZW4gb3BlbiBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBoaWdoIHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgbG93IHByaWNlXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjbG9zZSBjbG9zZSBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gdGlja1ZvbHVtZSB0aWNrIHZvbHVtZSwgaS5lLiBudW1iZXIgb2YgdGlja3MgaW5zaWRlIHRoZSBjYW5kbGVcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNwcmVhZCBzcHJlYWQgaW4gcG9pbnRzXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2b2x1bWUgdHJhZGUgdm9sdW1lXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRhVHJhZGVyIHRpY2sgZGF0YVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyVGlja1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBicm9rZXJUaW1lIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmlkXSBiaWQgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IFthc2tdIGFzayBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW2xhc3RdIGxhc3QgZGVhbCBwcmljZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZvbHVtZV0gdm9sdW1lIGZvciB0aGUgY3VycmVudCBsYXN0IGRlYWwgcHJpY2VcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZGUgaXMgdGljayBhIHJlc3VsdCBvZiBidXkgb3Igc2VsbCBkZWFsLCBvbmUgb2YgYnV5IG9yIHNlbGxcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgb3JkZXIgYm9va1xuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyQm9va1xuICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBhIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEBwcm9wZXJ0eSB7RGF0ZX0gdGltZSB0aW1lXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBicm9rZXJUaW1lIHRpbWUsIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqIEBwcm9wZXJ0eSB7QXJyYXk8TWV0YXRyYWRlckJvb2tFbnRyeT59IGJvb2sgbGlzdCBvZiBvcmRlciBib29rIGVudHJpZXNcbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGFUcmFkZXIgb3JkZXIgYm9vayBlbnRyeVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBNZXRhdHJhZGVyQm9va0VudHJ5XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIGVudHJ5IHR5cGUsIG9uZSBvZiBCT09LX1RZUEVfU0VMTCwgQk9PS19UWVBFX0JVWSwgQk9PS19UWVBFX1NFTExfTUFSS0VULFxuICAgKiBCT09LX1RZUEVfQlVZX01BUktFVFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcHJpY2UgcHJpY2VcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZvbHVtZSB2b2x1bWVcbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksbWF4LXN0YXRlbWVudHNcbiAgYXN5bmMgX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnN0YW5jZU51bWJlciA9IGRhdGEuaW5zdGFuY2VJbmRleCB8fCAwO1xuICAgICAgY29uc3Qgc29ja2V0SW5zdGFuY2UgPSB0aGlzLl9nZXRTb2NrZXRJbnN0YW5jZUJ5QWNjb3VudChkYXRhLmFjY291bnRJZCwgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgc29ja2V0SW5zdGFuY2UpIHtcbiAgICAgICAgc29ja2V0SW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnVwZGF0ZVN5bmNocm9uaXphdGlvbklkKGRhdGEuc3luY2hyb25pemF0aW9uSWQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRBY2NvdW50UmVnaW9uKGRhdGEuYWNjb3VudElkKTtcbiAgICAgIGNvbnN0IHByaW1hcnlBY2NvdW50SWQgPSB0aGlzLl9hY2NvdW50c0J5UmVwbGljYUlkW2RhdGEuYWNjb3VudElkXTtcbiAgICAgIGxldCBpbnN0YW5jZUlkID0gcHJpbWFyeUFjY291bnRJZCArICc6JyArIHJlZ2lvbiArICc6JyArIGluc3RhbmNlTnVtYmVyICsgJzonICsgKGRhdGEuaG9zdCB8fCAwKTtcbiAgICAgIGxldCBpbnN0YW5jZUluZGV4ID0gcmVnaW9uICsgJzonICsgaW5zdGFuY2VOdW1iZXIgKyAnOicgKyAoZGF0YS5ob3N0IHx8IDApO1xuXG4gICAgICBjb25zdCBpc09ubHlBY3RpdmVJbnN0YW5jZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlSW5zdGFuY2VJZHMgPSBPYmplY3Qua2V5cyh0aGlzLl9jb25uZWN0ZWRIb3N0cykuZmlsdGVyKGluc3RhbmNlID0+IFxuICAgICAgICAgIGluc3RhbmNlLnN0YXJ0c1dpdGgocHJpbWFyeUFjY291bnRJZCArICc6JyArIHJlZ2lvbiArICc6JyArIGluc3RhbmNlTnVtYmVyKSk7XG4gICAgICAgIHJldHVybiAhYWN0aXZlSW5zdGFuY2VJZHMubGVuZ3RoIHx8IGFjdGl2ZUluc3RhbmNlSWRzLmxlbmd0aCA9PT0gMSAmJiBhY3RpdmVJbnN0YW5jZUlkc1swXSA9PT0gaW5zdGFuY2VJZDtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGNhbmNlbERpc2Nvbm5lY3RUaW1lciA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdGF0dXNUaW1lcnNbaW5zdGFuY2VJZF0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCByZXNldERpc2Nvbm5lY3RUaW1lciA9ICgpID0+IHtcbiAgICAgICAgY2FuY2VsRGlzY29ubmVjdFRpbWVyKCk7XG4gICAgICAgIHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGAke2RhdGEuYWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiB0aW1lZCBvdXQgd2FpdGluZyBmb3IgY29ubmVjdGlvbiBzdGF0dXNgKTtcbiAgICAgICAgICBpZiAoaXNPbmx5QWN0aXZlSW5zdGFuY2UoKSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5vblRpbWVvdXQoZGF0YS5hY2NvdW50SWQsIDApO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uTWFuYWdlci5vblRpbWVvdXQoZGF0YS5hY2NvdW50SWQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnF1ZXVlRXZlbnQocHJpbWFyeUFjY291bnRJZCwgYCR7aW5zdGFuY2VJbmRleH06b25EaXNjb25uZWN0ZWRgLCAoKSA9PiBvbkRpc2Nvbm5lY3RlZCh0cnVlKSk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3N0YXR1c1RpbWVyc1tpbnN0YW5jZUlkXSk7XG4gICAgICAgIH0sIDYwMDAwKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgICBjb25zdCBvbkRpc2Nvbm5lY3RlZCA9IGFzeW5jIChpc1RpbWVvdXQgPSBmYWxzZSkgPT4geyBcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3RlZEhvc3RzW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2Uub25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJZCk7XG4gICAgICAgICAgaWYgKGlzT25seUFjdGl2ZUluc3RhbmNlKCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25EaXNjb25uZWN0ZWQoaW5zdGFuY2VJbmRleCksXG4gICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkRpc2Nvbm5lY3RlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9wYWNrZXRPcmRlcmVyLm9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSWQpO1xuICAgICAgICAgIGlmIChzb2NrZXRJbnN0YW5jZSkge1xuICAgICAgICAgICAgc29ja2V0SW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnJlbW92ZUlkQnlQYXJhbWV0ZXJzKGRhdGEuYWNjb3VudElkLCBpbnN0YW5jZU51bWJlciwgZGF0YS5ob3N0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3RyZWFtQ2xvc2VkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb25uZWN0ZWRIb3N0c1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICBpZiAoaXNPbmx5QWN0aXZlSW5zdGFuY2UoKSAmJiAhaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uRGlzY29ubmVjdGVkKGRhdGEuYWNjb3VudElkLCAwKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIub25EaXNjb25uZWN0ZWQoZGF0YS5hY2NvdW50SWQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdhdXRoZW50aWNhdGVkJykge1xuICAgICAgICByZXNldERpc2Nvbm5lY3RUaW1lcigpO1xuICAgICAgICBpZiAoKCFkYXRhLnNlc3Npb25JZCkgfHwgc29ja2V0SW5zdGFuY2UgJiYgKGRhdGEuc2Vzc2lvbklkID09PSBzb2NrZXRJbnN0YW5jZS5zZXNzaW9uSWQpKSB7XG4gICAgICAgICAgdGhpcy5fbGF0ZW5jeVNlcnZpY2Uub25Db25uZWN0ZWQoaW5zdGFuY2VJZCk7XG4gICAgICAgICAgdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0gPSBkYXRhLmhvc3Q7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uQ29ubmVjdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEucmVwbGljYXMpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQ29ubmVjdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgIGlmIChkYXRhLnJlcGxpY2FzID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmNhbmNlbEFjY291bnQoZGF0YS5hY2NvdW50SWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLmNhbmNlbFN1YnNjcmliZShkYXRhLmFjY291bnRJZCArICc6JyArIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICBjYW5jZWxEaXNjb25uZWN0VGltZXIoKTtcbiAgICAgICAgYXdhaXQgb25EaXNjb25uZWN0ZWQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSAnc3luY2hyb25pemF0aW9uU3RhcnRlZCcpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlRXZlbnRzW2luc3RhbmNlSWRdID0gW107XG4gICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdID0ge1xuICAgICAgICAgIGFjY291bnRJZDogZGF0YS5hY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLFxuICAgICAgICAgIHNwZWNpZmljYXRpb25zVXBkYXRlZDogZGF0YS5zcGVjaWZpY2F0aW9uc0hhc2hJbmRleCA9PT0gdW5kZWZpbmVkLFxuICAgICAgICAgIHBvc2l0aW9uc1VwZGF0ZWQ6IGRhdGEucG9zaXRpb25zSGFzaEluZGV4ID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgb3JkZXJzVXBkYXRlZDogZGF0YS5vcmRlcnNIYXNoSW5kZXggPT09IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0gPSBkYXRhLnN5bmNocm9uaXphdGlvbklkO1xuICAgICAgICBjb25zdCBzcGVjaWZpY2F0aW9uc0hhc2ggPSAoZGF0YS5zcGVjaWZpY2F0aW9uc0hhc2hJbmRleCAhPT0gdW5kZWZpbmVkKSA/IFxuICAgICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJiBcbiAgICAgICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25IYXNoZXNbZGF0YS5zeW5jaHJvbml6YXRpb25JZF1cbiAgICAgICAgICAgIC5zcGVjaWZpY2F0aW9uc0hhc2hlc1tkYXRhLnNwZWNpZmljYXRpb25zSGFzaEluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zSGFzaCA9IChkYXRhLnBvc2l0aW9uc0hhc2hJbmRleCAhPT0gdW5kZWZpbmVkKSA/IFxuICAgICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJiBcbiAgICAgICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25IYXNoZXNbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ucG9zaXRpb25zSGFzaGVzW2RhdGEucG9zaXRpb25zSGFzaEluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3JkZXJzSGFzaCA9IChkYXRhLm9yZGVyc0hhc2hJbmRleCAhPT0gdW5kZWZpbmVkKSA/IFxuICAgICAgICAgIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJiBcbiAgICAgICAgICB0aGlzLl9zeW5jaHJvbml6YXRpb25IYXNoZXNbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzSGFzaGVzW2RhdGEub3JkZXJzSGFzaEluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbkhhc2hlc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXTtcbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25TeW5jaHJvbml6YXRpb25TdGFydGVkKGluc3RhbmNlSW5kZXgsIHNwZWNpZmljYXRpb25zSGFzaCxcbiAgICAgICAgICAgICAgcG9zaXRpb25zSGFzaCwgb3JkZXJzSGFzaCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3luY2hyb25pemF0aW9uU3RhcnRlZGApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ2FjY291bnRJbmZvcm1hdGlvbicpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmFjY291bnRJbmZvcm1hdGlvbikge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZChpbnN0YW5jZUluZGV4LCBkYXRhLmFjY291bnRJbmZvcm1hdGlvbiksXG4gICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRgLCB0cnVlKTtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgICBpZiAodGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ucG9zaXRpb25zVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25zU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBvc2l0aW9uc1N5bmNocm9uaXplZGAsIHRydWUpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtZGVwdGhcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdLm9yZGVyc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZGAsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcihgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9OiBGYWlsZWQgdG8gbm90aWZ5IGxpc3RlbmVyIGAgK1xuICAgICAgICAgICAgICAgICdhYm91dCBhY2NvdW50SW5mb3JtYXRpb24gZXZlbnQnLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0gJiYgXG4gICAgICAgICAgICAgICF0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXS5wb3NpdGlvbnNVcGRhdGVkICYmIFxuICAgICAgICAgICAgICAhdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW2RhdGEuc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkZWFscycpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGRlYWwgb2YgKGRhdGEuZGVhbHMgfHwgW10pKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uRGVhbEFkZGVkKGluc3RhbmNlSW5kZXgsIGRlYWwpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uRGVhbEFkZGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ29yZGVycycpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkKGluc3RhbmNlSW5kZXgsIGRhdGEub3JkZXJzIHx8IFtdKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBlbmRpbmdPcmRlcnNSZXBsYWNlZGAsIHRydWUpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgJ2Fib3V0IG9yZGVycyBldmVudCcsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdoaXN0b3J5T3JkZXJzJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaGlzdG9yeU9yZGVyIG9mIChkYXRhLmhpc3RvcnlPcmRlcnMgfHwgW10pKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uSGlzdG9yeU9yZGVyQWRkZWQoaW5zdGFuY2VJbmRleCwgaGlzdG9yeU9yZGVyKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhpc3RvcnlPcmRlckFkZGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3Bvc2l0aW9ucycpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25zUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5wb3NpdGlvbnMgfHwgW10pLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25zUmVwbGFjZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Qb3NpdGlvbnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zeW5jaHJvbml6YXRpb25JZCksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25Qb3NpdGlvbnNTeW5jaHJvbml6ZWRgLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJlxuICAgICAgICAgICAgICAhdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTogRmFpbGVkIHRvIG5vdGlmeSBsaXN0ZW5lciBgICtcbiAgICAgICAgICAgICAgJ2Fib3V0IHBvc2l0aW9ucyBldmVudCcsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXSAmJiBcbiAgICAgICAgICAhdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3NbZGF0YS5zeW5jaHJvbml6YXRpb25JZF0ub3JkZXJzVXBkYXRlZCkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25GbGFnc1tkYXRhLnN5bmNocm9uaXphdGlvbklkXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICd1cGRhdGUnKSB7XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVFdmVudHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVFdmVudHNbaW5zdGFuY2VJZF0ucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5hY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGRhdGEuYWNjb3VudEluZm9ybWF0aW9uKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZFBvc2l0aW9ucyA9IGRhdGEudXBkYXRlZFBvc2l0aW9ucyB8fCBbXTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZFBvc2l0aW9uSWRzID0gZGF0YS5yZW1vdmVkUG9zaXRpb25JZHMgfHwgW107XG4gICAgICAgIGlmICh1cGRhdGVkUG9zaXRpb25zLmxlbmd0aCB8fCByZW1vdmVkUG9zaXRpb25JZHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCB1cGRhdGVkUG9zaXRpb25zLCByZW1vdmVkUG9zaXRpb25JZHMpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uUG9zaXRpb25zVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbiBvZiB1cGRhdGVkUG9zaXRpb25zKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUG9zaXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIHBvc2l0aW9uKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBvc2l0aW9uVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwb3NpdGlvbklkIG9mIHJlbW92ZWRQb3NpdGlvbklkcykge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblBvc2l0aW9uUmVtb3ZlZChpbnN0YW5jZUluZGV4LCBwb3NpdGlvbklkKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblBvc2l0aW9uUmVtb3ZlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVkT3JkZXJzID0gZGF0YS51cGRhdGVkT3JkZXJzIHx8IFtdO1xuICAgICAgICBjb25zdCBjb21wbGV0ZWRPcmRlcklkcyA9IGRhdGEuY29tcGxldGVkT3JkZXJJZHMgfHwgW107XG4gICAgICAgIGlmICh1cGRhdGVkT3JkZXJzLmxlbmd0aCB8fCBjb21wbGV0ZWRPcmRlcklkcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJzVXBkYXRlZChpbnN0YW5jZUluZGV4LCB1cGRhdGVkT3JkZXJzLCBjb21wbGV0ZWRPcmRlcklkcyksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJzVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBvcmRlciBvZiB1cGRhdGVkT3JkZXJzKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uUGVuZGluZ09yZGVyVXBkYXRlZChpbnN0YW5jZUluZGV4LCBvcmRlciksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJVcGRhdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG9yZGVySWQgb2YgY29tcGxldGVkT3JkZXJJZHMpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25QZW5kaW5nT3JkZXJDb21wbGV0ZWQoaW5zdGFuY2VJbmRleCwgb3JkZXJJZCksXG4gICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25QZW5kaW5nT3JkZXJDb21wbGV0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaGlzdG9yeU9yZGVyIG9mIChkYXRhLmhpc3RvcnlPcmRlcnMgfHwgW10pKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uSGlzdG9yeU9yZGVyQWRkZWQoaW5zdGFuY2VJbmRleCwgaGlzdG9yeU9yZGVyKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhpc3RvcnlPcmRlckFkZGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGRlYWwgb2YgKGRhdGEuZGVhbHMgfHwgW10pKSB7XG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uRGVhbEFkZGVkKGluc3RhbmNlSW5kZXgsIGRlYWwpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uRGVhbEFkZGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnRpbWVzdGFtcHMpIHtcbiAgICAgICAgICBkYXRhLnRpbWVzdGFtcHMuY2xpZW50UHJvY2Vzc2luZ0ZpbmlzaGVkID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fbGF0ZW5jeUxpc3RlbmVycyB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblVwZGF0ZShkYXRhLmFjY291bnRJZCwgZGF0YS50aW1lc3RhbXBzKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblVwZGF0ZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkZWFsU3luY2hyb25pemF0aW9uRmluaXNoZWQnKSB7XG4gICAgICAgIGlmIChkYXRhLnN5bmNocm9uaXphdGlvbklkICYmIGRhdGEuc3luY2hyb25pemF0aW9uSWQgIT09IHRoaXMuX3N5bmNocm9uaXphdGlvbklkQnlJbnN0YW5jZVtpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF07XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhdGVuY3lTZXJ2aWNlLm9uRGVhbHNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJZCk7XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIGlmIChzb2NrZXRJbnN0YW5jZSkge1xuICAgICAgICAgICAgc29ja2V0SW5zdGFuY2Uuc3luY2hyb25pemF0aW9uVGhyb3R0bGVyLnJlbW92ZVN5bmNocm9uaXphdGlvbklkKGRhdGEuc3luY2hyb25pemF0aW9uSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkRlYWxzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkRlYWxzU3luY2hyb25pemVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXSkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXSA9IHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXS5tYXAocGFja2V0ID0+ICgpID0+IFxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQocGFja2V0KSkpO1xuICAgICAgICAgIGlmICh0aGlzLl9ldmVudFF1ZXVlc1twcmltYXJ5QWNjb3VudElkXSkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZXNbcHJpbWFyeUFjY291bnRJZF0gPVxuICAgICAgICAgICAgICB0aGlzLl91cGRhdGVFdmVudHNbaW5zdGFuY2VJZF0uY29uY2F0KHRoaXMuX2V2ZW50UXVldWVzW3ByaW1hcnlBY2NvdW50SWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl91cGRhdGVFdmVudHNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50UXVldWVzW3ByaW1hcnlBY2NvdW50SWRdID0gdGhpcy5fdXBkYXRlRXZlbnRzW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3VwZGF0ZUV2ZW50c1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxBY2NvdW50RXZlbnRzKHByaW1hcnlBY2NvdW50SWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdvcmRlclN5bmNocm9uaXphdGlvbkZpbmlzaGVkJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIGRhdGEuc3luY2hyb25pemF0aW9uSWQpLFxuICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhpc3RvcnlPcmRlcnNTeW5jaHJvbml6ZWRgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdzdGF0dXMnKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkSG9zdHNbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICBpZiAodGhpcy5fc3RhdHVzVGltZXJzW2luc3RhbmNlSWRdICYmIGRhdGEuYXV0aGVudGljYXRlZCAmJiBcbiAgICAgICAgICAgICAgKHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuaXNEaXNjb25uZWN0ZWRSZXRyeU1vZGUoZGF0YS5hY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB8fCBcbiAgICAgICAgICAgICAgIXRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuaXNBY2NvdW50U3Vic2NyaWJpbmcoZGF0YS5hY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbk1hbmFnZXIuY2FuY2VsU3Vic2NyaWJlKGRhdGEuYWNjb3VudElkICsgJzonICsgaW5zdGFuY2VOdW1iZXIpO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMCkpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKCdpdCBzZWVtcyBsaWtlIHdlIGFyZSBub3QgY29ubmVjdGVkIHRvIGEgcnVubmluZyBBUEkgJyArXG4gICAgICAgICAgICAgICdzZXJ2ZXIgeWV0LCByZXRyeWluZyBzdWJzY3JpcHRpb24gZm9yIGFjY291bnQgJyArIGluc3RhbmNlSWQpO1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVTdWJzY3JpYmUoZGF0YS5hY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXREaXNjb25uZWN0VGltZXIoKTtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Ccm9rZXJDb25uZWN0aW9uU3RhdHVzQ2hhbmdlZChpbnN0YW5jZUluZGV4LCAhIWRhdGEuY29ubmVjdGVkKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLmhlYWx0aFN0YXR1cykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1kZXB0aFxuICAgICAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vbkhlYWx0aFN0YXR1cyhpbnN0YW5jZUluZGV4LCBkYXRhLmhlYWx0aFN0YXR1cyksXG4gICAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkhlYWx0aFN0YXR1c2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdkb3duZ3JhZGVTdWJzY3JpcHRpb24nKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci5pbmZvKGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06IE1hcmtldCBkYXRhIHN1YnNjcmlwdGlvbnMgZm9yIHN5bWJvbCBgICtcbiAgICAgICAgICBgJHtkYXRhLnN5bWJvbH0gd2VyZSBkb3duZ3JhZGVkIGJ5IHRoZSBzZXJ2ZXIgZHVlIHRvIHJhdGUgbGltaXRzLiBVcGRhdGVkIHN1YnNjcmlwdGlvbnM6IGAgK1xuICAgICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGRhdGEudXBkYXRlcyl9LCByZW1vdmVkIHN1YnNjcmlwdGlvbnM6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YS51bnN1YnNjcmlwdGlvbnMpfS4gYCArXG4gICAgICAgICAgJ1BsZWFzZSByZWFkIGh0dHBzOi8vbWV0YWFwaS5jbG91ZC9kb2NzL2NsaWVudC9yYXRlTGltaXRpbmcvIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZChpbnN0YW5jZUluZGV4LCBkYXRhLnN5bWJvbCwgZGF0YS51cGRhdGVzLCBkYXRhLnVuc3Vic2NyaXB0aW9ucyksXG4gICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3Vic2NyaXB0aW9uRG93bmdyYWRlZGApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3NwZWNpZmljYXRpb25zJykge1xuICAgICAgICBpZiAoZGF0YS5zeW5jaHJvbml6YXRpb25JZCAmJiBkYXRhLnN5bmNocm9uaXphdGlvbklkICE9PSB0aGlzLl9zeW5jaHJvbml6YXRpb25JZEJ5SW5zdGFuY2VbaW5zdGFuY2VJZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fc3luY2hyb25pemF0aW9uTGlzdGVuZXJzW3ByaW1hcnlBY2NvdW50SWRdIHx8IFtdKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgZGF0YS5zcGVjaWZpY2F0aW9ucyB8fCBbXSxcbiAgICAgICAgICAgICAgZGF0YS5yZW1vdmVkU3ltYm9scyB8fCBbXSksIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzcGVjaWZpY2F0aW9uIG9mIChkYXRhLnNwZWNpZmljYXRpb25zIHx8IFtdKSkge1xuICAgICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bWJvbFNwZWNpZmljYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIHNwZWNpZmljYXRpb24pLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcmVtb3ZlZFN5bWJvbCBvZiAoZGF0YS5yZW1vdmVkU3ltYm9scyB8fCBbXSkpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZChpbnN0YW5jZUluZGV4LCByZW1vdmVkU3ltYm9sKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFNwZWNpZmljYXRpb25SZW1vdmVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3ByaWNlcycpIHtcbiAgICAgICAgaWYgKGRhdGEuc3luY2hyb25pemF0aW9uSWQgJiYgZGF0YS5zeW5jaHJvbml6YXRpb25JZCAhPT0gdGhpcy5fc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlW2luc3RhbmNlSWRdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZXMgPSBkYXRhLnByaWNlcyB8fCBbXTtcbiAgICAgICAgbGV0IGNhbmRsZXMgPSBkYXRhLmNhbmRsZXMgfHwgW107XG4gICAgICAgIGxldCB0aWNrcyA9IGRhdGEudGlja3MgfHwgW107XG4gICAgICAgIGxldCBib29rcyA9IGRhdGEuYm9va3MgfHwgW107XG4gICAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX3N5bmNocm9uaXphdGlvbkxpc3RlbmVyc1twcmltYXJ5QWNjb3VudElkXSB8fCBbXSkge1xuICAgICAgICAgIGlmIChwcmljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uU3ltYm9sUHJpY2VzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBwcmljZXMsIGRhdGEuZXF1aXR5LCBkYXRhLm1hcmdpbiwgZGF0YS5mcmVlTWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEubWFyZ2luTGV2ZWwsIGRhdGEuYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvblN5bWJvbFByaWNlc1VwZGF0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbmRsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICgpID0+IGxpc3RlbmVyLm9uQ2FuZGxlc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgY2FuZGxlcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLCBkYXRhLmZyZWVNYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uQ2FuZGxlc1VwZGF0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRpY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblRpY2tzVXBkYXRlZChpbnN0YW5jZUluZGV4LCB0aWNrcywgZGF0YS5lcXVpdHksIGRhdGEubWFyZ2luLCBkYXRhLmZyZWVNYXJnaW4sXG4gICAgICAgICAgICAgICAgZGF0YS5tYXJnaW5MZXZlbCwgZGF0YS5hY2NvdW50Q3VycmVuY3lFeGNoYW5nZVJhdGUpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uVGlja3NVcGRhdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChib29rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25Cb29rc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgYm9va3MsIGRhdGEuZXF1aXR5LCBkYXRhLm1hcmdpbiwgZGF0YS5mcmVlTWFyZ2luLFxuICAgICAgICAgICAgICAgIGRhdGEubWFyZ2luTGV2ZWwsIGRhdGEuYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlKSxcbiAgICAgICAgICAgICAgYCR7cHJpbWFyeUFjY291bnRJZH06JHtpbnN0YW5jZUluZGV4fTpvbkJvb2tzVXBkYXRlZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcmljZSBvZiBwcmljZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9zeW5jaHJvbml6YXRpb25MaXN0ZW5lcnNbcHJpbWFyeUFjY291bnRJZF0gfHwgW10pIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgKCkgPT4gbGlzdGVuZXIub25TeW1ib2xQcmljZVVwZGF0ZWQoaW5zdGFuY2VJbmRleCwgcHJpY2UpLFxuICAgICAgICAgICAgICBgJHtwcmltYXJ5QWNjb3VudElkfToke2luc3RhbmNlSW5kZXh9Om9uU3ltYm9sUHJpY2VVcGRhdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByaWNlIG9mIHByaWNlcykge1xuICAgICAgICAgIGlmIChwcmljZS50aW1lc3RhbXBzKSB7XG4gICAgICAgICAgICBwcmljZS50aW1lc3RhbXBzLmNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWRlcHRoXG4gICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiB0aGlzLl9sYXRlbmN5TGlzdGVuZXJzIHx8IFtdKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Byb2Nlc3NFdmVudChcbiAgICAgICAgICAgICAgICAoKSA9PiBsaXN0ZW5lci5vblN5bWJvbFByaWNlKGRhdGEuYWNjb3VudElkLCBwcmljZS5zeW1ib2wsIHByaWNlLnRpbWVzdGFtcHMpLFxuICAgICAgICAgICAgICAgIGAke3ByaW1hcnlBY2NvdW50SWR9OiR7aW5zdGFuY2VJbmRleH06b25TeW1ib2xQcmljZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBpbmNvbWluZyBzeW5jaHJvbml6YXRpb24gcGFja2V0JywgZXJyKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfcHJvY2Vzc0V2ZW50KGNhbGxhYmxlLCBsYWJlbCwgdGhyb3dFcnJvcikge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGlzTG9uZ0V2ZW50ID0gZmFsc2U7XG4gICAgbGV0IGlzRXZlbnREb25lID0gZmFsc2U7XG5cbiAgICBjb25zdCBjaGVja0xvbmdFdmVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMCkpO1xuICAgICAgaWYgKCFpc0V2ZW50RG9uZSkge1xuICAgICAgICBpc0xvbmdFdmVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGAke2xhYmVsfTogZXZlbnQgaXMgdGFraW5nIG1vcmUgdGhhbiAxIHNlY29uZCB0byBwcm9jZXNzYCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNoZWNrTG9uZ0V2ZW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNhbGxhYmxlKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAodGhyb3dFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoYCR7bGFiZWx9OiBldmVudCBmYWlsZWQgd2l0aCBlcnJvcmAsIGVycik7XG4gICAgfVxuICAgIGlzRXZlbnREb25lID0gdHJ1ZTtcbiAgICBpZiAoaXNMb25nRXZlbnQpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGAke2xhYmVsfTogZmluaXNoZWQgaW4gJHtNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDApfSBzZWNvbmRzYCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2ZpcmVSZWNvbm5lY3RlZChpbnN0YW5jZU51bWJlciwgc29ja2V0SW5zdGFuY2VJbmRleCwgcmVnaW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlY29ubmVjdExpc3RlbmVycyA9IFtdO1xuICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fcmVjb25uZWN0TGlzdGVuZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXRJbnN0YW5jZXNCeUFjY291bnRzW2luc3RhbmNlTnVtYmVyXVtsaXN0ZW5lci5hY2NvdW50SWRdID09PSBzb2NrZXRJbnN0YW5jZUluZGV4ICYmIFxuICAgICAgICAgIHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihsaXN0ZW5lci5hY2NvdW50SWQpID09PSByZWdpb24pIHtcbiAgICAgICAgICByZWNvbm5lY3RMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzKS5mb3JFYWNoKHN5bmNocm9uaXphdGlvbklkID0+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudElkID0gdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3Nbc3luY2hyb25pemF0aW9uSWRdLmFjY291bnRJZDtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gPT09IHNvY2tldEluc3RhbmNlSW5kZXhcbiAgICAgICAgICAgICYmIHRoaXMuX3N5bmNocm9uaXphdGlvbkZsYWdzW3N5bmNocm9uaXphdGlvbklkXS5pbnN0YW5jZU51bWJlciA9PT0gaW5zdGFuY2VOdW1iZXJcbiAgICAgICAgICAgICYmIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF1cbiAgICAgICAgICAgICYmIHRoaXMuX3JlZ2lvbnNCeUFjY291bnRzW2FjY291bnRJZF0ucmVnaW9uID09PSByZWdpb24pIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fc3luY2hyb25pemF0aW9uRmxhZ3Nbc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlY29ubmVjdEFjY291bnRJZHMgPSByZWNvbm5lY3RMaXN0ZW5lcnMubWFwKGxpc3RlbmVyID0+IGxpc3RlbmVyLmFjY291bnRJZCk7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25NYW5hZ2VyLm9uUmVjb25uZWN0ZWQoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlY29ubmVjdEFjY291bnRJZHMpO1xuICAgICAgdGhpcy5fcGFja2V0T3JkZXJlci5vblJlY29ubmVjdGVkKHJlY29ubmVjdEFjY291bnRJZHMpO1xuXG4gICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiByZWNvbm5lY3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGxpc3RlbmVyLmxpc3RlbmVyLm9uUmVjb25uZWN0ZWQocmVnaW9uLCBpbnN0YW5jZU51bWJlcikpXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBub3RpZnkgcmVjb25uZWN0IGxpc3RlbmVyJywgZXJyKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBwcm9jZXNzIHJlY29ubmVjdGVkIGV2ZW50JywgZXJyKTtcbiAgICB9XG4gIH1cblxuICBfZ2V0U29ja2V0SW5zdGFuY2VCeUFjY291bnQoYWNjb3VudElkLCBpbnN0YW5jZU51bWJlcikge1xuICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0QWNjb3VudFJlZ2lvbihhY2NvdW50SWQpO1xuICAgIHJldHVybiB0aGlzLl9zb2NrZXRJbnN0YW5jZXNbcmVnaW9uXVtpbnN0YW5jZU51bWJlcl1bdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXV07XG4gIH1cblxuICBhc3luYyBnZXRVcmxTZXR0aW5ncyhpbnN0YW5jZU51bWJlciwgcmVnaW9uKSB7XG4gICAgaWYgKHRoaXMuX3VybCkge1xuICAgICAgcmV0dXJuIHt1cmw6IHRoaXMuX3VybCwgaXNTaGFyZWRDbGllbnRBcGk6IHRydWV9O1xuICAgIH1cblxuICAgIGNvbnN0IHVybFNldHRpbmdzID0gYXdhaXQgdGhpcy5fZG9tYWluQ2xpZW50LmdldFNldHRpbmdzKCk7XG4gICAgY29uc3QgZ2V0VXJsID0gKGhvc3RuYW1lKSA9PiBcbiAgICAgIGBodHRwczovLyR7aG9zdG5hbWV9LiR7cmVnaW9ufS0ke1N0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyBOdW1iZXIoaW5zdGFuY2VOdW1iZXIpKX0uJHt1cmxTZXR0aW5ncy5kb21haW59YDtcblxuICAgIGxldCB1cmw7XG4gICAgaWYgKHRoaXMuX3VzZVNoYXJlZENsaWVudEFwaSkge1xuICAgICAgdXJsID0gZ2V0VXJsKHRoaXMuX2hvc3RuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXJsID0gZ2V0VXJsKHVybFNldHRpbmdzLmhvc3RuYW1lKTtcbiAgICB9XG4gICAgY29uc3QgaXNTaGFyZWRDbGllbnRBcGkgPSB1cmwgPT09IGdldFVybCh0aGlzLl9ob3N0bmFtZSk7XG4gICAgcmV0dXJuIHt1cmwsIGlzU2hhcmVkQ2xpZW50QXBpfTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIF9nZXRTZXJ2ZXJVcmwoaW5zdGFuY2VOdW1iZXIsIHNvY2tldEluc3RhbmNlSW5kZXgsIHJlZ2lvbikge1xuICAgIGlmICh0aGlzLl91cmwpIHtcbiAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRoaXMuc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdW3NvY2tldEluc3RhbmNlSW5kZXhdLmNvbm5lY3RlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsU2V0dGluZ3MgPSBhd2FpdCB0aGlzLmdldFVybFNldHRpbmdzKGluc3RhbmNlTnVtYmVyLCByZWdpb24pO1xuICAgICAgICBjb25zdCB1cmwgPSB1cmxTZXR0aW5ncy51cmw7XG4gICAgICAgIGNvbnN0IGlzU2hhcmVkQ2xpZW50QXBpID0gdXJsU2V0dGluZ3MuaXNTaGFyZWRDbGllbnRBcGk7XG4gICAgICAgIGxldCBsb2dNZXNzYWdlID0gJ0Nvbm5lY3RpbmcgTWV0YUFwaSB3ZWJzb2NrZXQgY2xpZW50IHRvIHRoZSBNZXRhQXBpIHNlcnZlciAnICtcbiAgICAgIGB2aWEgJHt1cmx9ICR7aXNTaGFyZWRDbGllbnRBcGkgPyAnc2hhcmVkJyA6ICdkZWRpY2F0ZWQnfSBzZXJ2ZXIuYDtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0Q29ubmVjdCAmJiAhaXNTaGFyZWRDbGllbnRBcGkpIHtcbiAgICAgICAgICBsb2dNZXNzYWdlICs9ICcgUGxlYXNlIG5vdGUgdGhhdCBpdCBjYW4gdGFrZSB1cCB0byAzIG1pbnV0ZXMgZm9yIHlvdXIgZGVkaWNhdGVkIHNlcnZlciB0byBzdGFydCBmb3IgdGhlICcgK1xuICAgICAgICAnZmlyc3QgdGltZS4gRHVyaW5nIHRoaXMgdGltZSBpdCBpcyBPSyBpZiB5b3Ugc2VlIHNvbWUgY29ubmVjdGlvbiBlcnJvcnMuJztcbiAgICAgICAgICB0aGlzLl9maXJzdENvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2dnZXIuaW5mbyhsb2dNZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBzZXJ2ZXIgVVJMJywgZXJyKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAxMDAwKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3Rocm90dGxlUmVxdWVzdCh0eXBlLCBhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyLCB0aW1lSW5Ncykge1xuICAgIHRoaXMuX2xhc3RSZXF1ZXN0c1RpbWVbaW5zdGFuY2VOdW1iZXJdID0gdGhpcy5fbGFzdFJlcXVlc3RzVGltZVtpbnN0YW5jZU51bWJlcl0gfHwge307XG4gICAgdGhpcy5fbGFzdFJlcXVlc3RzVGltZVtpbnN0YW5jZU51bWJlcl1bdHlwZV0gPSB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lW2luc3RhbmNlTnVtYmVyXVt0eXBlXSB8fCB7fTtcbiAgICBsZXQgbGFzdFRpbWUgPSB0aGlzLl9sYXN0UmVxdWVzdHNUaW1lW2luc3RhbmNlTnVtYmVyXVt0eXBlXVthY2NvdW50SWRdO1xuICAgIGlmICghbGFzdFRpbWUgfHwgKGxhc3RUaW1lIDwgRGF0ZS5ub3coKSAtIHRpbWVJbk1zKSkge1xuICAgICAgdGhpcy5fbGFzdFJlcXVlc3RzVGltZVtpbnN0YW5jZU51bWJlcl1bdHlwZV1bYWNjb3VudElkXSA9IERhdGUubm93KCk7XG4gICAgICByZXR1cm4gISFsYXN0VGltZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgX3JlZnJlc2hBY2NvdW50UmVnaW9uKGFjY291bnRJZCkge1xuICAgIGlmICh0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdKSB7XG4gICAgICB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1thY2NvdW50SWRdLmxhc3RVc2VkID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH1cblxuICAvL2VzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gIGFzeW5jIF9jcmVhdGVTb2NrZXRJbnN0YW5jZUJ5QWNjb3VudChhY2NvdW50SWQsIGluc3RhbmNlTnVtYmVyKSB7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5nZXRBY2NvdW50UmVnaW9uKGFjY291bnRJZCk7XG4gICAgaWYgKHRoaXMuX3NvY2tldEluc3RhbmNlc0J5QWNjb3VudHNbaW5zdGFuY2VOdW1iZXJdW2FjY291bnRJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHNvY2tldEluc3RhbmNlSW5kZXggPSBudWxsO1xuICAgICAgd2hpbGUgKHRoaXMuX3N1YnNjcmliZUxvY2sgJiYgKChuZXcgRGF0ZSh0aGlzLl9zdWJzY3JpYmVMb2NrLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCkgPiBEYXRlLm5vdygpICYmIFxuICAgICAgICAgIHRoaXMuc3Vic2NyaWJlZEFjY291bnRJZHMoaW5zdGFuY2VOdW1iZXIsIHVuZGVmaW5lZCwgcmVnaW9uKS5sZW5ndGggPCBcbiAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpIHx8IFxuICAgICAgICAgIChuZXcgRGF0ZSh0aGlzLl9zdWJzY3JpYmVMb2NrLmxvY2tlZEF0VGltZSkuZ2V0VGltZSgpICsgdGhpcy5fc3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMgKiAxMDAwID4gXG4gICAgICAgICAgRGF0ZS5ub3coKSAmJiB0aGlzLnN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCB1bmRlZmluZWQsIHJlZ2lvbikubGVuZ3RoID49IFxuICAgICAgICAgIHRoaXMuX3N1YnNjcmliZUxvY2subG9ja2VkQXRBY2NvdW50cykpKSB7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMTAwMCkpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX3NvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgYWNjb3VudENvdW50ZXIgPSB0aGlzLmdldEFzc2lnbmVkQWNjb3VudHMoaW5zdGFuY2VOdW1iZXIsIGluZGV4LCByZWdpb24pLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLnNvY2tldEluc3RhbmNlc1tyZWdpb25dW2luc3RhbmNlTnVtYmVyXVtpbmRleF07XG4gICAgICAgIGlmIChpbnN0YW5jZS5zdWJzY3JpYmVMb2NrKSB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlLnN1YnNjcmliZUxvY2sudHlwZSA9PT0gJ0xJTUlUX0FDQ09VTlRfU1VCU0NSSVBUSU9OU19QRVJfVVNFUl9QRVJfU0VSVkVSJyAmJiBcbiAgICAgICAgICAgIChuZXcgRGF0ZShpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCkgPiBEYXRlLm5vdygpIHx8IFxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVkQWNjb3VudElkcyhpbnN0YW5jZU51bWJlciwgaW5kZXgsIHJlZ2lvbikubGVuZ3RoID49IFxuICAgICAgICAgICAgaW5zdGFuY2Uuc3Vic2NyaWJlTG9jay5sb2NrZWRBdEFjY291bnRzKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnR5cGUgPT09ICdMSU1JVF9BQ0NPVU5UX1NVQlNDUklQVElPTlNfUEVSX1NFUlZFUicgJiYgXG4gICAgICAgICAgICBuZXcgRGF0ZShpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLnJlY29tbWVuZGVkUmV0cnlUaW1lKS5nZXRUaW1lKCkgPiBEYXRlLm5vdygpICYmXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZWRBY2NvdW50SWRzKGluc3RhbmNlTnVtYmVyLCBpbmRleCwgcmVnaW9uKS5sZW5ndGggPj0gXG4gICAgICAgICAgICBpbnN0YW5jZS5zdWJzY3JpYmVMb2NrLmxvY2tlZEF0QWNjb3VudHMpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjb3VudENvdW50ZXIgPCB0aGlzLl9tYXhBY2NvdW50c1Blckluc3RhbmNlKSB7XG4gICAgICAgICAgc29ja2V0SW5zdGFuY2VJbmRleCA9IGluZGV4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc29ja2V0SW5zdGFuY2VJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXRJbnN0YW5jZUluZGV4ID0gdGhpcy5fc29ja2V0SW5zdGFuY2VzW3JlZ2lvbl1baW5zdGFuY2VOdW1iZXJdLmxlbmd0aDtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KGluc3RhbmNlTnVtYmVyLCByZWdpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5fc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50c1tpbnN0YW5jZU51bWJlcl1bYWNjb3VudElkXSA9IHNvY2tldEluc3RhbmNlSW5kZXg7XG4gICAgfVxuICB9ICBcblxuICBfY2xlYXJBY2NvdW50Q2FjaGVKb2IoKSB7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fcmVnaW9uc0J5QWNjb3VudHMpLmZvckVhY2gocmVwbGljYUlkID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9yZWdpb25zQnlBY2NvdW50c1tyZXBsaWNhSWRdO1xuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5jb25uZWN0aW9ucyA9PT0gMCAmJiBkYXRlIC0gZGF0YS5sYXN0VXNlZCA+IDIgKiA2MCAqIDYwICogMTAwMCkge1xuICAgICAgICBjb25zdCBwcmltYXJ5QWNjb3VudElkID0gdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhSWRdO1xuICAgICAgICBjb25zdCByZXBsaWNhcyA9IE9iamVjdC52YWx1ZXModGhpcy5fYWNjb3VudFJlcGxpY2FzW3ByaW1hcnlBY2NvdW50SWRdIHx8IHt9KTtcbiAgICAgICAgcmVwbGljYXMuZm9yRWFjaChyZXBsaWNhID0+IHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudHNCeVJlcGxpY2FJZFtyZXBsaWNhXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcmVnaW9uc0J5QWNjb3VudHNbcmVwbGljYV07XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgdGhpcy5fYWNjb3VudFJlcGxpY2FzW3ByaW1hcnlBY2NvdW50SWRdO1xuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoYCR7cHJpbWFyeUFjY291bnRJZH06IHJlbW92ZWQgZXhwaXJlZCBhY2NvdW50IHJlcGxpY2FzIGRhdGFgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9jbGVhckluYWN0aXZlU3luY0RhdGFKb2IoKSB7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3luY2hyb25pemF0aW9uSGFzaGVzKS5rZXlzKHN5bmNocm9uaXphdGlvbklkID0+IHtcbiAgICAgIGlmICh0aGlzLl9zeW5jaHJvbml6YXRpb25IYXNoZXNbc3luY2hyb25pemF0aW9uSWRdLmxhc3RVcGRhdGVkIDwgZGF0ZSAtIDMwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zeW5jaHJvbml6YXRpb25IYXNoZXNbc3luY2hyb25pemF0aW9uSWRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbiJdLCJuYW1lcyI6WyJyYW5kb21zdHJpbmciLCJzb2NrZXRJTyIsIlRpbWVvdXRFcnJvciIsIlZhbGlkYXRpb25FcnJvciIsIk5vdEZvdW5kRXJyb3IiLCJJbnRlcm5hbEVycm9yIiwiVW5hdXRob3JpemVkRXJyb3IiLCJUb29NYW55UmVxdWVzdHNFcnJvciIsIkZvcmJpZGRlbkVycm9yIiwiT3B0aW9uc1ZhbGlkYXRvciIsIk5vdFN5bmNocm9uaXplZEVycm9yIiwiTm90Q29ubmVjdGVkRXJyb3IiLCJUcmFkZUVycm9yIiwiUGFja2V0T3JkZXJlciIsIlN5bmNocm9uaXphdGlvblRocm90dGxlciIsIlN1YnNjcmlwdGlvbk1hbmFnZXIiLCJMb2dnZXJNYW5hZ2VyIiwiYW55IiwiTGF0ZW5jeVNlcnZpY2UiLCJQYWNrZXRMb2dnZXIiLCJ3aW5kb3ciLCJyZXF1aXJlIiwiZGVmYXVsdCIsIk1ldGFBcGlXZWJzb2NrZXRDbGllbnQiLCJvbk91dE9mT3JkZXJQYWNrZXQiLCJhY2NvdW50SWQiLCJpbnN0YW5jZUluZGV4IiwiZXhwZWN0ZWRTZXF1ZW5jZU51bWJlciIsImFjdHVhbFNlcXVlbmNlTnVtYmVyIiwicGFja2V0IiwicmVjZWl2ZWRBdCIsInByaW1hcnlBY2NvdW50SWQiLCJfYWNjb3VudHNCeVJlcGxpY2FJZCIsIl9zdWJzY3JpcHRpb25NYW5hZ2VyIiwiaXNTdWJzY3JpcHRpb25BY3RpdmUiLCJsZXZlbCIsIl9sYXRlbmN5U2VydmljZSIsImdldFN5bmNocm9uaXplZEFjY291bnRJbnN0YW5jZXMiLCJsZW5ndGgiLCJfbG9nZ2VyIiwidHlwZSIsImVuc3VyZVN1YnNjcmliZSIsInVybCIsIl91cmwiLCJyZWdpb24iLCJfcmVnaW9uIiwic29ja2V0SW5zdGFuY2VzIiwiX3NvY2tldEluc3RhbmNlcyIsInNvY2tldEluc3RhbmNlc0J5QWNjb3VudHMiLCJfc29ja2V0SW5zdGFuY2VzQnlBY2NvdW50cyIsImFjY291bnRSZXBsaWNhcyIsIl9hY2NvdW50UmVwbGljYXMiLCJhY2NvdW50c0J5UmVwbGljYUlkIiwiY2xlYXJBY2NvdW50Q2FjaGVKb2IiLCJfY2xlYXJBY2NvdW50Q2FjaGVKb2IiLCJiaW5kIiwibGF0ZW5jeVNlcnZpY2UiLCJzdWJzY3JpYmVkQWNjb3VudElkcyIsImluc3RhbmNlTnVtYmVyIiwic29ja2V0SW5zdGFuY2VJbmRleCIsImNvbm5lY3RlZElkcyIsIk9iamVjdCIsImtleXMiLCJfY29ubmVjdGVkSG9zdHMiLCJmb3JFYWNoIiwiaW5zdGFuY2VJZCIsInNwbGl0IiwiYWNjb3VudFJlZ2lvbiIsImdldEFjY291bnRSZWdpb24iLCJpbmNsdWRlcyIsInVuZGVmaW5lZCIsInB1c2giLCJjb25uZWN0ZWQiLCJpbnN0YW5jZSIsInNvY2tldCIsImdldEFzc2lnbmVkQWNjb3VudHMiLCJhY2NvdW50SWRzIiwia2V5IiwiX3JlZ2lvbnNCeUFjY291bnRzIiwiYWRkQWNjb3VudENhY2hlIiwicmVwbGljYXMiLCJyZXBsaWNhSWQiLCJjb25uZWN0aW9ucyIsImxhc3RVc2VkIiwiRGF0ZSIsIm5vdyIsImRlYnVnIiwidXBkYXRlQWNjb3VudENhY2hlIiwib2xkUmVwbGljYXMiLCJjb25uZWN0aW9uQ291bnQiLCJyZW1vdmVBY2NvdW50Q2FjaGUiLCJsb2NrU29ja2V0SW5zdGFuY2UiLCJtZXRhZGF0YSIsIl9zdWJzY3JpYmVMb2NrIiwicmVjb21tZW5kZWRSZXRyeVRpbWUiLCJsb2NrZWRBdEFjY291bnRzIiwibG9ja2VkQXRUaW1lIiwic3Vic2NyaWJlZEFjY291bnRzIiwic29ja2V0SW5zdGFuY2UiLCJjbG9zZSIsIl9yZWNvbm5lY3QiLCJzdWJzY3JpYmVMb2NrIiwiY29ubmVjdCIsImNsaWVudElkIiwiTWF0aCIsInJhbmRvbSIsInJlc29sdmUiLCJyZXN1bHQiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiaWQiLCJyZWNvbm5lY3RXYWl0VGltZSIsIl9zb2NrZXRNaW5pbXVtUmVjb25uZWN0VGltZW91dCIsInJlcXVlc3RSZXNvbHZlcyIsInJlc29sdmVkIiwiY29ubmVjdFJlc3VsdCIsInNlc3Npb25JZCIsImdlbmVyYXRlIiwiaXNSZWNvbm5lY3RpbmciLCJzeW5jaHJvbml6YXRpb25UaHJvdHRsZXIiLCJfc3luY2hyb25pemF0aW9uVGhyb3R0bGVyT3B0cyIsInN0YXJ0Iiwic2VydmVyVXJsIiwiX2dldFNlcnZlclVybCIsInBhdGgiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25EZWxheSIsInJlY29ubmVjdGlvbkRlbGF5TWF4IiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJJbmZpbml0eSIsInRpbWVvdXQiLCJfY29ubmVjdFRpbWVvdXQiLCJleHRyYUhlYWRlcnMiLCJxdWVyeSIsIl90b2tlbiIsInByb3RvY29sIiwib24iLCJpbmZvIiwiX2ZpcmVSZWNvbm5lY3RlZCIsImVyciIsImVycm9yIiwicmVhc29uIiwib25EaXNjb25uZWN0IiwiZGF0YSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInJlcXVlc3RJZCIsInRpbWVzdGFtcHMiLCJyZXF1ZXN0UmVzb2x2ZSIsInJlamVjdCIsIl9jb252ZXJ0SXNvVGltZVRvRGF0ZSIsImNsaWVudFByb2Nlc3NpbmdGaW5pc2hlZCIsImxpc3RlbmVyIiwiX2xhdGVuY3lMaXN0ZW5lcnMiLCJ0aGVuIiwib25UcmFkZSIsIm9uUmVzcG9uc2UiLCJjYXRjaCIsIl9jb252ZXJ0RXJyb3IiLCJ0cmFjZSIsInNlcXVlbmNlTnVtYmVyIiwic2VxdWVuY2VUaW1lc3RhbXAiLCJzeW5jaHJvbml6YXRpb25JZCIsImFwcGxpY2F0aW9uIiwiaG9zdCIsInNwZWNpZmljYXRpb25zVXBkYXRlZCIsInBvc2l0aW9uc1VwZGF0ZWQiLCJvcmRlcnNVcGRhdGVkIiwic3BlY2lmaWNhdGlvbnMiLCJfc3luY2hyb25pemF0aW9uTGlzdGVuZXJzIiwiYWN0aXZlU3luY2hyb25pemF0aW9uSWRzIiwiX3BhY2tldExvZ2dlciIsImxvZ1BhY2tldCIsImlnbm9yZWRQYWNrZXRUeXBlcyIsIl90aHJvdHRsZVJlcXVlc3QiLCJfdW5zdWJzY3JpYmVUaHJvdHRsaW5nSW50ZXJ2YWwiLCJ1bnN1YnNjcmliZSIsIndhcm4iLCJxdWV1ZVBhY2tldCIsInZhbHVlcyIsIkVycm9yIiwiX3BhY2tldE9yZGVyZXIiLCJzdG9wIiwiY2xlYXJJbnRlcnZhbCIsIl9jbGVhckFjY291bnRDYWNoZUludGVydmFsIiwiX2NsZWFySW5hY3RpdmVTeW5jRGF0YUpvYiIsImdldEFjY291bnRJbmZvcm1hdGlvbiIsIm9wdGlvbnMiLCJyZXNwb25zZSIsInJwY1JlcXVlc3QiLCJhY2NvdW50SW5mb3JtYXRpb24iLCJnZXRQb3NpdGlvbnMiLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsInBvc2l0aW9uSWQiLCJwb3NpdGlvbiIsImdldE9yZGVycyIsIm9yZGVycyIsImdldE9yZGVyIiwib3JkZXJJZCIsIm9yZGVyIiwiZ2V0SGlzdG9yeU9yZGVyc0J5VGlja2V0IiwidGlja2V0IiwiaGlzdG9yeU9yZGVycyIsInN5bmNocm9uaXppbmciLCJnZXRIaXN0b3J5T3JkZXJzQnlQb3NpdGlvbiIsImdldEhpc3RvcnlPcmRlcnNCeVRpbWVSYW5nZSIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJvZmZzZXQiLCJsaW1pdCIsImdldERlYWxzQnlUaWNrZXQiLCJkZWFscyIsImdldERlYWxzQnlQb3NpdGlvbiIsImdldERlYWxzQnlUaW1lUmFuZ2UiLCJyZW1vdmVBcHBsaWNhdGlvbiIsInRyYWRlIiwicmVsaWFiaWxpdHkiLCJycGNSZXF1ZXN0QWxsSW5zdGFuY2VzIiwiX2FwcGxpY2F0aW9uIiwic3RyaW5nQ29kZSIsImRlc2NyaXB0aW9uIiwibnVtZXJpY0NvZGUiLCJtZXNzYWdlIiwic2NoZWR1bGVTdWJzY3JpYmUiLCJzdWJzY3JpYmUiLCJzeW5jaHJvbml6ZSIsInN0YXJ0aW5nSGlzdG9yeU9yZGVyVGltZSIsInN0YXJ0aW5nRGVhbFRpbWUiLCJoYXNoZXMiLCJfZ2V0U29ja2V0SW5zdGFuY2VCeUFjY291bnQiLCJfY3JlYXRlU29ja2V0SW5zdGFuY2VCeUFjY291bnQiLCJzeW5jVGhyb3R0bGVyIiwiX3N5bmNocm9uaXphdGlvbkhhc2hlcyIsImxhc3RVcGRhdGVkIiwic2NoZWR1bGVTeW5jaHJvbml6ZSIsInZlcnNpb24iLCJ3YWl0U3luY2hyb25pemVkIiwiYXBwbGljYXRpb25QYXR0ZXJuIiwidGltZW91dEluU2Vjb25kcyIsInN1YnNjcmliZVRvTWFya2V0RGF0YSIsInN5bWJvbCIsInN1YnNjcmlwdGlvbnMiLCJyZWZyZXNoTWFya2V0RGF0YVN1YnNjcmlwdGlvbnMiLCJ1bnN1YnNjcmliZUZyb21NYXJrZXREYXRhIiwiZ2V0U3ltYm9scyIsInN5bWJvbHMiLCJnZXRTeW1ib2xTcGVjaWZpY2F0aW9uIiwic3BlY2lmaWNhdGlvbiIsImdldFN5bWJvbFByaWNlIiwia2VlcFN1YnNjcmlwdGlvbiIsInByaWNlIiwiZ2V0Q2FuZGxlIiwidGltZWZyYW1lIiwiY2FuZGxlIiwiZ2V0VGljayIsInRpY2siLCJnZXRCb29rIiwiYm9vayIsInJlZnJlc2hUZXJtaW5hbFN0YXRlIiwicmVmcmVzaFN5bWJvbFF1b3RlcyIsInJlZnJlc2hlZFF1b3RlcyIsInNhdmVVcHRpbWUiLCJ1cHRpbWUiLCJvblVuc3Vic2NyaWJlIiwidXBkYXRlRXZlbnRzVG9SZW1vdmUiLCJfdXBkYXRlRXZlbnRzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImFsbCIsIm1hcCIsIk51bWJlciIsIm5hbWUiLCJnZXRTZXJ2ZXJUaW1lIiwic2VydmVyVGltZSIsImNhbGN1bGF0ZU1hcmdpbiIsIm1hcmdpbiIsInVuc3Vic2NyaWJlQWNjb3VudFJlZ2lvbiIsInVuc3Vic2NyaWJlUHJvbWlzZXMiLCJfcHJvY2Vzc0V2ZW50Iiwib25VbnN1YnNjcmliZVJlZ2lvbiIsImFkZFN5bmNocm9uaXphdGlvbkxpc3RlbmVyIiwibGlzdGVuZXJzIiwicmVtb3ZlU3luY2hyb25pemF0aW9uTGlzdGVuZXIiLCJsIiwiYWRkTGF0ZW5jeUxpc3RlbmVyIiwicmVtb3ZlTGF0ZW5jeUxpc3RlbmVyIiwiYWRkUmVjb25uZWN0TGlzdGVuZXIiLCJfcmVjb25uZWN0TGlzdGVuZXJzIiwicmVtb3ZlUmVjb25uZWN0TGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJvbkFjY291bnREZWxldGVkIiwiY2FuY2VsQWNjb3VudCIsIm1hc3RlckFjY291bnRJZCIsInJlZ2lvbkRhdGEiLCJfc3luY2hyb25pemF0aW9uSWRCeUluc3RhbmNlIiwicmVwbGljYSIsInBhY2tldHMiLCJyZXN0b3JlT3JkZXIiLCJwIiwiX3NlcXVlbnRpYWxFdmVudFByb2Nlc3NpbmciLCJldmVudHMiLCJwYWNrZXRJdGVtIiwiX3Byb2Nlc3NTeW5jaHJvbml6YXRpb25QYWNrZXQiLCJfZXZlbnRRdWV1ZXMiLCJfY2FsbEFjY291bnRFdmVudHMiLCJjb25jYXQiLCJxdWV1ZUV2ZW50IiwiY2FsbGFibGUiLCJldmVudCIsInNoaWZ0IiwiX3RyeVJlY29ubmVjdCIsIm1pbiIsInNldFRpbWVvdXQiLCJpbyIsIm9wdHMiLCJ1cmkiLCJyZXF1ZXN0IiwiYXNzaWduIiwiZXJyb3JzIiwiaWdub3JlZFJlcXVlc3RUeXBlcyIsImNvbm5lY3RlZEluc3RhbmNlIiwiZ2V0QWN0aXZlQWNjb3VudEluc3RhbmNlcyIsIndhaXRDb25uZWN0ZWRJbnN0YW5jZSIsImFjdGl2ZVJlZ2lvbiIsIl9yZWZyZXNoQWNjb3VudFJlZ2lvbiIsIl9tYWtlUmVxdWVzdCIsInJldHJ5Q291bnRlciIsImNhbGNSZXRyeUNvdW50ZXIiLCJjYWxjUmVxdWVzdFRpbWUiLCJfcmV0cmllcyIsInBvdyIsIl9taW5SZXRyeURlbGF5SW5TZWNvbmRzIiwiX21heFJldHJ5RGVsYXlJblNlY29uZHMiLCJyZXRyeVRpbWUiLCJnZXRUaW1lIiwiY2xpZW50UHJvY2Vzc2luZ1N0YXJ0ZWQiLCJyYWNlIiwiX3JlcXVlc3RUaW1lb3V0IiwiZW1pdCIsImRldGFpbHMiLCJmaWVsZCIsInZhbHVlIiwibWF0Y2giLCJBcnJheSIsImlzQXJyYXkiLCJpdGVtIiwicHJpY2VzIiwidXBkYXRlU3luY2hyb25pemF0aW9uSWQiLCJpc09ubHlBY3RpdmVJbnN0YW5jZSIsImFjdGl2ZUluc3RhbmNlSWRzIiwiY2FuY2VsRGlzY29ubmVjdFRpbWVyIiwiX3N0YXR1c1RpbWVycyIsImNsZWFyVGltZW91dCIsInJlc2V0RGlzY29ubmVjdFRpbWVyIiwib25UaW1lb3V0Iiwib25EaXNjb25uZWN0ZWQiLCJpc1RpbWVvdXQiLCJvblN0cmVhbUNsb3NlZCIsInJlbW92ZUlkQnlQYXJhbWV0ZXJzIiwib25Db25uZWN0ZWQiLCJjYW5jZWxTdWJzY3JpYmUiLCJfc3luY2hyb25pemF0aW9uRmxhZ3MiLCJzcGVjaWZpY2F0aW9uc0hhc2hJbmRleCIsInBvc2l0aW9uc0hhc2hJbmRleCIsIm9yZGVyc0hhc2hJbmRleCIsInNwZWNpZmljYXRpb25zSGFzaCIsInNwZWNpZmljYXRpb25zSGFzaGVzIiwicG9zaXRpb25zSGFzaCIsInBvc2l0aW9uc0hhc2hlcyIsIm9yZGVyc0hhc2giLCJvcmRlcnNIYXNoZXMiLCJvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQiLCJvbkFjY291bnRJbmZvcm1hdGlvblVwZGF0ZWQiLCJvblBvc2l0aW9uc1N5bmNocm9uaXplZCIsIm9uUGVuZGluZ09yZGVyc1N5bmNocm9uaXplZCIsImRlYWwiLCJvbkRlYWxBZGRlZCIsIm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkIiwiaGlzdG9yeU9yZGVyIiwib25IaXN0b3J5T3JkZXJBZGRlZCIsIm9uUG9zaXRpb25zUmVwbGFjZWQiLCJ1cGRhdGVkUG9zaXRpb25zIiwicmVtb3ZlZFBvc2l0aW9uSWRzIiwib25Qb3NpdGlvbnNVcGRhdGVkIiwib25Qb3NpdGlvblVwZGF0ZWQiLCJvblBvc2l0aW9uUmVtb3ZlZCIsInVwZGF0ZWRPcmRlcnMiLCJjb21wbGV0ZWRPcmRlcklkcyIsIm9uUGVuZGluZ09yZGVyc1VwZGF0ZWQiLCJvblBlbmRpbmdPcmRlclVwZGF0ZWQiLCJvblBlbmRpbmdPcmRlckNvbXBsZXRlZCIsIm9uVXBkYXRlIiwib25EZWFsc1N5bmNocm9uaXplZCIsInJlbW92ZVN5bmNocm9uaXphdGlvbklkIiwib25IaXN0b3J5T3JkZXJzU3luY2hyb25pemVkIiwiYXV0aGVudGljYXRlZCIsImlzRGlzY29ubmVjdGVkUmV0cnlNb2RlIiwiaXNBY2NvdW50U3Vic2NyaWJpbmciLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwiaGVhbHRoU3RhdHVzIiwib25IZWFsdGhTdGF0dXMiLCJ1cGRhdGVzIiwidW5zdWJzY3JpcHRpb25zIiwib25TdWJzY3JpcHRpb25Eb3duZ3JhZGVkIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uc1VwZGF0ZWQiLCJyZW1vdmVkU3ltYm9scyIsIm9uU3ltYm9sU3BlY2lmaWNhdGlvblVwZGF0ZWQiLCJyZW1vdmVkU3ltYm9sIiwib25TeW1ib2xTcGVjaWZpY2F0aW9uUmVtb3ZlZCIsImNhbmRsZXMiLCJ0aWNrcyIsImJvb2tzIiwib25TeW1ib2xQcmljZXNVcGRhdGVkIiwiZXF1aXR5IiwiZnJlZU1hcmdpbiIsIm1hcmdpbkxldmVsIiwiYWNjb3VudEN1cnJlbmN5RXhjaGFuZ2VSYXRlIiwib25DYW5kbGVzVXBkYXRlZCIsIm9uVGlja3NVcGRhdGVkIiwib25Cb29rc1VwZGF0ZWQiLCJvblN5bWJvbFByaWNlVXBkYXRlZCIsIm9uU3ltYm9sUHJpY2UiLCJsYWJlbCIsInRocm93RXJyb3IiLCJpc0xvbmdFdmVudCIsImlzRXZlbnREb25lIiwiY2hlY2tMb25nRXZlbnQiLCJmbG9vciIsInJlY29ubmVjdExpc3RlbmVycyIsInJlY29ubmVjdEFjY291bnRJZHMiLCJvblJlY29ubmVjdGVkIiwiZ2V0VXJsU2V0dGluZ3MiLCJpc1NoYXJlZENsaWVudEFwaSIsInVybFNldHRpbmdzIiwiX2RvbWFpbkNsaWVudCIsImdldFNldHRpbmdzIiwiZ2V0VXJsIiwiaG9zdG5hbWUiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJkb21haW4iLCJfdXNlU2hhcmVkQ2xpZW50QXBpIiwiX2hvc3RuYW1lIiwibG9nTWVzc2FnZSIsIl9maXJzdENvbm5lY3QiLCJ0aW1lSW5NcyIsIl9sYXN0UmVxdWVzdHNUaW1lIiwibGFzdFRpbWUiLCJfc3Vic2NyaWJlQ29vbGRvd25JblNlY29uZHMiLCJpbmRleCIsImFjY291bnRDb3VudGVyIiwiX21heEFjY291bnRzUGVySW5zdGFuY2UiLCJkYXRlIiwiY29uc3RydWN0b3IiLCJtZXRhQXBpIiwiZG9tYWluQ2xpZW50IiwidG9rZW4iLCJ2YWxpZGF0b3IiLCJwYWNrZXRPcmRlcmluZ1RpbWVvdXQiLCJ2YWxpZGF0ZU5vblplcm8iLCJfZG9tYWluIiwiX21ldGFBcGkiLCJyZXF1ZXN0VGltZW91dCIsImNvbm5lY3RUaW1lb3V0IiwicmV0cnlPcHRzIiwidmFsaWRhdGVOdW1iZXIiLCJyZXRyaWVzIiwibWluRGVsYXlJblNlY29uZHMiLCJtYXhEZWxheUluU2Vjb25kcyIsInN1YnNjcmliZUNvb2xkb3duSW5TZWNvbmRzIiwidmFsaWRhdGVCb29sZWFuIiwidXNlU2hhcmVkQ2xpZW50QXBpIiwidW5zdWJzY3JpYmVUaHJvdHRsaW5nSW50ZXJ2YWxJblNlY29uZHMiLCJwYWNrZXRMb2dnZXIiLCJlbmFibGVkIiwiZ2V0TG9nZ2VyIiwiZGlzYWJsZUludGVybmFsSm9icyIsInNldEludGVydmFsIl0sIm1hcHBp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
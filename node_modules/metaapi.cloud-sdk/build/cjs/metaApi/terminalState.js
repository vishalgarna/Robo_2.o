"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return TerminalState;
    }
});
const _randomstring = /*#__PURE__*/ _interop_require_default(require("randomstring"));
const _synchronizationListener = /*#__PURE__*/ _interop_require_default(require("../clients/metaApi/synchronizationListener"));
const _metaApiWebsocketclient = /*#__PURE__*/ _interop_require_default(require("../clients/metaApi/metaApiWebsocket.client"));
const _logger = /*#__PURE__*/ _interop_require_default(require("../logger"));
const _terminalHashManager = /*#__PURE__*/ _interop_require_default(require("./terminalHashManager"));
const _metatraderAccount = /*#__PURE__*/ _interop_require_default(require("./metatraderAccount"));
const _promises = require("../helpers/promises");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
let TerminalState = class TerminalState extends _synchronizationListener.default {
    get id() {
        return this._id;
    }
    /**
   * Returns true if MetaApi have connected to MetaTrader terminal
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal
   */ get connected() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.connected, false);
    }
    /**
   * Returns true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to broker
   * @return {Boolean} true if MetaApi have connected to MetaTrader terminal and MetaTrader terminal is connected to
   * broker
   */ get connectedToBroker() {
        return Object.values(this._stateByInstanceIndex).reduce((acc, s)=>acc || s.connectedToBroker, false);
    }
    /**
   * Returns a local copy of account information
   * @returns {MetatraderAccountInformation} local copy of account information
   */ get accountInformation() {
        return this._combinedState.accountInformation;
    }
    /**
   * Returns a local copy of MetaTrader positions opened
   * @returns {Array<MetatraderPosition>} a local copy of MetaTrader positions opened
   */ get positions() {
        const hash = this._combinedState.positionsHash;
        return hash ? Object.values(this._terminalHashManager.getPositionsByHash(hash) || {}) : [];
    }
    /**
   * Returns a local copy of MetaTrader orders opened
   * @returns {Array<MetatraderOrder>} a local copy of MetaTrader orders opened
   */ get orders() {
        const hash = this._combinedState.ordersHash;
        return hash ? Object.values(this._terminalHashManager.getOrdersByHash(hash) || {}) : [];
    }
    /**
   * Returns a local copy of symbol specifications available in MetaTrader trading terminal
   * @returns {Array<MetatraderSymbolSpecification>} a local copy of symbol specifications available in MetaTrader
   * trading terminal
   */ get specifications() {
        const hash = this._combinedState.specificationsHash;
        return hash ? Object.values(this._terminalHashManager.getSpecificationsByHash(this._combinedState.specificationsHash) || {}) : [];
    }
    /**
   * Returns hashes of terminal state data for incremental synchronization
   * @returns {Promise<Object>} promise resolving with hashes of terminal state data
   */ // eslint-disable-next-line complexity
    getHashes() {
        const specificationsHashes = this._terminalHashManager.getLastUsedSpecificationHashes(this._account.server);
        const positionsHashes = this._terminalHashManager.getLastUsedPositionHashes(this._account.id);
        const ordersHashes = this._terminalHashManager.getLastUsedOrderHashes(this._account.id);
        return {
            specificationsHashes: specificationsHashes,
            positionsHashes: positionsHashes,
            ordersHashes: ordersHashes
        };
    }
    /**
   * Returns MetaTrader symbol specification by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolSpecification} MetatraderSymbolSpecification found or undefined if specification for a
   * symbol is not found
   */ specification(symbol) {
        if (this._combinedState.specificationsHash) {
            const state = this._terminalHashManager.getSpecificationsByHash(this._combinedState.specificationsHash);
            return state[symbol];
        } else {
            return null;
        }
    }
    /**
   * Returns MetaTrader symbol price by symbol
   * @param {String} symbol symbol (e.g. currency pair or an index)
   * @return {MetatraderSymbolPrice} MetatraderSymbolPrice found or undefined if price for a symbol is not found
   */ price(symbol) {
        return this._combinedState.pricesBySymbol[symbol];
    }
    /**
   * Quote time
   * @typdef {Object} QuoteTime
   * @property {Date} time quote time
   * @property {String} brokerTime quote time in broker timezone, YYYY-MM-DD HH:mm:ss.SSS format
   */ /**
   * Returns time of the last received quote
   * @return {QuoteTime} time of the last received quote
   */ get lastQuoteTime() {
        if (this._combinedState.lastQuoteTime) {
            return {
                time: this._combinedState.lastQuoteTime,
                brokerTime: this._combinedState.lastQuoteBrokerTime
            };
        } else {
            return undefined;
        }
    }
    /**
   * Waits for price to be received
   * @param {string} symbol symbol (e.g. currency pair or an index)
   * @param {number} [timeoutInSeconds] timeout in seconds, default is 30
   * @return {Promise<MetatraderSymbolPrice>} promise resolving with price or undefined if price has not been received
   */ async waitForPrice(symbol, timeoutInSeconds = 30) {
        this._waitForPriceResolves[symbol] = this._waitForPriceResolves[symbol] || [];
        if (!this.price(symbol)) {
            await Promise.race([
                new Promise((res)=>this._waitForPriceResolves[symbol].push(res)),
                new Promise((res)=>setTimeout(res, timeoutInSeconds * 1000))
            ]);
        }
        return this.price(symbol);
    }
    /**
   * Invoked when connection to MetaTrader terminal established
   * @param {String} instanceIndex index of an account instance connected
   */ onConnected(instanceIndex) {
        this._getState(instanceIndex).connected = true;
    }
    /**
   * Invoked when connection to MetaTrader terminal terminated
   * @param {String} instanceIndex index of an account instance connected
   */ onDisconnected(instanceIndex) {
        let state = this._getState(instanceIndex);
        state.connected = false;
        state.connectedToBroker = false;
    }
    /**
   * Invoked when broker connection status have changed
   * @param {String} instanceIndex index of an account instance connected
   * @param {Boolean} connected is MetaTrader terminal is connected to broker
   */ onBrokerConnectionStatusChanged(instanceIndex, connected) {
        this._combinedState.lastStatusTime = Date.now();
        this._getState(instanceIndex).connectedToBroker = connected;
    }
    /**
   * Invoked when MetaTrader terminal state synchronization is started
   * @param {string} instanceIndex index of an account instance connected
   * @param {string} specificationsHash specifications hash
   * @param {string} positionsHash positions hash
   * @param {string} ordersHash orders hash
   * @param {string} synchronizationId synchronization id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onSynchronizationStarted(instanceIndex, specificationsHash, positionsHash, ordersHash, synchronizationId) {
        const unsynchronizedStates = this._getStateIndicesOfSameInstanceNumber(instanceIndex).filter((stateIndex)=>!this._stateByInstanceIndex[stateIndex].ordersInitialized);
        unsynchronizedStates.sort((a, b)=>b.lastSyncUpdateTime - a.lastSyncUpdateTime);
        unsynchronizedStates.slice(1).forEach((stateIndex)=>this._removeState(stateIndex));
        let state = this._getState(instanceIndex);
        state.isSpecificationsExpected = !specificationsHash;
        state.isPositionsExpected = !positionsHash;
        state.isOrdersExpected = !ordersHash;
        state.lastSyncUpdateTime = Date.now();
        state.accountInformation = undefined;
        state.pricesBySymbol = {};
        state.positions = [];
        if (!positionsHash) {
            state.positionsInitialized = false;
            state.positionsHash = null;
        } else {
            state.positionsHash = positionsHash;
        }
        state.orders = [];
        if (!ordersHash) {
            state.ordersInitialized = false;
            state.ordersHash = null;
        } else {
            state.ordersHash = ordersHash;
        }
        state.specificationsBySymbol = {};
        if (!specificationsHash) {
            this._logger.trace(()=>`${this._account.id}:${instanceIndex}:${synchronizationId}: cleared specifications ` + "on synchronization start");
            state.specificationsHash = null;
        } else {
            this._logger.trace(()=>`${this._account.id}:${instanceIndex}:${synchronizationId}: no need to clear ` + `specifications on synchronization start, ${Object.keys(state.specificationsBySymbol || {}).length} ` + "specifications reused");
            state.specificationsHash = specificationsHash;
        }
    }
    /**
   * Invoked when MetaTrader account information is updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {MetatraderAccountInformation} accountInformation updated MetaTrader account information
   */ onAccountInformationUpdated(instanceIndex, accountInformation) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        state.accountInformation = accountInformation;
        if (accountInformation) {
            this._combinedState.accountInformation = Object.assign({}, accountInformation);
        }
    }
    /**
   * Invoked when the positions are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderPosition>} positions updated array of positions
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsReplaced(instanceIndex, positions) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        if (state.isPositionsExpected) {
            state.positions = positions;
        }
    }
    /**
   * Invoked when position synchronization fnished to indicate progress of an initial terminal state synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPositionsSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.positionsInitialized = true;
    }
    /**
   * Invoked when MetaTrader positions are updated
   * @param {string} instanceIndex index of an account instance connected
   * @param {MetatraderPosition[]} positions updated MetaTrader positions
   * @param {string[]} removedPositionIds removed position ids
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onPositionsUpdated(instanceIndex, positions, removedPositionIds) {
        let instanceState = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        const date = Date.now();
        removedPositionIds.forEach((id)=>this._combinedState.removedPositions[id] = date);
        positions = this._filterRemovedPositions(positions);
        Object.keys(this._combinedState.removedPositions).forEach((id)=>{
            if (this._combinedState.removedPositions[id] < date - 24 * 60 * 60 * 1000) {
                delete this._combinedState.removedPositions[id];
            }
        });
        if (instanceState.ordersInitialized) {
            const updatePositions = async (state, instance)=>{
                const hash = await this._terminalHashManager.updatePositions(this._account.id, this._account.type, this._id, instance, positions, removedPositionIds, state.positionsHash);
                state.positionsHash = hash;
            };
            await updatePositions(instanceState, instanceIndex);
            await updatePositions(this._combinedState, this._combinedInstanceIndex);
        } else {
            instanceState.positions = instanceState.positions.filter((position)=>!removedPositionIds.includes(position.id));
            positions.forEach((position)=>{
                let index = instanceState.positions.findIndex((p)=>p.id === position.id);
                if (index !== -1) {
                    instanceState.positions[index] = position;
                } else {
                    instanceState.positions.push(position);
                }
            });
        }
    }
    /**
   * Invoked when the orders are replaced as a result of initial terminal state synchronization
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderOrder>} orders updated array of pending orders
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ onPendingOrdersReplaced(instanceIndex, orders) {
        let state = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        if (state.isOrdersExpected) {
            state.orders = orders;
        }
    }
    /**
   * Invoked when pending order synchronization fnished to indicate progress of an initial terminal state
   * synchronization
   * @param {string} instanceIndex index of an account instance connected
   * @param {String} synchronizationId synchronization request id
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ // eslint-disable-next-line complexity, max-statements
    async onPendingOrdersSynchronized(instanceIndex, synchronizationId) {
        let state = this._getState(instanceIndex);
        state.positionsInitialized = true;
        state.ordersInitialized = true;
        this._combinedState.accountInformation = state.accountInformation ? Object.assign({}, state.accountInformation) : undefined;
        state.positions = this._filterRemovedPositions(state.positions);
        if (state.positions.length) {
            const hash = this._terminalHashManager.recordPositions(this._account.id, this._account.type, this._id, instanceIndex, state.positions);
            state.positionsHash = hash;
            this._combinedState.positions = (state.positions || []).map((p)=>Object.assign({}, p));
            this._combinedState.positionsHash = hash;
        } else if (state.positionsHash) {
            this._terminalHashManager.removePositionReference(this.id, instanceIndex);
            this._terminalHashManager.addPositionReference(state.positionsHash, this.id, instanceIndex);
            this._combinedState.positionsHash = state.positionsHash;
            this._terminalHashManager.removePositionReference(this.id, this._combinedInstanceIndex);
            this._terminalHashManager.addPositionReference(state.positionsHash, this.id, this._combinedInstanceIndex);
        }
        state.orders = this._filterRemovedOrders(state.orders);
        if (state.orders.length) {
            const hash = this._terminalHashManager.recordOrders(this._account.id, this._account.type, this._id, instanceIndex, state.orders);
            state.ordersHash = hash;
            this._combinedState.orders = (state.orders || []).map((o)=>Object.assign({}, o));
            this._combinedState.ordersHash = hash;
        } else if (state.ordersHash) {
            this._terminalHashManager.removeOrderReference(this.id, instanceIndex);
            this._terminalHashManager.addOrderReference(state.ordersHash, this.id, instanceIndex);
            this._combinedState.ordersHash = state.ordersHash;
            this._terminalHashManager.removeOrderReference(this.id, this._combinedInstanceIndex);
            this._terminalHashManager.addOrderReference(state.ordersHash, this.id, this._combinedInstanceIndex);
        }
        this._logger.trace(()=>`${this._account.id}:${instanceIndex}:${synchronizationId}: assigned specifications to ` + "combined state from " + `${instanceIndex}, ${Object.keys(state.specificationsBySymbol || {}).length} specifications assigned`);
        this._combinedState.positionsInitialized = true;
        this._combinedState.ordersInitialized = true;
        if (Object.keys(state.specificationsBySymbol || {}).length) {
            if (state.isSpecificationsExpected) {
                const hash = await this._terminalHashManager.recordSpecifications(this._account.server, this._account.type, this._id, instanceIndex, Object.values(state.specificationsBySymbol));
                this._combinedState.specificationsHash = hash;
                state.specificationsHash = hash;
                state.specificationsBySymbol = null;
            } else if (state.specificationsHash) {
                const hash = await this._terminalHashManager.updateSpecifications(this._account.server, this._account.type, this._id, instanceIndex, Object.values(state.specificationsBySymbol), [], state.specificationsHash);
                state.specificationsHash = hash;
            }
        } else if (state.specificationsHash) {
            this._terminalHashManager.removeSpecificationReference(this.id, instanceIndex);
            this._terminalHashManager.addSpecificationReference(state.specificationsHash, this.id, instanceIndex);
            this._combinedState.specificationsHash = state.specificationsHash;
            this._terminalHashManager.removeSpecificationReference(this.id, this._combinedInstanceIndex);
            this._terminalHashManager.addSpecificationReference(state.specificationsHash, this.id, this._combinedInstanceIndex);
        }
        for (let stateIndex of this._getStateIndicesOfSameInstanceNumber(instanceIndex)){
            if (!this._stateByInstanceIndex[stateIndex].connected) {
                this._removeState(stateIndex);
            }
        }
    }
    /**
   * Invoked when MetaTrader pending orders are updated or completed
   * @param {string} instanceIndex index of an account instance connected
   * @param {MetatraderOrder[]} orders updated MetaTrader pending orders
   * @param {string[]} completedOrderIds completed MetaTrader pending order ids
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onPendingOrdersUpdated(instanceIndex, orders, completedOrderIds) {
        let instanceState = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        const date = Date.now();
        completedOrderIds.forEach((id)=>this._combinedState.completedOrders[id] = date);
        orders = this._filterRemovedOrders(orders);
        Object.keys(this._combinedState.completedOrders).forEach((id)=>{
            if (this._combinedState.completedOrders[id] < date - 24 * 60 * 60 * 1000) {
                delete this._combinedState.completedOrders[id];
            }
        });
        if (instanceState.ordersInitialized) {
            const updatePendingOrders = async (state, instance)=>{
                const hash = await this._terminalHashManager.updateOrders(this._account.id, this._account.type, this._id, instance, orders, completedOrderIds, state.ordersHash);
                state.ordersHash = hash;
            };
            await updatePendingOrders(instanceState, instanceIndex);
            await updatePendingOrders(this._combinedState, this._combinedInstanceIndex);
        } else {
            instanceState.orders = instanceState.orders.filter((order)=>!completedOrderIds.includes(order.id));
            orders.forEach((order)=>{
                let index = instanceState.orders.findIndex((o)=>o.id === order.id);
                if (index !== -1) {
                    instanceState.orders[index] = order;
                } else {
                    instanceState.orders.push(order);
                }
            });
        }
    }
    /**
   * Invoked when a symbol specification was updated
   * @param {String} instanceIndex index of account instance connected
   * @param {Array<MetatraderSymbolSpecification>} specifications updated specifications
   * @param {Array<String>} removedSymbols removed symbols
   */ async onSymbolSpecificationsUpdated(instanceIndex, specifications, removedSymbols) {
        let instanceState = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        if (!instanceState.ordersInitialized) {
            for (let specification of specifications){
                instanceState.specificationsBySymbol[specification.symbol] = specification;
            }
        } else {
            const hash = this._terminalHashManager.updateSpecifications(this._account.server, this._account.type, this._id, instanceIndex, specifications, removedSymbols, instanceState.specificationsHash);
            instanceState.specificationsHash = hash;
            const combinedHash = this._terminalHashManager.updateSpecifications(this._account.server, this._account.type, this._id, this._combinedInstanceIndex, specifications, removedSymbols, this._combinedState.specificationsHash);
            this._combinedState.specificationsHash = combinedHash;
        }
        this._logger.trace(()=>`${this._account.id}:${instanceIndex}: updated ${specifications.length} specifications, ` + `removed ${removedSymbols.length} specifications. There are ` + `${Object.keys(instanceState.specificationsBySymbol || {}).length} specifications after update`);
    }
    /**
   * Invoked when prices for several symbols were updated
   * @param {String} instanceIndex index of an account instance connected
   * @param {Array<MetatraderSymbolPrice>} prices updated MetaTrader symbol prices
   * @param {Number} equity account liquidation value
   * @param {Number} margin margin used
   * @param {Number} freeMargin free margin
   * @param {Number} marginLevel margin level calculated as % of equity/margin
   */ // eslint-disable-next-line complexity
    onSymbolPricesUpdated(instanceIndex, prices, equity, margin, freeMargin, marginLevel) {
        let instanceState = this._getState(instanceIndex);
        this._refreshStateUpdateTime(instanceIndex);
        // eslint-disable-next-line complexity,max-statements
        const updateSymbolPrices = (state)=>{
            let pricesInitialized = false;
            let priceUpdated = false;
            for (let price of prices || []){
                let currentPrice = state.pricesBySymbol[price.symbol];
                if (currentPrice && currentPrice.time.getTime() > price.time.getTime()) {
                    continue;
                } else {
                    priceUpdated = true;
                }
                if (!state.lastQuoteTime || state.lastQuoteTime.getTime() < price.time.getTime()) {
                    state.lastQuoteTime = price.time;
                    state.lastQuoteBrokerTime = price.brokerTime;
                }
                state.pricesBySymbol[price.symbol] = price;
                const allPositions = Object.values(this._terminalHashManager.getPositionsByHash(state.positionsHash) || {});
                const allOrders = Object.values(this._terminalHashManager.getOrdersByHash(state.ordersHash) || {});
                let positions = allPositions.filter((p)=>p.symbol === price.symbol);
                let otherPositions = allPositions.filter((p)=>p.symbol !== price.symbol);
                let orders = allOrders.filter((o)=>o.symbol === price.symbol);
                pricesInitialized = true;
                for (let position of otherPositions){
                    let p = state.pricesBySymbol[position.symbol];
                    if (p) {
                        if (position.unrealizedProfit === undefined) {
                            this._updatePositionProfits(position, p);
                        }
                    } else {
                        pricesInitialized = false;
                    }
                }
                for (let position of positions){
                    this._updatePositionProfits(position, price);
                }
                for (let order of orders){
                    order.currentPrice = order.type === "ORDER_TYPE_BUY" || order.type === "ORDER_TYPE_BUY_LIMIT" || order.type === "ORDER_TYPE_BUY_STOP" || order.type === "ORDER_TYPE_BUY_STOP_LIMIT" ? price.ask : price.bid;
                }
                let priceResolves = this._waitForPriceResolves[price.symbol] || [];
                if (priceResolves.length) {
                    for (let resolve of priceResolves){
                        resolve();
                    }
                    delete this._waitForPriceResolves[price.symbol];
                }
            }
            if (priceUpdated && state.accountInformation) {
                const positions = Object.values(this._terminalHashManager.getPositionsByHash(state.positionsHash) || {});
                if (state.positionsInitialized && pricesInitialized) {
                    if (state.accountInformation.platform === "mt5") {
                        state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + positions.reduce((acc, p)=>acc + Math.round((p.unrealizedProfit || 0) * 100) / 100 + Math.round((p.swap || 0) * 100) / 100, 0);
                    } else {
                        state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.balance + positions.reduce((acc, p)=>acc + Math.round((p.swap || 0) * 100) / 100 + Math.round((p.commission || 0) * 100) / 100 + Math.round((p.unrealizedProfit || 0) * 100) / 100, 0);
                    }
                    state.accountInformation.equity = Math.round(state.accountInformation.equity * 100) / 100;
                } else {
                    state.accountInformation.equity = equity !== undefined ? equity : state.accountInformation.equity;
                }
                state.accountInformation.margin = margin !== undefined ? margin : state.accountInformation.margin;
                state.accountInformation.freeMargin = freeMargin !== undefined ? freeMargin : state.accountInformation.freeMargin;
                state.accountInformation.marginLevel = freeMargin !== undefined ? marginLevel : state.accountInformation.marginLevel;
            }
        };
        updateSymbolPrices(instanceState);
        updateSymbolPrices(this._combinedState);
        for (let price of prices){
            for (let call of Object.values(this._processThrottledQuotesCalls)){
                var _call_expectedSymbols;
                this._logger.trace(`${this._account.id}:${instanceIndex}: refreshed ${price.symbol} price`);
                (_call_expectedSymbols = call.expectedSymbols) === null || _call_expectedSymbols === void 0 ? void 0 : _call_expectedSymbols.delete(price.symbol);
                call.receivedSymbols.add(price.symbol);
                call.promise.check();
            }
        }
    }
    /**
   * Invoked when a stream for an instance index is closed
   * @param {String} instanceIndex index of an account instance connected
   * @return {Promise} promise which resolves when the asynchronous event is processed
   */ async onStreamClosed(instanceIndex) {
        if (this._stateByInstanceIndex[instanceIndex]) {
            for (let stateIndex of this._getStateIndicesOfSameInstanceNumber(instanceIndex)){
                const instanceState = this._stateByInstanceIndex[stateIndex];
                if (!this._stateByInstanceIndex[instanceIndex].ordersInitialized && this._stateByInstanceIndex[instanceIndex].lastSyncUpdateTime <= instanceState.lastSyncUpdateTime) {
                    this._removeState(instanceIndex);
                    break;
                }
                if (instanceState.connected && instanceState.ordersInitialized) {
                    this._removeState(instanceIndex);
                    break;
                }
            }
        }
    }
    /**
   * Forces refresh of most recent quote updates for symbols subscribed to by the terminal, and waits for them all to
   * be processed by this terminal state. This method does not waits for all other listeners to receive and process the
   * quote updates
   * @param {RefreshTerminalStateOptions} [options] additional options
   * @returns {Promise} promise resolving when the terminal state received and processed the latest quotes
   */ async refreshTerminalState(options) {
        let callData = {
            receivedSymbols: new Set()
        };
        let callId = _randomstring.default.generate(8);
        this._processThrottledQuotesCalls[callId] = callData;
        callData.promise = new _promises.ConditionPromise(()=>callData.expectedSymbols && !callData.expectedSymbols.size);
        var _options_timeoutInSeconds;
        callData.promise.timeout(1000 * ((_options_timeoutInSeconds = options === null || options === void 0 ? void 0 : options.timeoutInSeconds) !== null && _options_timeoutInSeconds !== void 0 ? _options_timeoutInSeconds : 10), "refreshing terminal state timed out");
        try {
            let symbols = await Promise.race([
                this._websocketClient.refreshTerminalState(this._account.id),
                callData.promise // will only throw timeout error at this point
            ]);
            this._logger.debug(`${this._account.id}: expecting for ${symbols.length ? symbols : 0} symbols to refresh`);
            let expectedSymbols = new Set();
            for (let symbol of symbols){
                if (!callData.receivedSymbols.has(symbol)) {
                    expectedSymbols.add(symbol);
                }
            }
            callData.expectedSymbols = expectedSymbols;
            callData.promise.check();
            await callData.promise;
        } finally{
            delete this._processThrottledQuotesCalls[callId];
        }
    }
    /**
   * Removes connection related data from terminal hash manager
   */ close() {
        Object.keys(this._stateByInstanceIndex).forEach((instanceIndex)=>{
            this._removeFromHashManager(instanceIndex);
        });
        this._removeFromHashManager(this._combinedInstanceIndex);
    }
    // resets combined state and removes from hash manager if has been disconnected for a long time
    _checkCombinedStateActivityJob() {
        if (!this.connectedToBroker && this._combinedState.lastStatusTime < Date.now() - 30 * 60 * 1000) {
            this._removeFromHashManager(this._combinedInstanceIndex);
            this._combinedState.accountInformation = undefined;
            this._combinedState.specificationsBySymbol = null;
            this._combinedState.pricesBySymbol = {};
            this._combinedState.specificationsHash = null;
            this._combinedState.orders = [];
            this._combinedState.ordersHash = null;
            this._combinedState.positions = [];
            this._combinedState.positionsHash = null;
            this._combinedState.ordersInitialized = false;
            this._combinedState.positionsInitialized = false;
            this._combinedState.lastStatusTime = 0;
            this._combinedState.lastQuoteTime = undefined;
            this._combinedState.lastQuoteBrokerTime = undefined;
        }
    }
    _removeState(instanceIndex) {
        delete this._stateByInstanceIndex[instanceIndex];
        this._removeFromHashManager(instanceIndex);
    }
    _removeFromHashManager(instanceIndex) {
        this._terminalHashManager.removeConnectionReferences(this._account.server, this._account.id, this._id, instanceIndex);
    }
    _refreshStateUpdateTime(instanceIndex) {
        const state = this._stateByInstanceIndex[instanceIndex];
        if (state && state.ordersInitialized) {
            state.lastSyncUpdateTime = Date.now();
        }
    }
    _getStateIndicesOfSameInstanceNumber(instanceIndex) {
        const region = instanceIndex.split(":")[0];
        const instanceNumber = instanceIndex.split(":")[1];
        return Object.keys(this._stateByInstanceIndex).filter((stateInstanceIndex)=>stateInstanceIndex.startsWith(`${region}:${instanceNumber}:`) && instanceIndex !== stateInstanceIndex);
    }
    // eslint-disable-next-line complexity
    _updatePositionProfits(position, price) {
        let specification = this.specification(position.symbol);
        if (specification) {
            let multiplier = Math.pow(10, specification.digits);
            if (position.profit !== undefined) {
                position.profit = Math.round(position.profit * multiplier) / multiplier;
            }
            if (position.unrealizedProfit === undefined || position.realizedProfit === undefined) {
                position.unrealizedProfit = (position.type === "POSITION_TYPE_BUY" ? 1 : -1) * (position.currentPrice - position.openPrice) * position.currentTickValue * position.volume / specification.tickSize;
                position.unrealizedProfit = Math.round(position.unrealizedProfit * multiplier) / multiplier;
                position.realizedProfit = position.profit - position.unrealizedProfit;
            }
            let newPositionPrice = position.type === "POSITION_TYPE_BUY" ? price.bid : price.ask;
            let isProfitable = (position.type === "POSITION_TYPE_BUY" ? 1 : -1) * (newPositionPrice - position.openPrice);
            let currentTickValue = isProfitable > 0 ? price.profitTickValue : price.lossTickValue;
            let unrealizedProfit = (position.type === "POSITION_TYPE_BUY" ? 1 : -1) * (newPositionPrice - position.openPrice) * currentTickValue * position.volume / specification.tickSize;
            unrealizedProfit = Math.round(unrealizedProfit * multiplier) / multiplier;
            position.unrealizedProfit = unrealizedProfit;
            position.profit = position.unrealizedProfit + position.realizedProfit;
            position.profit = Math.round(position.profit * multiplier) / multiplier;
            position.currentPrice = newPositionPrice;
            position.currentTickValue = currentTickValue;
        }
    }
    _filterRemovedPositions(positions) {
        return positions.filter((position)=>!this._combinedState.removedPositions[position.id]);
    }
    _filterRemovedOrders(orders) {
        return orders.filter((order)=>!this._combinedState.completedOrders[order.id]);
    }
    _getState(instanceIndex) {
        if (!this._stateByInstanceIndex["" + instanceIndex]) {
            this._logger.trace(`${this._account.id}:${instanceIndex}: constructed new state`);
            this._stateByInstanceIndex["" + instanceIndex] = this._constructTerminalState(instanceIndex);
        }
        return this._stateByInstanceIndex["" + instanceIndex];
    }
    _constructTerminalState(instanceIndex) {
        return {
            instanceIndex,
            connected: false,
            connectedToBroker: false,
            accountInformation: undefined,
            positions: [],
            orders: [],
            specificationsBySymbol: {},
            pricesBySymbol: {},
            ordersInitialized: false,
            positionsInitialized: false,
            lastSyncUpdateTime: 0,
            positionsHash: null,
            ordersHash: null,
            specificationsHash: null,
            isSpecificationsExpected: true,
            isPositionsExpected: true,
            isOrdersExpected: true,
            lastQuoteTime: undefined,
            lastQuoteBrokerTime: undefined
        };
    }
    /**
   * Constructs the instance of terminal state class
   * @param {MetatraderAccount} account mt account
   * @param {TerminalHashManager} terminalHashManager terminal hash manager
   * @param {MetaApiWebsocketClient} websocketClient websocket client
   */ constructor(account, terminalHashManager, websocketClient){
        super();
        this._id = _randomstring.default.generate(32);
        this._account = account;
        this._terminalHashManager = terminalHashManager;
        this._websocketClient = websocketClient;
        this._stateByInstanceIndex = {};
        this._waitForPriceResolves = {};
        this._combinedInstanceIndex = "combined";
        this._combinedState = {
            accountInformation: undefined,
            positions: [],
            orders: [],
            specificationsBySymbol: null,
            pricesBySymbol: {},
            removedPositions: {},
            completedOrders: {},
            specificationsHash: null,
            positionsHash: null,
            ordersHash: null,
            ordersInitialized: false,
            positionsInitialized: false,
            lastStatusTime: 0,
            lastQuoteTime: undefined,
            lastQuoteBrokerTime: undefined
        };
        this._processThrottledQuotesCalls = {};
        this._logger = _logger.default.getLogger("TerminalState");
        this._checkCombinedStateActivityJob = this._checkCombinedStateActivityJob.bind(this);
        setInterval(this._checkCombinedStateActivityJob, 5 * 60 * 1000);
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIjxhbm9uPiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCByYW5kb21zdHJpbmcgZnJvbSAncmFuZG9tc3RyaW5nJztcbmltcG9ydCBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciBmcm9tICcuLi9jbGllbnRzL21ldGFBcGkvc3luY2hyb25pemF0aW9uTGlzdGVuZXInO1xuaW1wb3J0IE1ldGFBcGlXZWJzb2NrZXRDbGllbnQgZnJvbSAnLi4vY2xpZW50cy9tZXRhQXBpL21ldGFBcGlXZWJzb2NrZXQuY2xpZW50JztcbmltcG9ydCBMb2dnZXJNYW5hZ2VyIGZyb20gJy4uL2xvZ2dlcic7XG5pbXBvcnQgVGVybWluYWxIYXNoTWFuYWdlciBmcm9tICcuL3Rlcm1pbmFsSGFzaE1hbmFnZXInO1xuaW1wb3J0IE1ldGF0cmFkZXJBY2NvdW50IGZyb20gJy4vbWV0YXRyYWRlckFjY291bnQnO1xuaW1wb3J0IHtDb25kaXRpb25Qcm9taXNlfSBmcm9tICcuLi9oZWxwZXJzL3Byb21pc2VzJztcblxuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3Igc3RvcmluZyBhIGxvY2FsIGNvcHkgb2YgcmVtb3RlIHRlcm1pbmFsIHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRlcm1pbmFsU3RhdGUgZXh0ZW5kcyBTeW5jaHJvbml6YXRpb25MaXN0ZW5lciB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgdGhlIGluc3RhbmNlIG9mIHRlcm1pbmFsIHN0YXRlIGNsYXNzXG4gICAqIEBwYXJhbSB7TWV0YXRyYWRlckFjY291bnR9IGFjY291bnQgbXQgYWNjb3VudFxuICAgKiBAcGFyYW0ge1Rlcm1pbmFsSGFzaE1hbmFnZXJ9IHRlcm1pbmFsSGFzaE1hbmFnZXIgdGVybWluYWwgaGFzaCBtYW5hZ2VyXG4gICAqIEBwYXJhbSB7TWV0YUFwaVdlYnNvY2tldENsaWVudH0gd2Vic29ja2V0Q2xpZW50IHdlYnNvY2tldCBjbGllbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFjY291bnQsIHRlcm1pbmFsSGFzaE1hbmFnZXIsIHdlYnNvY2tldENsaWVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5faWQgPSByYW5kb21zdHJpbmcuZ2VuZXJhdGUoMzIpO1xuICAgIHRoaXMuX2FjY291bnQgPSBhY2NvdW50O1xuICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIgPSB0ZXJtaW5hbEhhc2hNYW5hZ2VyO1xuICAgIHRoaXMuX3dlYnNvY2tldENsaWVudCA9IHdlYnNvY2tldENsaWVudDtcbiAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleCA9IHt9O1xuICAgIHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzID0ge307XG4gICAgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4ID0gJ2NvbWJpbmVkJztcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlID0ge1xuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IG51bGwsXG4gICAgICBwcmljZXNCeVN5bWJvbDoge30sXG4gICAgICByZW1vdmVkUG9zaXRpb25zOiB7fSxcbiAgICAgIGNvbXBsZXRlZE9yZGVyczoge30sXG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2g6IG51bGwsXG4gICAgICBwb3NpdGlvbnNIYXNoOiBudWxsLFxuICAgICAgb3JkZXJzSGFzaDogbnVsbCxcbiAgICAgIG9yZGVyc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uc0luaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgIGxhc3RTdGF0dXNUaW1lOiAwLFxuICAgICAgbGFzdFF1b3RlVGltZTogdW5kZWZpbmVkLFxuICAgICAgbGFzdFF1b3RlQnJva2VyVGltZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICB0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHMgPSB7fTtcbiAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXJNYW5hZ2VyLmdldExvZ2dlcignVGVybWluYWxTdGF0ZScpO1xuICAgIHRoaXMuX2NoZWNrQ29tYmluZWRTdGF0ZUFjdGl2aXR5Sm9iID0gdGhpcy5fY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IuYmluZCh0aGlzKTtcbiAgICBzZXRJbnRlcnZhbCh0aGlzLl9jaGVja0NvbWJpbmVkU3RhdGVBY3Rpdml0eUpvYiwgNSAqIDYwICogMTAwMCk7XG4gIH1cblxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWxcbiAgICovXG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLnJlZHVjZSgoYWNjLCBzKSA9PiBhY2MgfHwgcy5jb25uZWN0ZWQsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgTWV0YUFwaSBoYXZlIGNvbm5lY3RlZCB0byBNZXRhVHJhZGVyIHRlcm1pbmFsIGFuZCBNZXRhVHJhZGVyIHRlcm1pbmFsIGlzIGNvbm5lY3RlZCB0byBicm9rZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBNZXRhQXBpIGhhdmUgY29ubmVjdGVkIHRvIE1ldGFUcmFkZXIgdGVybWluYWwgYW5kIE1ldGFUcmFkZXIgdGVybWluYWwgaXMgY29ubmVjdGVkIHRvXG4gICAqIGJyb2tlclxuICAgKi9cbiAgZ2V0IGNvbm5lY3RlZFRvQnJva2VyKCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KS5yZWR1Y2UoKGFjYywgcykgPT4gYWNjIHx8IHMuY29ubmVjdGVkVG9Ccm9rZXIsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWwgY29weSBvZiBhY2NvdW50IGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm5zIHtNZXRhdHJhZGVyQWNjb3VudEluZm9ybWF0aW9ufSBsb2NhbCBjb3B5IG9mIGFjY291bnQgaW5mb3JtYXRpb25cbiAgICovXG4gIGdldCBhY2NvdW50SW5mb3JtYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbWJpbmVkU3RhdGUuYWNjb3VudEluZm9ybWF0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgcG9zaXRpb25zIG9wZW5lZFxuICAgKiBAcmV0dXJucyB7QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gYSBsb2NhbCBjb3B5IG9mIE1ldGFUcmFkZXIgcG9zaXRpb25zIG9wZW5lZFxuICAgKi9cbiAgZ2V0IHBvc2l0aW9ucygpIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNIYXNoO1xuICAgIHJldHVybiBoYXNoID8gT2JqZWN0LnZhbHVlcyh0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFBvc2l0aW9uc0J5SGFzaChoYXNoKSB8fCB7fSkgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIG9yZGVycyBvcGVuZWRcbiAgICogQHJldHVybnMge0FycmF5PE1ldGF0cmFkZXJPcmRlcj59IGEgbG9jYWwgY29weSBvZiBNZXRhVHJhZGVyIG9yZGVycyBvcGVuZWRcbiAgICovXG4gIGdldCBvcmRlcnMoKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzSGFzaDtcbiAgICByZXR1cm4gaGFzaCA/IE9iamVjdC52YWx1ZXModGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRPcmRlcnNCeUhhc2goaGFzaCkgfHwge30pIDogW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvY2FsIGNvcHkgb2Ygc3ltYm9sIHNwZWNpZmljYXRpb25zIGF2YWlsYWJsZSBpbiBNZXRhVHJhZGVyIHRyYWRpbmcgdGVybWluYWxcbiAgICogQHJldHVybnMge0FycmF5PE1ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9uPn0gYSBsb2NhbCBjb3B5IG9mIHN5bWJvbCBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgaW4gTWV0YVRyYWRlclxuICAgKiB0cmFkaW5nIHRlcm1pbmFsXG4gICAqL1xuICBnZXQgc3BlY2lmaWNhdGlvbnMoKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoO1xuICAgIHJldHVybiBoYXNoID8gT2JqZWN0LnZhbHVlcyh0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFNwZWNpZmljYXRpb25zQnlIYXNoKFxuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gpIHx8IHt9KSA6IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGFzaGVzIG9mIHRlcm1pbmFsIHN0YXRlIGRhdGEgZm9yIGluY3JlbWVudGFsIHN5bmNocm9uaXphdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBwcm9taXNlIHJlc29sdmluZyB3aXRoIGhhc2hlcyBvZiB0ZXJtaW5hbCBzdGF0ZSBkYXRhXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBnZXRIYXNoZXMoKSB7XG4gICAgY29uc3Qgc3BlY2lmaWNhdGlvbnNIYXNoZXMgPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldExhc3RVc2VkU3BlY2lmaWNhdGlvbkhhc2hlcyh0aGlzLl9hY2NvdW50LnNlcnZlcik7XG4gICAgY29uc3QgcG9zaXRpb25zSGFzaGVzID0gdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRMYXN0VXNlZFBvc2l0aW9uSGFzaGVzKHRoaXMuX2FjY291bnQuaWQpO1xuICAgIGNvbnN0IG9yZGVyc0hhc2hlcyA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0TGFzdFVzZWRPcmRlckhhc2hlcyh0aGlzLl9hY2NvdW50LmlkKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2hlczogc3BlY2lmaWNhdGlvbnNIYXNoZXMsXG4gICAgICBwb3NpdGlvbnNIYXNoZXM6IHBvc2l0aW9uc0hhc2hlcyxcbiAgICAgIG9yZGVyc0hhc2hlczogb3JkZXJzSGFzaGVzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIE1ldGFUcmFkZXIgc3ltYm9sIHNwZWNpZmljYXRpb24gYnkgc3ltYm9sXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW1ib2wgc3ltYm9sIChlLmcuIGN1cnJlbmN5IHBhaXIgb3IgYW4gaW5kZXgpXG4gICAqIEByZXR1cm4ge01ldGF0cmFkZXJTeW1ib2xTcGVjaWZpY2F0aW9ufSBNZXRhdHJhZGVyU3ltYm9sU3BlY2lmaWNhdGlvbiBmb3VuZCBvciB1bmRlZmluZWQgaWYgc3BlY2lmaWNhdGlvbiBmb3IgYVxuICAgKiBzeW1ib2wgaXMgbm90IGZvdW5kXG4gICAqL1xuICBzcGVjaWZpY2F0aW9uKHN5bWJvbCkge1xuICAgIGlmKHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0U3BlY2lmaWNhdGlvbnNCeUhhc2goXG4gICAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKTtcbiAgICAgIHJldHVybiBzdGF0ZVtzeW1ib2xdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBNZXRhVHJhZGVyIHN5bWJvbCBwcmljZSBieSBzeW1ib2xcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN5bWJvbCBzeW1ib2wgKGUuZy4gY3VycmVuY3kgcGFpciBvciBhbiBpbmRleClcbiAgICogQHJldHVybiB7TWV0YXRyYWRlclN5bWJvbFByaWNlfSBNZXRhdHJhZGVyU3ltYm9sUHJpY2UgZm91bmQgb3IgdW5kZWZpbmVkIGlmIHByaWNlIGZvciBhIHN5bWJvbCBpcyBub3QgZm91bmRcbiAgICovXG4gIHByaWNlKHN5bWJvbCkge1xuICAgIHJldHVybiB0aGlzLl9jb21iaW5lZFN0YXRlLnByaWNlc0J5U3ltYm9sW3N5bWJvbF07XG4gIH1cblxuICAvKipcbiAgICogUXVvdGUgdGltZVxuICAgKiBAdHlwZGVmIHtPYmplY3R9IFF1b3RlVGltZVxuICAgKiBAcHJvcGVydHkge0RhdGV9IHRpbWUgcXVvdGUgdGltZVxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gYnJva2VyVGltZSBxdW90ZSB0aW1lIGluIGJyb2tlciB0aW1lem9uZSwgWVlZWS1NTS1ERCBISDptbTpzcy5TU1MgZm9ybWF0XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRpbWUgb2YgdGhlIGxhc3QgcmVjZWl2ZWQgcXVvdGVcbiAgICogQHJldHVybiB7UXVvdGVUaW1lfSB0aW1lIG9mIHRoZSBsYXN0IHJlY2VpdmVkIHF1b3RlXG4gICAqL1xuICBnZXQgbGFzdFF1b3RlVGltZSgpIHtcbiAgICBpZiAodGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0UXVvdGVUaW1lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aW1lOiB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZVRpbWUsXG4gICAgICAgIGJyb2tlclRpbWU6IHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFF1b3RlQnJva2VyVGltZSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdhaXRzIGZvciBwcmljZSB0byBiZSByZWNlaXZlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIHN5bWJvbCAoZS5nLiBjdXJyZW5jeSBwYWlyIG9yIGFuIGluZGV4KVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVvdXRJblNlY29uZHNdIHRpbWVvdXQgaW4gc2Vjb25kcywgZGVmYXVsdCBpcyAzMFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPE1ldGF0cmFkZXJTeW1ib2xQcmljZT59IHByb21pc2UgcmVzb2x2aW5nIHdpdGggcHJpY2Ugb3IgdW5kZWZpbmVkIGlmIHByaWNlIGhhcyBub3QgYmVlbiByZWNlaXZlZFxuICAgKi9cbiAgYXN5bmMgd2FpdEZvclByaWNlKHN5bWJvbCwgdGltZW91dEluU2Vjb25kcyA9IDMwKSB7XG4gICAgdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbc3ltYm9sXSA9IHRoaXMuX3dhaXRGb3JQcmljZVJlc29sdmVzW3N5bWJvbF0gfHwgW107XG4gICAgaWYgKCF0aGlzLnByaWNlKHN5bWJvbCkpIHtcbiAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIG5ldyBQcm9taXNlKHJlcyA9PiB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1tzeW1ib2xdLnB1c2gocmVzKSksXG4gICAgICAgIG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgdGltZW91dEluU2Vjb25kcyAqIDEwMDApKVxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnByaWNlKHN5bWJvbCk7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCBlc3RhYmxpc2hlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKi9cbiAgb25Db25uZWN0ZWQoaW5zdGFuY2VJbmRleCkge1xuICAgIHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpLmNvbm5lY3RlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIGNvbm5lY3Rpb24gdG8gTWV0YVRyYWRlciB0ZXJtaW5hbCB0ZXJtaW5hdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqL1xuICBvbkRpc2Nvbm5lY3RlZChpbnN0YW5jZUluZGV4KSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgc3RhdGUuY29ubmVjdGVkVG9Ccm9rZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYnJva2VyIGNvbm5lY3Rpb24gc3RhdHVzIGhhdmUgY2hhbmdlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbm5lY3RlZCBpcyBNZXRhVHJhZGVyIHRlcm1pbmFsIGlzIGNvbm5lY3RlZCB0byBicm9rZXJcbiAgICovXG4gIG9uQnJva2VyQ29ubmVjdGlvblN0YXR1c0NoYW5nZWQoaW5zdGFuY2VJbmRleCwgY29ubmVjdGVkKSB7XG4gICAgdGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0U3RhdHVzVGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCkuY29ubmVjdGVkVG9Ccm9rZXIgPSBjb25uZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIE1ldGFUcmFkZXIgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uIGlzIHN0YXJ0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNwZWNpZmljYXRpb25zSGFzaCBzcGVjaWZpY2F0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvbnNIYXNoIHBvc2l0aW9ucyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmRlcnNIYXNoIG9yZGVycyBoYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gaWRcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBvblN5bmNocm9uaXphdGlvblN0YXJ0ZWQoaW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnNIYXNoLCBwb3NpdGlvbnNIYXNoLCBvcmRlcnNIYXNoLCBzeW5jaHJvbml6YXRpb25JZCkge1xuICAgIGNvbnN0IHVuc3luY2hyb25pemVkU3RhdGVzID0gdGhpcy5fZ2V0U3RhdGVJbmRpY2VzT2ZTYW1lSW5zdGFuY2VOdW1iZXIoaW5zdGFuY2VJbmRleClcbiAgICAgIC5maWx0ZXIoc3RhdGVJbmRleCA9PiAhdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbc3RhdGVJbmRleF0ub3JkZXJzSW5pdGlhbGl6ZWQpO1xuICAgIHVuc3luY2hyb25pemVkU3RhdGVzLnNvcnQoKGEsYikgPT4gYi5sYXN0U3luY1VwZGF0ZVRpbWUgLSBhLmxhc3RTeW5jVXBkYXRlVGltZSk7XG4gICAgdW5zeW5jaHJvbml6ZWRTdGF0ZXMuc2xpY2UoMSkuZm9yRWFjaChzdGF0ZUluZGV4ID0+IHRoaXMuX3JlbW92ZVN0YXRlKHN0YXRlSW5kZXgpKTtcblxuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHN0YXRlLmlzU3BlY2lmaWNhdGlvbnNFeHBlY3RlZCA9ICFzcGVjaWZpY2F0aW9uc0hhc2g7XG4gICAgc3RhdGUuaXNQb3NpdGlvbnNFeHBlY3RlZCA9ICFwb3NpdGlvbnNIYXNoO1xuICAgIHN0YXRlLmlzT3JkZXJzRXhwZWN0ZWQgPSAhb3JkZXJzSGFzaDtcbiAgICBzdGF0ZS5sYXN0U3luY1VwZGF0ZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5wcmljZXNCeVN5bWJvbCA9IHt9O1xuICAgIHN0YXRlLnBvc2l0aW9ucyA9IFtdO1xuICAgIGlmKCFwb3NpdGlvbnNIYXNoKSB7XG4gICAgICBzdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9uc0hhc2ggPSBwb3NpdGlvbnNIYXNoO1xuICAgIH1cbiAgICBzdGF0ZS5vcmRlcnMgPSBbXTtcbiAgICBpZighb3JkZXJzSGFzaCkge1xuICAgICAgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm9yZGVyc0hhc2ggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5vcmRlcnNIYXNoID0gb3JkZXJzSGFzaDtcbiAgICB9XG4gICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IHt9O1xuICAgIGlmKCFzcGVjaWZpY2F0aW9uc0hhc2gpIHtcbiAgICAgIHRoaXMuX2xvZ2dlci50cmFjZSgoKSA9PiBgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiR7c3luY2hyb25pemF0aW9uSWR9OiBjbGVhcmVkIHNwZWNpZmljYXRpb25zIGAgK1xuICAgICAgICAnb24gc3luY2hyb25pemF0aW9uIHN0YXJ0Jyk7XG4gICAgICBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fToke3N5bmNocm9uaXphdGlvbklkfTogbm8gbmVlZCB0byBjbGVhciBgICtcbiAgICAgICAgYHNwZWNpZmljYXRpb25zIG9uIHN5bmNocm9uaXphdGlvbiBzdGFydCwgJHtPYmplY3Qua2V5cyhzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sIHx8IHt9KS5sZW5ndGh9IGAgK1xuICAgICAgICAnc3BlY2lmaWNhdGlvbnMgcmV1c2VkJyk7XG4gICAgICBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBzcGVjaWZpY2F0aW9uc0hhc2g7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIGFjY291bnQgaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJBY2NvdW50SW5mb3JtYXRpb259IGFjY291bnRJbmZvcm1hdGlvbiB1cGRhdGVkIE1ldGFUcmFkZXIgYWNjb3VudCBpbmZvcm1hdGlvblxuICAgKi9cbiAgb25BY2NvdW50SW5mb3JtYXRpb25VcGRhdGVkKGluc3RhbmNlSW5kZXgsIGFjY291bnRJbmZvcm1hdGlvbikge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gYWNjb3VudEluZm9ybWF0aW9uO1xuICAgIGlmIChhY2NvdW50SW5mb3JtYXRpb24pIHtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudEluZm9ybWF0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBwb3NpdGlvbnMgYXJlIHJlcGxhY2VkIGFzIGEgcmVzdWx0IG9mIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclBvc2l0aW9uPn0gcG9zaXRpb25zIHVwZGF0ZWQgYXJyYXkgb2YgcG9zaXRpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25Qb3NpdGlvbnNSZXBsYWNlZChpbnN0YW5jZUluZGV4LCBwb3NpdGlvbnMpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGlmKHN0YXRlLmlzUG9zaXRpb25zRXhwZWN0ZWQpIHtcbiAgICAgIHN0YXRlLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHBvc2l0aW9uIHN5bmNocm9uaXphdGlvbiBmbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGUgc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIG9uUG9zaXRpb25zU3luY2hyb25pemVkKGluc3RhbmNlSW5kZXgsIHN5bmNocm9uaXphdGlvbklkKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgc3RhdGUucG9zaXRpb25zSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBvc2l0aW9ucyBhcmUgdXBkYXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJQb3NpdGlvbltdfSBwb3NpdGlvbnMgdXBkYXRlZCBNZXRhVHJhZGVyIHBvc2l0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSByZW1vdmVkUG9zaXRpb25JZHMgcmVtb3ZlZCBwb3NpdGlvbiBpZHNcbiAgICogQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIHRoZSBhc3luY2hyb25vdXMgZXZlbnQgaXMgcHJvY2Vzc2VkXG4gICAqL1xuICBhc3luYyBvblBvc2l0aW9uc1VwZGF0ZWQoaW5zdGFuY2VJbmRleCwgcG9zaXRpb25zLCByZW1vdmVkUG9zaXRpb25JZHMpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgcmVtb3ZlZFBvc2l0aW9uSWRzLmZvckVhY2goaWQgPT4gdGhpcy5fY29tYmluZWRTdGF0ZS5yZW1vdmVkUG9zaXRpb25zW2lkXSA9IGRhdGUpO1xuICAgIHBvc2l0aW9ucyA9IHRoaXMuX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMocG9zaXRpb25zKTtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9jb21iaW5lZFN0YXRlLnJlbW92ZWRQb3NpdGlvbnMpLmZvckVhY2goaWQgPT4ge1xuICAgICAgaWYodGhpcy5fY29tYmluZWRTdGF0ZS5yZW1vdmVkUG9zaXRpb25zW2lkXSA8IGRhdGUgLSAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21iaW5lZFN0YXRlLnJlbW92ZWRQb3NpdGlvbnNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYoaW5zdGFuY2VTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCkge1xuICAgICAgY29uc3QgdXBkYXRlUG9zaXRpb25zID0gYXN5bmMgKHN0YXRlLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci51cGRhdGVQb3NpdGlvbnModGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCxcbiAgICAgICAgICBpbnN0YW5jZSwgcG9zaXRpb25zLCByZW1vdmVkUG9zaXRpb25JZHMsIHN0YXRlLnBvc2l0aW9uc0hhc2gpO1xuICAgICAgICBzdGF0ZS5wb3NpdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgIH07XG4gICAgICBhd2FpdCB1cGRhdGVQb3NpdGlvbnMoaW5zdGFuY2VTdGF0ZSwgaW5zdGFuY2VJbmRleCk7XG4gICAgICBhd2FpdCB1cGRhdGVQb3NpdGlvbnModGhpcy5fY29tYmluZWRTdGF0ZSwgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2VTdGF0ZS5wb3NpdGlvbnMgPSBpbnN0YW5jZVN0YXRlLnBvc2l0aW9ucy5maWx0ZXIocG9zaXRpb24gPT4gIXJlbW92ZWRQb3NpdGlvbklkcy5pbmNsdWRlcyhwb3NpdGlvbi5pZCkpO1xuICAgICAgcG9zaXRpb25zLmZvckVhY2gocG9zaXRpb24gPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSBpbnN0YW5jZVN0YXRlLnBvc2l0aW9ucy5maW5kSW5kZXgocCA9PiBwLmlkID09PSBwb3NpdGlvbi5pZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLnBvc2l0aW9uc1tpbmRleF0gPSBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLnBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgb3JkZXJzIGFyZSByZXBsYWNlZCBhcyBhIHJlc3VsdCBvZiBpbml0aWFsIHRlcm1pbmFsIHN0YXRlIHN5bmNocm9uaXphdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge0FycmF5PE1ldGF0cmFkZXJPcmRlcj59IG9yZGVycyB1cGRhdGVkIGFycmF5IG9mIHBlbmRpbmcgb3JkZXJzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgb25QZW5kaW5nT3JkZXJzUmVwbGFjZWQoaW5zdGFuY2VJbmRleCwgb3JkZXJzKSB7XG4gICAgbGV0IHN0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgdGhpcy5fcmVmcmVzaFN0YXRlVXBkYXRlVGltZShpbnN0YW5jZUluZGV4KTtcbiAgICBpZihzdGF0ZS5pc09yZGVyc0V4cGVjdGVkKSB7XG4gICAgICBzdGF0ZS5vcmRlcnMgPSBvcmRlcnM7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwZW5kaW5nIG9yZGVyIHN5bmNocm9uaXphdGlvbiBmbmlzaGVkIHRvIGluZGljYXRlIHByb2dyZXNzIG9mIGFuIGluaXRpYWwgdGVybWluYWwgc3RhdGVcbiAgICogc3luY2hyb25pemF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFuIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzeW5jaHJvbml6YXRpb25JZCBzeW5jaHJvbml6YXRpb24gcmVxdWVzdCBpZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5LCBtYXgtc3RhdGVtZW50c1xuICBhc3luYyBvblBlbmRpbmdPcmRlcnNTeW5jaHJvbml6ZWQoaW5zdGFuY2VJbmRleCwgc3luY2hyb25pemF0aW9uSWQpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICBzdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID0gc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uID8gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uKSA6XG4gICAgICB1bmRlZmluZWQ7XG4gICAgc3RhdGUucG9zaXRpb25zID0gdGhpcy5fZmlsdGVyUmVtb3ZlZFBvc2l0aW9ucyhzdGF0ZS5wb3NpdGlvbnMpO1xuICAgIGlmKHN0YXRlLnBvc2l0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlY29yZFBvc2l0aW9ucyh0aGlzLl9hY2NvdW50LmlkLFxuICAgICAgICB0aGlzLl9hY2NvdW50LnR5cGUsIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4LCBzdGF0ZS5wb3NpdGlvbnMpO1xuICAgICAgc3RhdGUucG9zaXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9ucyA9IChzdGF0ZS5wb3NpdGlvbnMgfHwgW10pLm1hcChwID0+IE9iamVjdC5hc3NpZ24oe30sIHApKTtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUucG9zaXRpb25zSGFzaCA9IGhhc2g7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5wb3NpdGlvbnNIYXNoKSB7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlbW92ZVBvc2l0aW9uUmVmZXJlbmNlKHRoaXMuaWQsIGluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5hZGRQb3NpdGlvblJlZmVyZW5jZShzdGF0ZS5wb3NpdGlvbnNIYXNoLFxuICAgICAgICB0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUucG9zaXRpb25zSGFzaCA9IHN0YXRlLnBvc2l0aW9uc0hhc2g7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlbW92ZVBvc2l0aW9uUmVmZXJlbmNlKHRoaXMuaWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmFkZFBvc2l0aW9uUmVmZXJlbmNlKHN0YXRlLnBvc2l0aW9uc0hhc2gsXG4gICAgICAgIHRoaXMuaWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIHN0YXRlLm9yZGVycyA9IHRoaXMuX2ZpbHRlclJlbW92ZWRPcmRlcnMoc3RhdGUub3JkZXJzKTtcbiAgICBpZihzdGF0ZS5vcmRlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBoYXNoID0gdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZWNvcmRPcmRlcnModGhpcy5fYWNjb3VudC5pZCxcbiAgICAgICAgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCwgaW5zdGFuY2VJbmRleCwgc3RhdGUub3JkZXJzKTtcbiAgICAgIHN0YXRlLm9yZGVyc0hhc2ggPSBoYXNoO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnMgPSAoc3RhdGUub3JkZXJzIHx8IFtdKS5tYXAobyA9PiBPYmplY3QuYXNzaWduKHt9LCBvKSk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2ggPSBoYXNoO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub3JkZXJzSGFzaCkge1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVPcmRlclJlZmVyZW5jZSh0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkT3JkZXJSZWZlcmVuY2Uoc3RhdGUub3JkZXJzSGFzaCxcbiAgICAgICAgdGhpcy5pZCwgaW5zdGFuY2VJbmRleCk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2ggPSBzdGF0ZS5vcmRlcnNIYXNoO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVPcmRlclJlZmVyZW5jZSh0aGlzLmlkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5hZGRPcmRlclJlZmVyZW5jZShzdGF0ZS5vcmRlcnNIYXNoLFxuICAgICAgICB0aGlzLmlkLCB0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2dnZXIudHJhY2UoKCkgPT4gYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fToke3N5bmNocm9uaXphdGlvbklkfTogYXNzaWduZWQgc3BlY2lmaWNhdGlvbnMgdG8gYCArXG4gICAgICAnY29tYmluZWQgc3RhdGUgZnJvbSAnICtcbiAgICAgIGAke2luc3RhbmNlSW5kZXh9LCAke09iamVjdC5rZXlzKHN0YXRlLnNwZWNpZmljYXRpb25zQnlTeW1ib2wgfHwge30pLmxlbmd0aH0gc3BlY2lmaWNhdGlvbnMgYXNzaWduZWRgKTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICBpZiAoT2JqZWN0LmtleXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCB8fCB7fSkubGVuZ3RoKSB7XG4gICAgICBpZihzdGF0ZS5pc1NwZWNpZmljYXRpb25zRXhwZWN0ZWQpIHtcbiAgICAgICAgY29uc3QgaGFzaCA9IGF3YWl0IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVjb3JkU3BlY2lmaWNhdGlvbnModGhpcy5fYWNjb3VudC5zZXJ2ZXIsXG4gICAgICAgICAgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCwgaW5zdGFuY2VJbmRleCwgT2JqZWN0LnZhbHVlcyhzdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sKSk7XG4gICAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgICAgc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYoc3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKSB7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBhd2FpdCB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnVwZGF0ZVNwZWNpZmljYXRpb25zKHRoaXMuX2FjY291bnQuc2VydmVyLFxuICAgICAgICAgIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsIGluc3RhbmNlSW5kZXgsIE9iamVjdC52YWx1ZXMoc3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCksXG4gICAgICAgICAgW10sIHN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCk7XG4gICAgICAgIHN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IGhhc2g7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gpIHtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIucmVtb3ZlU3BlY2lmaWNhdGlvblJlZmVyZW5jZSh0aGlzLmlkLCBpbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkU3BlY2lmaWNhdGlvblJlZmVyZW5jZShzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gsXG4gICAgICAgIHRoaXMuaWQsIGluc3RhbmNlSW5kZXgpO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2ggPSBzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2g7XG4gICAgICB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnJlbW92ZVNwZWNpZmljYXRpb25SZWZlcmVuY2UodGhpcy5pZCwgdGhpcy5fY29tYmluZWRJbnN0YW5jZUluZGV4KTtcbiAgICAgIHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuYWRkU3BlY2lmaWNhdGlvblJlZmVyZW5jZShzdGF0ZS5zcGVjaWZpY2F0aW9uc0hhc2gsXG4gICAgICAgIHRoaXMuaWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgfVxuICAgIGZvcihsZXQgc3RhdGVJbmRleCBvZiB0aGlzLl9nZXRTdGF0ZUluZGljZXNPZlNhbWVJbnN0YW5jZU51bWJlcihpbnN0YW5jZUluZGV4KSkge1xuICAgICAgaWYgKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtzdGF0ZUluZGV4XS5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RhdGUoc3RhdGVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXJzIGFyZSB1cGRhdGVkIG9yIGNvbXBsZXRlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcGFyYW0ge01ldGF0cmFkZXJPcmRlcltdfSBvcmRlcnMgdXBkYXRlZCBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXJzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNvbXBsZXRlZE9yZGVySWRzIGNvbXBsZXRlZCBNZXRhVHJhZGVyIHBlbmRpbmcgb3JkZXIgaWRzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiB0aGUgYXN5bmNocm9ub3VzIGV2ZW50IGlzIHByb2Nlc3NlZFxuICAgKi9cbiAgYXN5bmMgb25QZW5kaW5nT3JkZXJzVXBkYXRlZChpbnN0YW5jZUluZGV4LCBvcmRlcnMsIGNvbXBsZXRlZE9yZGVySWRzKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGNvbXBsZXRlZE9yZGVySWRzLmZvckVhY2goaWQgPT4gdGhpcy5fY29tYmluZWRTdGF0ZS5jb21wbGV0ZWRPcmRlcnNbaWRdID0gZGF0ZSk7XG4gICAgb3JkZXJzID0gdGhpcy5fZmlsdGVyUmVtb3ZlZE9yZGVycyhvcmRlcnMpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzKS5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGlmKHRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzW2lkXSA8IGRhdGUgLSAyNCAqIDYwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21iaW5lZFN0YXRlLmNvbXBsZXRlZE9yZGVyc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZihpbnN0YW5jZVN0YXRlLm9yZGVyc0luaXRpYWxpemVkKSB7XG4gICAgICBjb25zdCB1cGRhdGVQZW5kaW5nT3JkZXJzID0gYXN5bmMgKHN0YXRlLCBpbnN0YW5jZSkgPT4ge1xuICAgICAgICBjb25zdCBoYXNoID0gYXdhaXQgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci51cGRhdGVPcmRlcnModGhpcy5fYWNjb3VudC5pZCwgdGhpcy5fYWNjb3VudC50eXBlLCB0aGlzLl9pZCxcbiAgICAgICAgICBpbnN0YW5jZSwgb3JkZXJzLCBjb21wbGV0ZWRPcmRlcklkcywgc3RhdGUub3JkZXJzSGFzaCk7XG4gICAgICAgIHN0YXRlLm9yZGVyc0hhc2ggPSBoYXNoO1xuICAgICAgfTtcbiAgICAgIGF3YWl0IHVwZGF0ZVBlbmRpbmdPcmRlcnMoaW5zdGFuY2VTdGF0ZSwgaW5zdGFuY2VJbmRleCk7XG4gICAgICBhd2FpdCB1cGRhdGVQZW5kaW5nT3JkZXJzKHRoaXMuX2NvbWJpbmVkU3RhdGUsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlU3RhdGUub3JkZXJzID0gaW5zdGFuY2VTdGF0ZS5vcmRlcnMuZmlsdGVyKG9yZGVyID0+ICFjb21wbGV0ZWRPcmRlcklkcy5pbmNsdWRlcyhvcmRlci5pZCkpO1xuICAgICAgb3JkZXJzLmZvckVhY2gob3JkZXIgPT4ge1xuICAgICAgICBsZXQgaW5kZXggPSBpbnN0YW5jZVN0YXRlLm9yZGVycy5maW5kSW5kZXgobyA9PiBvLmlkID09PSBvcmRlci5pZCk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLm9yZGVyc1tpbmRleF0gPSBvcmRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0YW5jZVN0YXRlLm9yZGVycy5wdXNoKG9yZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBhIHN5bWJvbCBzcGVjaWZpY2F0aW9uIHdhcyB1cGRhdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbnN0YW5jZUluZGV4IGluZGV4IG9mIGFjY291bnQgaW5zdGFuY2UgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7QXJyYXk8TWV0YXRyYWRlclN5bWJvbFNwZWNpZmljYXRpb24+fSBzcGVjaWZpY2F0aW9ucyB1cGRhdGVkIHNwZWNpZmljYXRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gcmVtb3ZlZFN5bWJvbHMgcmVtb3ZlZCBzeW1ib2xzXG4gICAqL1xuICBhc3luYyBvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZChpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9ucywgcmVtb3ZlZFN5bWJvbHMpIHtcbiAgICBsZXQgaW5zdGFuY2VTdGF0ZSA9IHRoaXMuX2dldFN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgIHRoaXMuX3JlZnJlc2hTdGF0ZVVwZGF0ZVRpbWUoaW5zdGFuY2VJbmRleCk7XG4gICAgaWYoIWluc3RhbmNlU3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIGZvciAobGV0IHNwZWNpZmljYXRpb24gb2Ygc3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2VTdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sW3NwZWNpZmljYXRpb24uc3ltYm9sXSA9IHNwZWNpZmljYXRpb247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLnVwZGF0ZVNwZWNpZmljYXRpb25zKHRoaXMuX2FjY291bnQuc2VydmVyLCB0aGlzLl9hY2NvdW50LnR5cGUsXG4gICAgICAgIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4LCBzcGVjaWZpY2F0aW9ucywgcmVtb3ZlZFN5bWJvbHMsIGluc3RhbmNlU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoKTtcbiAgICAgIGluc3RhbmNlU3RhdGUuc3BlY2lmaWNhdGlvbnNIYXNoID0gaGFzaDtcbiAgICAgIGNvbnN0IGNvbWJpbmVkSGFzaCA9IHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIudXBkYXRlU3BlY2lmaWNhdGlvbnModGhpcy5fYWNjb3VudC5zZXJ2ZXIsXG4gICAgICAgIHRoaXMuX2FjY291bnQudHlwZSwgdGhpcy5faWQsIHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCwgc3BlY2lmaWNhdGlvbnMsIHJlbW92ZWRTeW1ib2xzLFxuICAgICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCk7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IGNvbWJpbmVkSGFzaDtcbiAgICB9XG4gICAgdGhpcy5fbG9nZ2VyLnRyYWNlKCgpID0+IGAke3RoaXMuX2FjY291bnQuaWR9OiR7aW5zdGFuY2VJbmRleH06IHVwZGF0ZWQgJHtzcGVjaWZpY2F0aW9ucy5sZW5ndGh9IHNwZWNpZmljYXRpb25zLCBgICtcbiAgICAgIGByZW1vdmVkICR7cmVtb3ZlZFN5bWJvbHMubGVuZ3RofSBzcGVjaWZpY2F0aW9ucy4gVGhlcmUgYXJlIGAgK1xuICAgICAgYCR7T2JqZWN0LmtleXMoaW5zdGFuY2VTdGF0ZS5zcGVjaWZpY2F0aW9uc0J5U3ltYm9sIHx8IHt9KS5sZW5ndGh9IHNwZWNpZmljYXRpb25zIGFmdGVyIHVwZGF0ZWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiBwcmljZXMgZm9yIHNldmVyYWwgc3ltYm9scyB3ZXJlIHVwZGF0ZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluc3RhbmNlSW5kZXggaW5kZXggb2YgYW4gYWNjb3VudCBpbnN0YW5jZSBjb25uZWN0ZWRcbiAgICogQHBhcmFtIHtBcnJheTxNZXRhdHJhZGVyU3ltYm9sUHJpY2U+fSBwcmljZXMgdXBkYXRlZCBNZXRhVHJhZGVyIHN5bWJvbCBwcmljZXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVxdWl0eSBhY2NvdW50IGxpcXVpZGF0aW9uIHZhbHVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXJnaW4gbWFyZ2luIHVzZWRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyZWVNYXJnaW4gZnJlZSBtYXJnaW5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1hcmdpbkxldmVsIG1hcmdpbiBsZXZlbCBjYWxjdWxhdGVkIGFzICUgb2YgZXF1aXR5L21hcmdpblxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgb25TeW1ib2xQcmljZXNVcGRhdGVkKGluc3RhbmNlSW5kZXgsIHByaWNlcywgZXF1aXR5LCBtYXJnaW4sIGZyZWVNYXJnaW4sIG1hcmdpbkxldmVsKSB7XG4gICAgbGV0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB0aGlzLl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHksbWF4LXN0YXRlbWVudHNcbiAgICBjb25zdCB1cGRhdGVTeW1ib2xQcmljZXMgPSAoc3RhdGUpID0+IHtcbiAgICAgIGxldCBwcmljZXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgbGV0IHByaWNlVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgcHJpY2Ugb2YgcHJpY2VzIHx8IFtdKSB7XG4gICAgICAgIGxldCBjdXJyZW50UHJpY2UgPSBzdGF0ZS5wcmljZXNCeVN5bWJvbFtwcmljZS5zeW1ib2xdO1xuICAgICAgICBpZiAoY3VycmVudFByaWNlICYmIGN1cnJlbnRQcmljZS50aW1lLmdldFRpbWUoKSA+IHByaWNlLnRpbWUuZ2V0VGltZSgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJpY2VVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YXRlLmxhc3RRdW90ZVRpbWUgfHwgc3RhdGUubGFzdFF1b3RlVGltZS5nZXRUaW1lKCkgPCBwcmljZS50aW1lLmdldFRpbWUoKSkge1xuICAgICAgICAgIHN0YXRlLmxhc3RRdW90ZVRpbWUgPSBwcmljZS50aW1lO1xuICAgICAgICAgIHN0YXRlLmxhc3RRdW90ZUJyb2tlclRpbWUgPSBwcmljZS5icm9rZXJUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnByaWNlc0J5U3ltYm9sW3ByaWNlLnN5bWJvbF0gPSBwcmljZTtcbiAgICAgICAgY29uc3QgYWxsUG9zaXRpb25zID0gT2JqZWN0LnZhbHVlcyh0aGlzLl90ZXJtaW5hbEhhc2hNYW5hZ2VyLmdldFBvc2l0aW9uc0J5SGFzaChcbiAgICAgICAgICBzdGF0ZS5wb3NpdGlvbnNIYXNoKSB8fCB7fSk7XG4gICAgICAgIGNvbnN0IGFsbE9yZGVycyA9IE9iamVjdC52YWx1ZXModGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5nZXRPcmRlcnNCeUhhc2goXG4gICAgICAgICAgc3RhdGUub3JkZXJzSGFzaCkgfHwge30pO1xuICAgICAgICBsZXQgcG9zaXRpb25zID0gYWxsUG9zaXRpb25zLmZpbHRlcihwID0+IHAuc3ltYm9sID09PSBwcmljZS5zeW1ib2wpO1xuICAgICAgICBsZXQgb3RoZXJQb3NpdGlvbnMgPSBhbGxQb3NpdGlvbnMuZmlsdGVyKHAgPT4gcC5zeW1ib2wgIT09IHByaWNlLnN5bWJvbCk7XG4gICAgICAgIGxldCBvcmRlcnMgPSBhbGxPcmRlcnMuZmlsdGVyKG8gPT4gby5zeW1ib2wgPT09IHByaWNlLnN5bWJvbCk7XG4gICAgICAgIHByaWNlc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gb2Ygb3RoZXJQb3NpdGlvbnMpIHtcbiAgICAgICAgICBsZXQgcCA9IHN0YXRlLnByaWNlc0J5U3ltYm9sW3Bvc2l0aW9uLnN5bWJvbF07XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJpY2VzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgcG9zaXRpb24gb2YgcG9zaXRpb25zKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwcmljZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgb3JkZXIgb2Ygb3JkZXJzKSB7XG4gICAgICAgICAgb3JkZXIuY3VycmVudFByaWNlID0gb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZJyB8fCBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVlfTElNSVQnIHx8XG4gICAgICAgICAgICBvcmRlci50eXBlID09PSAnT1JERVJfVFlQRV9CVVlfU1RPUCcgfHwgb3JkZXIudHlwZSA9PT0gJ09SREVSX1RZUEVfQlVZX1NUT1BfTElNSVQnID8gcHJpY2UuYXNrIDogcHJpY2UuYmlkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmljZVJlc29sdmVzID0gdGhpcy5fd2FpdEZvclByaWNlUmVzb2x2ZXNbcHJpY2Uuc3ltYm9sXSB8fCBbXTtcbiAgICAgICAgaWYgKHByaWNlUmVzb2x2ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgcmVzb2x2ZSBvZiBwcmljZVJlc29sdmVzKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl93YWl0Rm9yUHJpY2VSZXNvbHZlc1twcmljZS5zeW1ib2xdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJpY2VVcGRhdGVkICYmIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbikge1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBPYmplY3QudmFsdWVzKHRoaXMuX3Rlcm1pbmFsSGFzaE1hbmFnZXIuZ2V0UG9zaXRpb25zQnlIYXNoKHN0YXRlLnBvc2l0aW9uc0hhc2gpIHx8IHt9KTtcbiAgICAgICAgaWYgKHN0YXRlLnBvc2l0aW9uc0luaXRpYWxpemVkICYmIHByaWNlc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5wbGF0Zm9ybSA9PT0gJ210NScpIHtcbiAgICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5lcXVpdHkgPSBlcXVpdHkgIT09IHVuZGVmaW5lZCA/IGVxdWl0eSA6IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5iYWxhbmNlICtcbiAgICAgICAgICAgICAgcG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwKSA9PiBhY2MgK1xuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoKHAudW5yZWFsaXplZFByb2ZpdCB8fCAwKSAqIDEwMCkgLyAxMDAgKyBNYXRoLnJvdW5kKChwLnN3YXAgfHwgMCkgKiAxMDApIC8gMTAwLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmVxdWl0eSA9IGVxdWl0eSAhPT0gdW5kZWZpbmVkID8gZXF1aXR5IDogc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLmJhbGFuY2UgK1xuICAgICAgICAgICAgcG9zaXRpb25zLnJlZHVjZSgoYWNjLCBwKSA9PiBhY2MgKyBNYXRoLnJvdW5kKChwLnN3YXAgfHwgMCkgKiAxMDApIC8gMTAwICtcbiAgICAgICAgICAgICAgTWF0aC5yb3VuZCgocC5jb21taXNzaW9uIHx8IDApICogMTAwKSAvIDEwMCArIE1hdGgucm91bmQoKHAudW5yZWFsaXplZFByb2ZpdCB8fCAwKSAqIDEwMCkgLyAxMDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ID0gTWF0aC5yb3VuZChzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ICogMTAwKSAvIDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5ID0gZXF1aXR5ICE9PSB1bmRlZmluZWQgPyBlcXVpdHkgOiBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24uZXF1aXR5O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW4gPSBtYXJnaW4gIT09IHVuZGVmaW5lZCA/IG1hcmdpbiA6IHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5tYXJnaW47XG4gICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5mcmVlTWFyZ2luID0gZnJlZU1hcmdpbiAhPT0gdW5kZWZpbmVkID8gZnJlZU1hcmdpbiA6IFxuICAgICAgICAgIHN0YXRlLmFjY291bnRJbmZvcm1hdGlvbi5mcmVlTWFyZ2luO1xuICAgICAgICBzdGF0ZS5hY2NvdW50SW5mb3JtYXRpb24ubWFyZ2luTGV2ZWwgPSBmcmVlTWFyZ2luICE9PSB1bmRlZmluZWQgPyBtYXJnaW5MZXZlbCA6XG4gICAgICAgICAgc3RhdGUuYWNjb3VudEluZm9ybWF0aW9uLm1hcmdpbkxldmVsO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlU3ltYm9sUHJpY2VzKGluc3RhbmNlU3RhdGUpO1xuICAgIHVwZGF0ZVN5bWJvbFByaWNlcyh0aGlzLl9jb21iaW5lZFN0YXRlKTtcbiAgICBmb3IgKGxldCBwcmljZSBvZiBwcmljZXMpIHtcbiAgICAgIGZvciAobGV0IGNhbGwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHMpKSB7XG4gICAgICAgIHRoaXMuX2xvZ2dlci50cmFjZShgJHt0aGlzLl9hY2NvdW50LmlkfToke2luc3RhbmNlSW5kZXh9OiByZWZyZXNoZWQgJHtwcmljZS5zeW1ib2x9IHByaWNlYCk7XG4gICAgICAgIGNhbGwuZXhwZWN0ZWRTeW1ib2xzPy5kZWxldGUocHJpY2Uuc3ltYm9sKTtcbiAgICAgICAgY2FsbC5yZWNlaXZlZFN5bWJvbHMuYWRkKHByaWNlLnN5bWJvbCk7XG4gICAgICAgIGNhbGwucHJvbWlzZS5jaGVjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gYSBzdHJlYW0gZm9yIGFuIGluc3RhbmNlIGluZGV4IGlzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5zdGFuY2VJbmRleCBpbmRleCBvZiBhbiBhY2NvdW50IGluc3RhbmNlIGNvbm5lY3RlZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGFzeW5jaHJvbm91cyBldmVudCBpcyBwcm9jZXNzZWRcbiAgICovXG4gIGFzeW5jIG9uU3RyZWFtQ2xvc2VkKGluc3RhbmNlSW5kZXgpIHtcbiAgICBpZih0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtpbnN0YW5jZUluZGV4XSkge1xuICAgICAgZm9yKGxldCBzdGF0ZUluZGV4IG9mIHRoaXMuX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlU3RhdGUgPSB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFtzdGF0ZUluZGV4XTtcbiAgICAgICAgaWYoIXRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4W2luc3RhbmNlSW5kZXhdLm9yZGVyc0luaXRpYWxpemVkIFxuICAgICAgICAgICAgJiYgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF0ubGFzdFN5bmNVcGRhdGVUaW1lIDw9IGluc3RhbmNlU3RhdGUubGFzdFN5bmNVcGRhdGVUaW1lKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlU3RhdGUoaW5zdGFuY2VJbmRleCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW5zdGFuY2VTdGF0ZS5jb25uZWN0ZWQgJiYgaW5zdGFuY2VTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVN0YXRlKGluc3RhbmNlSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyByZWZyZXNoIG9mIG1vc3QgcmVjZW50IHF1b3RlIHVwZGF0ZXMgZm9yIHN5bWJvbHMgc3Vic2NyaWJlZCB0byBieSB0aGUgdGVybWluYWwsIGFuZCB3YWl0cyBmb3IgdGhlbSBhbGwgdG9cbiAgICogYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgdGVybWluYWwgc3RhdGUuIFRoaXMgbWV0aG9kIGRvZXMgbm90IHdhaXRzIGZvciBhbGwgb3RoZXIgbGlzdGVuZXJzIHRvIHJlY2VpdmUgYW5kIHByb2Nlc3MgdGhlXG4gICAqIHF1b3RlIHVwZGF0ZXNcbiAgICogQHBhcmFtIHtSZWZyZXNoVGVybWluYWxTdGF0ZU9wdGlvbnN9IFtvcHRpb25zXSBhZGRpdGlvbmFsIG9wdGlvbnNcbiAgICogQHJldHVybnMge1Byb21pc2V9IHByb21pc2UgcmVzb2x2aW5nIHdoZW4gdGhlIHRlcm1pbmFsIHN0YXRlIHJlY2VpdmVkIGFuZCBwcm9jZXNzZWQgdGhlIGxhdGVzdCBxdW90ZXNcbiAgICovXG4gIGFzeW5jIHJlZnJlc2hUZXJtaW5hbFN0YXRlKG9wdGlvbnMpIHtcbiAgICBsZXQgY2FsbERhdGEgPSB7XG4gICAgICByZWNlaXZlZFN5bWJvbHM6IG5ldyBTZXQoKVxuICAgIH07XG4gICAgbGV0IGNhbGxJZCA9IHJhbmRvbXN0cmluZy5nZW5lcmF0ZSg4KTtcbiAgICB0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHNbY2FsbElkXSA9IGNhbGxEYXRhO1xuICAgIGNhbGxEYXRhLnByb21pc2UgPSBuZXcgQ29uZGl0aW9uUHJvbWlzZSgoKSA9PiBjYWxsRGF0YS5leHBlY3RlZFN5bWJvbHMgJiYgIWNhbGxEYXRhLmV4cGVjdGVkU3ltYm9scy5zaXplKTtcbiAgICBjYWxsRGF0YS5wcm9taXNlLnRpbWVvdXQoMTAwMCAqIChvcHRpb25zPy50aW1lb3V0SW5TZWNvbmRzID8/IDEwKSwgJ3JlZnJlc2hpbmcgdGVybWluYWwgc3RhdGUgdGltZWQgb3V0Jyk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBzeW1ib2xzID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Q2xpZW50LnJlZnJlc2hUZXJtaW5hbFN0YXRlKHRoaXMuX2FjY291bnQuaWQpLFxuICAgICAgICBjYWxsRGF0YS5wcm9taXNlIC8vIHdpbGwgb25seSB0aHJvdyB0aW1lb3V0IGVycm9yIGF0IHRoaXMgcG9pbnRcbiAgICAgIF0pO1xuICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKGAke3RoaXMuX2FjY291bnQuaWR9OiBleHBlY3RpbmcgZm9yICR7c3ltYm9scy5sZW5ndGggPyBzeW1ib2xzIDogMH0gc3ltYm9scyB0byByZWZyZXNoYCk7XG4gICAgICBsZXQgZXhwZWN0ZWRTeW1ib2xzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChsZXQgc3ltYm9sIG9mIHN5bWJvbHMpIHtcbiAgICAgICAgaWYgKCFjYWxsRGF0YS5yZWNlaXZlZFN5bWJvbHMuaGFzKHN5bWJvbCkpIHtcbiAgICAgICAgICBleHBlY3RlZFN5bWJvbHMuYWRkKHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhbGxEYXRhLmV4cGVjdGVkU3ltYm9scyA9IGV4cGVjdGVkU3ltYm9scztcbiAgICAgIGNhbGxEYXRhLnByb21pc2UuY2hlY2soKTtcbiAgICAgIGF3YWl0IGNhbGxEYXRhLnByb21pc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9wcm9jZXNzVGhyb3R0bGVkUXVvdGVzQ2FsbHNbY2FsbElkXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBjb25uZWN0aW9uIHJlbGF0ZWQgZGF0YSBmcm9tIHRlcm1pbmFsIGhhc2ggbWFuYWdlclxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXgpLmZvckVhY2goaW5zdGFuY2VJbmRleCA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVGcm9tSGFzaE1hbmFnZXIoaW5zdGFuY2VJbmRleCk7XG4gICAgfSk7XG4gICAgdGhpcy5fcmVtb3ZlRnJvbUhhc2hNYW5hZ2VyKHRoaXMuX2NvbWJpbmVkSW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvLyByZXNldHMgY29tYmluZWQgc3RhdGUgYW5kIHJlbW92ZXMgZnJvbSBoYXNoIG1hbmFnZXIgaWYgaGFzIGJlZW4gZGlzY29ubmVjdGVkIGZvciBhIGxvbmcgdGltZVxuICBfY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IoKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZFRvQnJva2VyICYmIHRoaXMuX2NvbWJpbmVkU3RhdGUubGFzdFN0YXR1c1RpbWUgPCBEYXRlLm5vdygpIC0gMzAgKiA2MCAqIDEwMDApIHtcbiAgICAgIHRoaXMuX3JlbW92ZUZyb21IYXNoTWFuYWdlcih0aGlzLl9jb21iaW5lZEluc3RhbmNlSW5kZXgpO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmFjY291bnRJbmZvcm1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUuc3BlY2lmaWNhdGlvbnNCeVN5bWJvbCA9IG51bGw7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnByaWNlc0J5U3ltYm9sID0ge307XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnNwZWNpZmljYXRpb25zSGFzaCA9IG51bGw7XG4gICAgICBcbiAgICAgIHRoaXMuX2NvbWJpbmVkU3RhdGUub3JkZXJzID0gW107XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLm9yZGVyc0hhc2ggPSBudWxsO1xuICAgICAgXG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLnBvc2l0aW9ucyA9IFtdO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNIYXNoID0gbnVsbDtcbiAgICAgIFxuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5vcmRlcnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5wb3NpdGlvbnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fY29tYmluZWRTdGF0ZS5sYXN0U3RhdHVzVGltZSA9IDA7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZVRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jb21iaW5lZFN0YXRlLmxhc3RRdW90ZUJyb2tlclRpbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgX3JlbW92ZVN0YXRlKGluc3RhbmNlSW5kZXgpIHtcbiAgICBkZWxldGUgdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgdGhpcy5fcmVtb3ZlRnJvbUhhc2hNYW5hZ2VyKGluc3RhbmNlSW5kZXgpO1xuICB9XG5cbiAgX3JlbW92ZUZyb21IYXNoTWFuYWdlcihpbnN0YW5jZUluZGV4KSB7XG4gICAgdGhpcy5fdGVybWluYWxIYXNoTWFuYWdlci5yZW1vdmVDb25uZWN0aW9uUmVmZXJlbmNlcyh0aGlzLl9hY2NvdW50LnNlcnZlcixcbiAgICAgIHRoaXMuX2FjY291bnQuaWQsIHRoaXMuX2lkLCBpbnN0YW5jZUluZGV4KTtcbiAgfVxuXG4gIF9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lKGluc3RhbmNlSW5kZXgpe1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVCeUluc3RhbmNlSW5kZXhbaW5zdGFuY2VJbmRleF07XG4gICAgaWYoc3RhdGUgJiYgc3RhdGUub3JkZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXRlLmxhc3RTeW5jVXBkYXRlVGltZSA9IERhdGUubm93KCk7XG4gICAgfVxuICB9XG5cbiAgX2dldFN0YXRlSW5kaWNlc09mU2FtZUluc3RhbmNlTnVtYmVyKGluc3RhbmNlSW5kZXgpIHtcbiAgICBjb25zdCByZWdpb24gPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMF07XG4gICAgY29uc3QgaW5zdGFuY2VOdW1iZXIgPSBpbnN0YW5jZUluZGV4LnNwbGl0KCc6JylbMV07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4KVxuICAgICAgLmZpbHRlcihzdGF0ZUluc3RhbmNlSW5kZXggPT4gc3RhdGVJbnN0YW5jZUluZGV4LnN0YXJ0c1dpdGgoYCR7cmVnaW9ufToke2luc3RhbmNlTnVtYmVyfTpgKSAmJiBcbiAgICAgIGluc3RhbmNlSW5kZXggIT09IHN0YXRlSW5zdGFuY2VJbmRleCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICBfdXBkYXRlUG9zaXRpb25Qcm9maXRzKHBvc2l0aW9uLCBwcmljZSkge1xuICAgIGxldCBzcGVjaWZpY2F0aW9uID0gdGhpcy5zcGVjaWZpY2F0aW9uKHBvc2l0aW9uLnN5bWJvbCk7XG4gICAgaWYgKHNwZWNpZmljYXRpb24pIHtcbiAgICAgIGxldCBtdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHNwZWNpZmljYXRpb24uZGlnaXRzKTtcbiAgICAgIGlmIChwb3NpdGlvbi5wcm9maXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi5wcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24ucmVhbGl6ZWRQcm9maXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3NpdGlvbi51bnJlYWxpemVkUHJvZml0ID0gKHBvc2l0aW9uLnR5cGUgPT09ICdQT1NJVElPTl9UWVBFX0JVWScgPyAxIDogLTEpICpcbiAgICAgICAgICAocG9zaXRpb24uY3VycmVudFByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIHBvc2l0aW9uLmN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICAgIHBvc2l0aW9uLnZvbHVtZSAvIHNwZWNpZmljYXRpb24udGlja1NpemU7XG4gICAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSBNYXRoLnJvdW5kKHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICAgIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0ID0gcG9zaXRpb24ucHJvZml0IC0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdDtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdQb3NpdGlvblByaWNlID0gcG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IHByaWNlLmJpZCA6IHByaWNlLmFzaztcbiAgICAgIGxldCBpc1Byb2ZpdGFibGUgPSAocG9zaXRpb24udHlwZSA9PT0gJ1BPU0lUSU9OX1RZUEVfQlVZJyA/IDEgOiAtMSkgKiAobmV3UG9zaXRpb25QcmljZSAtIHBvc2l0aW9uLm9wZW5QcmljZSk7XG4gICAgICBsZXQgY3VycmVudFRpY2tWYWx1ZSA9IChpc1Byb2ZpdGFibGUgPiAwID8gcHJpY2UucHJvZml0VGlja1ZhbHVlIDogcHJpY2UubG9zc1RpY2tWYWx1ZSk7XG4gICAgICBsZXQgdW5yZWFsaXplZFByb2ZpdCA9IChwb3NpdGlvbi50eXBlID09PSAnUE9TSVRJT05fVFlQRV9CVVknID8gMSA6IC0xKSAqXG4gICAgICAgIChuZXdQb3NpdGlvblByaWNlIC0gcG9zaXRpb24ub3BlblByaWNlKSAqIGN1cnJlbnRUaWNrVmFsdWUgKlxuICAgICAgICBwb3NpdGlvbi52b2x1bWUgLyBzcGVjaWZpY2F0aW9uLnRpY2tTaXplO1xuICAgICAgdW5yZWFsaXplZFByb2ZpdCA9IE1hdGgucm91bmQodW5yZWFsaXplZFByb2ZpdCAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbiAgICAgIHBvc2l0aW9uLnVucmVhbGl6ZWRQcm9maXQgPSB1bnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gcG9zaXRpb24udW5yZWFsaXplZFByb2ZpdCArIHBvc2l0aW9uLnJlYWxpemVkUHJvZml0O1xuICAgICAgcG9zaXRpb24ucHJvZml0ID0gTWF0aC5yb3VuZChwb3NpdGlvbi5wcm9maXQgKiBtdWx0aXBsaWVyKSAvIG11bHRpcGxpZXI7XG4gICAgICBwb3NpdGlvbi5jdXJyZW50UHJpY2UgPSBuZXdQb3NpdGlvblByaWNlO1xuICAgICAgcG9zaXRpb24uY3VycmVudFRpY2tWYWx1ZSA9IGN1cnJlbnRUaWNrVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgcmV0dXJuIHBvc2l0aW9ucy5maWx0ZXIocG9zaXRpb24gPT4gIXRoaXMuX2NvbWJpbmVkU3RhdGUucmVtb3ZlZFBvc2l0aW9uc1twb3NpdGlvbi5pZF0pO1xuICB9XG5cbiAgX2ZpbHRlclJlbW92ZWRPcmRlcnMob3JkZXJzKSB7XG4gICAgcmV0dXJuIG9yZGVycy5maWx0ZXIob3JkZXIgPT4gIXRoaXMuX2NvbWJpbmVkU3RhdGUuY29tcGxldGVkT3JkZXJzW29yZGVyLmlkXSk7XG4gIH1cbiAgXG4gIF9nZXRTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdKSB7XG4gICAgICB0aGlzLl9sb2dnZXIudHJhY2UoYCR7dGhpcy5fYWNjb3VudC5pZH06JHtpbnN0YW5jZUluZGV4fTogY29uc3RydWN0ZWQgbmV3IHN0YXRlYCk7XG4gICAgICB0aGlzLl9zdGF0ZUJ5SW5zdGFuY2VJbmRleFsnJyArIGluc3RhbmNlSW5kZXhdID0gdGhpcy5fY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlQnlJbnN0YW5jZUluZGV4WycnICsgaW5zdGFuY2VJbmRleF07XG4gIH1cblxuICBfY29uc3RydWN0VGVybWluYWxTdGF0ZShpbnN0YW5jZUluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluc3RhbmNlSW5kZXgsXG4gICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgY29ubmVjdGVkVG9Ccm9rZXI6IGZhbHNlLFxuICAgICAgYWNjb3VudEluZm9ybWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICBwb3NpdGlvbnM6IFtdLFxuICAgICAgb3JkZXJzOiBbXSxcbiAgICAgIHNwZWNpZmljYXRpb25zQnlTeW1ib2w6IHt9LFxuICAgICAgcHJpY2VzQnlTeW1ib2w6IHt9LFxuICAgICAgb3JkZXJzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgcG9zaXRpb25zSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgbGFzdFN5bmNVcGRhdGVUaW1lOiAwLFxuICAgICAgcG9zaXRpb25zSGFzaDogbnVsbCxcbiAgICAgIG9yZGVyc0hhc2g6IG51bGwsXG4gICAgICBzcGVjaWZpY2F0aW9uc0hhc2g6IG51bGwsXG4gICAgICBpc1NwZWNpZmljYXRpb25zRXhwZWN0ZWQ6IHRydWUsXG4gICAgICBpc1Bvc2l0aW9uc0V4cGVjdGVkOiB0cnVlLFxuICAgICAgaXNPcmRlcnNFeHBlY3RlZDogdHJ1ZSxcbiAgICAgIGxhc3RRdW90ZVRpbWU6IHVuZGVmaW5lZCxcbiAgICAgIGxhc3RRdW90ZUJyb2tlclRpbWU6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxufVxuIl0sIm5hbWVzIjpbIlRlcm1pbmFsU3RhdGUiLCJTeW5jaHJvbml6YXRpb25MaXN0ZW5lciIsImlkIiwiX2lkIiwiY29ubmVjdGVkIiwiT2JqZWN0IiwidmFsdWVzIiwiX3N0YXRlQnlJbnN0YW5jZUluZGV4IiwicmVkdWNlIiwiYWNjIiwicyIsImNvbm5lY3RlZFRvQnJva2VyIiwiYWNjb3VudEluZm9ybWF0aW9uIiwiX2NvbWJpbmVkU3RhdGUiLCJwb3NpdGlvbnMiLCJoYXNoIiwicG9zaXRpb25zSGFzaCIsIl90ZXJtaW5hbEhhc2hNYW5hZ2VyIiwiZ2V0UG9zaXRpb25zQnlIYXNoIiwib3JkZXJzIiwib3JkZXJzSGFzaCIsImdldE9yZGVyc0J5SGFzaCIsInNwZWNpZmljYXRpb25zIiwic3BlY2lmaWNhdGlvbnNIYXNoIiwiZ2V0U3BlY2lmaWNhdGlvbnNCeUhhc2giLCJnZXRIYXNoZXMiLCJzcGVjaWZpY2F0aW9uc0hhc2hlcyIsImdldExhc3RVc2VkU3BlY2lmaWNhdGlvbkhhc2hlcyIsIl9hY2NvdW50Iiwic2VydmVyIiwicG9zaXRpb25zSGFzaGVzIiwiZ2V0TGFzdFVzZWRQb3NpdGlvbkhhc2hlcyIsIm9yZGVyc0hhc2hlcyIsImdldExhc3RVc2VkT3JkZXJIYXNoZXMiLCJzcGVjaWZpY2F0aW9uIiwic3ltYm9sIiwic3RhdGUiLCJwcmljZSIsInByaWNlc0J5U3ltYm9sIiwibGFzdFF1b3RlVGltZSIsInRpbWUiLCJicm9rZXJUaW1lIiwibGFzdFF1b3RlQnJva2VyVGltZSIsInVuZGVmaW5lZCIsIndhaXRGb3JQcmljZSIsInRpbWVvdXRJblNlY29uZHMiLCJfd2FpdEZvclByaWNlUmVzb2x2ZXMiLCJQcm9taXNlIiwicmFjZSIsInJlcyIsInB1c2giLCJzZXRUaW1lb3V0Iiwib25Db25uZWN0ZWQiLCJpbnN0YW5jZUluZGV4IiwiX2dldFN0YXRlIiwib25EaXNjb25uZWN0ZWQiLCJvbkJyb2tlckNvbm5lY3Rpb25TdGF0dXNDaGFuZ2VkIiwibGFzdFN0YXR1c1RpbWUiLCJEYXRlIiwibm93Iiwib25TeW5jaHJvbml6YXRpb25TdGFydGVkIiwic3luY2hyb25pemF0aW9uSWQiLCJ1bnN5bmNocm9uaXplZFN0YXRlcyIsIl9nZXRTdGF0ZUluZGljZXNPZlNhbWVJbnN0YW5jZU51bWJlciIsImZpbHRlciIsInN0YXRlSW5kZXgiLCJvcmRlcnNJbml0aWFsaXplZCIsInNvcnQiLCJhIiwiYiIsImxhc3RTeW5jVXBkYXRlVGltZSIsInNsaWNlIiwiZm9yRWFjaCIsIl9yZW1vdmVTdGF0ZSIsImlzU3BlY2lmaWNhdGlvbnNFeHBlY3RlZCIsImlzUG9zaXRpb25zRXhwZWN0ZWQiLCJpc09yZGVyc0V4cGVjdGVkIiwicG9zaXRpb25zSW5pdGlhbGl6ZWQiLCJzcGVjaWZpY2F0aW9uc0J5U3ltYm9sIiwiX2xvZ2dlciIsInRyYWNlIiwia2V5cyIsImxlbmd0aCIsIm9uQWNjb3VudEluZm9ybWF0aW9uVXBkYXRlZCIsIl9yZWZyZXNoU3RhdGVVcGRhdGVUaW1lIiwiYXNzaWduIiwib25Qb3NpdGlvbnNSZXBsYWNlZCIsIm9uUG9zaXRpb25zU3luY2hyb25pemVkIiwib25Qb3NpdGlvbnNVcGRhdGVkIiwicmVtb3ZlZFBvc2l0aW9uSWRzIiwiaW5zdGFuY2VTdGF0ZSIsImRhdGUiLCJyZW1vdmVkUG9zaXRpb25zIiwiX2ZpbHRlclJlbW92ZWRQb3NpdGlvbnMiLCJ1cGRhdGVQb3NpdGlvbnMiLCJpbnN0YW5jZSIsInR5cGUiLCJfY29tYmluZWRJbnN0YW5jZUluZGV4IiwicG9zaXRpb24iLCJpbmNsdWRlcyIsImluZGV4IiwiZmluZEluZGV4IiwicCIsIm9uUGVuZGluZ09yZGVyc1JlcGxhY2VkIiwib25QZW5kaW5nT3JkZXJzU3luY2hyb25pemVkIiwicmVjb3JkUG9zaXRpb25zIiwibWFwIiwicmVtb3ZlUG9zaXRpb25SZWZlcmVuY2UiLCJhZGRQb3NpdGlvblJlZmVyZW5jZSIsIl9maWx0ZXJSZW1vdmVkT3JkZXJzIiwicmVjb3JkT3JkZXJzIiwibyIsInJlbW92ZU9yZGVyUmVmZXJlbmNlIiwiYWRkT3JkZXJSZWZlcmVuY2UiLCJyZWNvcmRTcGVjaWZpY2F0aW9ucyIsInVwZGF0ZVNwZWNpZmljYXRpb25zIiwicmVtb3ZlU3BlY2lmaWNhdGlvblJlZmVyZW5jZSIsImFkZFNwZWNpZmljYXRpb25SZWZlcmVuY2UiLCJvblBlbmRpbmdPcmRlcnNVcGRhdGVkIiwiY29tcGxldGVkT3JkZXJJZHMiLCJjb21wbGV0ZWRPcmRlcnMiLCJ1cGRhdGVQZW5kaW5nT3JkZXJzIiwidXBkYXRlT3JkZXJzIiwib3JkZXIiLCJvblN5bWJvbFNwZWNpZmljYXRpb25zVXBkYXRlZCIsInJlbW92ZWRTeW1ib2xzIiwiY29tYmluZWRIYXNoIiwib25TeW1ib2xQcmljZXNVcGRhdGVkIiwicHJpY2VzIiwiZXF1aXR5IiwibWFyZ2luIiwiZnJlZU1hcmdpbiIsIm1hcmdpbkxldmVsIiwidXBkYXRlU3ltYm9sUHJpY2VzIiwicHJpY2VzSW5pdGlhbGl6ZWQiLCJwcmljZVVwZGF0ZWQiLCJjdXJyZW50UHJpY2UiLCJnZXRUaW1lIiwiYWxsUG9zaXRpb25zIiwiYWxsT3JkZXJzIiwib3RoZXJQb3NpdGlvbnMiLCJ1bnJlYWxpemVkUHJvZml0IiwiX3VwZGF0ZVBvc2l0aW9uUHJvZml0cyIsImFzayIsImJpZCIsInByaWNlUmVzb2x2ZXMiLCJyZXNvbHZlIiwicGxhdGZvcm0iLCJiYWxhbmNlIiwiTWF0aCIsInJvdW5kIiwic3dhcCIsImNvbW1pc3Npb24iLCJjYWxsIiwiX3Byb2Nlc3NUaHJvdHRsZWRRdW90ZXNDYWxscyIsImV4cGVjdGVkU3ltYm9scyIsImRlbGV0ZSIsInJlY2VpdmVkU3ltYm9scyIsImFkZCIsInByb21pc2UiLCJjaGVjayIsIm9uU3RyZWFtQ2xvc2VkIiwicmVmcmVzaFRlcm1pbmFsU3RhdGUiLCJvcHRpb25zIiwiY2FsbERhdGEiLCJTZXQiLCJjYWxsSWQiLCJyYW5kb21zdHJpbmciLCJnZW5lcmF0ZSIsIkNvbmRpdGlvblByb21pc2UiLCJzaXplIiwidGltZW91dCIsInN5bWJvbHMiLCJfd2Vic29ja2V0Q2xpZW50IiwiZGVidWciLCJoYXMiLCJjbG9zZSIsIl9yZW1vdmVGcm9tSGFzaE1hbmFnZXIiLCJfY2hlY2tDb21iaW5lZFN0YXRlQWN0aXZpdHlKb2IiLCJyZW1vdmVDb25uZWN0aW9uUmVmZXJlbmNlcyIsInJlZ2lvbiIsInNwbGl0IiwiaW5zdGFuY2VOdW1iZXIiLCJzdGF0ZUluc3RhbmNlSW5kZXgiLCJzdGFydHNXaXRoIiwibXVsdGlwbGllciIsInBvdyIsImRpZ2l0cyIsInByb2ZpdCIsInJlYWxpemVkUHJvZml0Iiwib3BlblByaWNlIiwiY3VycmVudFRpY2tWYWx1ZSIsInZvbHVtZSIsInRpY2tTaXplIiwibmV3UG9zaXRpb25QcmljZSIsImlzUHJvZml0YWJsZSIsInByb2ZpdFRpY2tWYWx1ZSIsImxvc3NUaWNrVmFsdWUiLCJfY29uc3RydWN0VGVybWluYWxTdGF0ZSIsImNvbnN0cnVjdG9yIiwiYWNjb3VudCIsInRlcm1pbmFsSGFzaE1hbmFnZXIiLCJ3ZWJzb2NrZXRDbGllbnQiLCJMb2dnZXJNYW5hZ2VyIiwiZ2V0TG9nZ2VyIiwiYmluZCIsInNldEludGVydmFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7OztlQWFxQkE7OztxRUFYSTtnRkFDVzsrRUFDRDsrREFDVDs0RUFDTTswRUFDRjswQkFDQzs7Ozs7O0FBS2hCLElBQUEsQUFBTUEsZ0JBQU4sTUFBTUEsc0JBQXNCQyxnQ0FBdUI7SUF3Q2hFLElBQUlDLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQ0MsR0FBRztJQUNqQjtJQUVBOzs7R0FHQyxHQUNELElBQUlDLFlBQVk7UUFDZCxPQUFPQyxPQUFPQyxNQUFNLENBQUMsSUFBSSxDQUFDQyxxQkFBcUIsRUFBRUMsTUFBTSxDQUFDLENBQUNDLEtBQUtDLElBQU1ELE9BQU9DLEVBQUVOLFNBQVMsRUFBRTtJQUMxRjtJQUVBOzs7O0dBSUMs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